---
ms.openlocfilehash: 6cf489595654236c18edee94c0af380e605c9571
ms.sourcegitcommit: f61a06970fa0562d2e40363fae3948eb168624ca
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/14/2020
ms.locfileid: "79485172"
---
# <a name="private-protected"></a><span data-ttu-id="556ea-101">private protected</span><span class="sxs-lookup"><span data-stu-id="556ea-101">private protected</span></span>

* <span data-ttu-id="556ea-102">[x] 提議</span><span class="sxs-lookup"><span data-stu-id="556ea-102">[x] Proposed</span></span>
* <span data-ttu-id="556ea-103">[x] 原型：[完成](https://github.com/dotnet/roslyn/blob/master/docs/features/private-protected.md)</span><span class="sxs-lookup"><span data-stu-id="556ea-103">[x] Prototype: [Complete](https://github.com/dotnet/roslyn/blob/master/docs/features/private-protected.md)</span></span>
* <span data-ttu-id="556ea-104">[x] 執行：[完成](https://github.com/dotnet/roslyn/blob/master/docs/features/private-protected.md)</span><span class="sxs-lookup"><span data-stu-id="556ea-104">[x] Implementation: [Complete](https://github.com/dotnet/roslyn/blob/master/docs/features/private-protected.md)</span></span>
* <span data-ttu-id="556ea-105">[x] 規格：[完成](#detailed-design)</span><span class="sxs-lookup"><span data-stu-id="556ea-105">[x] Specification: [Complete](#detailed-design)</span></span>

## <a name="summary"></a><span data-ttu-id="556ea-106">摘要</span><span class="sxs-lookup"><span data-stu-id="556ea-106">Summary</span></span>
[summary]: #summary

<span data-ttu-id="556ea-107">在中C#將 CLR `protectedAndInternal` 存取範圍層級公開為 `private protected`。</span><span class="sxs-lookup"><span data-stu-id="556ea-107">Expose the CLR `protectedAndInternal` accessibility level in C# as `private protected`.</span></span>

## <a name="motivation"></a><span data-ttu-id="556ea-108">動機</span><span class="sxs-lookup"><span data-stu-id="556ea-108">Motivation</span></span>
[motivation]: #motivation

<span data-ttu-id="556ea-109">在許多情況下，API 包含的成員僅適用于提供該類型之元件中所包含的子類別。</span><span class="sxs-lookup"><span data-stu-id="556ea-109">There are many circumstances in which an API contains members that are only intended to be implemented and used by subclasses contained in the assembly that provides the type.</span></span> <span data-ttu-id="556ea-110">雖然 CLR 會針對該目的提供存取範圍層級，但無法在中C#使用。</span><span class="sxs-lookup"><span data-stu-id="556ea-110">While the CLR provides an accessibility level for that purpose, it is not available in C#.</span></span> <span data-ttu-id="556ea-111">因此，API 擁有者會強制使用 `internal` 保護和自我專業領域或自訂分析器，或使用具有其他檔的 `protected`，其中說明，當成員出現在該類型的公開檔中時，它就不是公用 API 的一部分。</span><span class="sxs-lookup"><span data-stu-id="556ea-111">Consequently API owners are forced to either use `internal` protection and self-discipline or a custom analyzer, or to use `protected` with additional documentation explaining that, while the member appears in the public documentation for the type, it is not intended to be part of the public API.</span></span>  <span data-ttu-id="556ea-112">如需後者的範例，請參閱其名稱開頭為 `Common`的 Roslyn `CSharpCompilationOptions` 成員。</span><span class="sxs-lookup"><span data-stu-id="556ea-112">For examples of the latter, see members of Roslyn's `CSharpCompilationOptions` whose names start with `Common`.</span></span>

<span data-ttu-id="556ea-113">直接在中C#提供此存取層級的支援，可讓您在語言中以自然方式表示這些情況。</span><span class="sxs-lookup"><span data-stu-id="556ea-113">Directly providing support for this access level in C# enables these circumstances to be expressed naturally in the language.</span></span>

## <a name="detailed-design"></a><span data-ttu-id="556ea-114">詳細設計</span><span class="sxs-lookup"><span data-stu-id="556ea-114">Detailed design</span></span>
[design]: #detailed-design

### <a name="private-protected-access-modifier"></a><span data-ttu-id="556ea-115">`private protected` 存取修飾詞</span><span class="sxs-lookup"><span data-stu-id="556ea-115">`private protected` access modifier</span></span>

<span data-ttu-id="556ea-116">我們建議您新增新的存取修飾片語合 `private protected` （可在修飾詞之間以任何順序出現）。</span><span class="sxs-lookup"><span data-stu-id="556ea-116">We propose to add a new access modifier combination `private protected` (which can appear in any order among the modifiers).</span></span> <span data-ttu-id="556ea-117">這會對應到 protectedAndInternal 的 CLR 概念，並且會借用目前在[ C++/cli](https://docs.microsoft.com/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli#BKMK_Member_visibility)中使用的相同語法。</span><span class="sxs-lookup"><span data-stu-id="556ea-117">This maps to the CLR notion of protectedAndInternal, and borrows the same syntax currently used in [C++/CLI](https://docs.microsoft.com/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli#BKMK_Member_visibility).</span></span>

<span data-ttu-id="556ea-118">如果該子類別與成員位於相同的元件，則可以在其容器的子類別記憶體取已宣告 `private protected` 的成員。</span><span class="sxs-lookup"><span data-stu-id="556ea-118">A member declared `private protected` can be accessed within a subclass of its container if that subclass is in the same assembly as the member.</span></span>

<span data-ttu-id="556ea-119">我們修改語言規格，如下所示（粗體新增）。</span><span class="sxs-lookup"><span data-stu-id="556ea-119">We modify the language specification as follows (additions in bold).</span></span> <span data-ttu-id="556ea-120">區段編號不會顯示在下方，因為它們可能會根據其整合的規格版本而有所不同。</span><span class="sxs-lookup"><span data-stu-id="556ea-120">Section numbers are not shown below as they may vary depending on which version of the specification it is integrated into.</span></span>

-----

> <span data-ttu-id="556ea-121">成員的宣告存取範圍可以是下列其中一項：</span><span class="sxs-lookup"><span data-stu-id="556ea-121">The declared accessibility of a member can be one of the following:</span></span>
- <span data-ttu-id="556ea-122">Public，其選取方式是在成員宣告中包含公用修飾詞。</span><span class="sxs-lookup"><span data-stu-id="556ea-122">Public, which is selected by including a public modifier in the member declaration.</span></span> <span data-ttu-id="556ea-123">「公用」的直覺意義是「存取不受限制」。</span><span class="sxs-lookup"><span data-stu-id="556ea-123">The intuitive meaning of public is “access not limited”.</span></span>
- <span data-ttu-id="556ea-124">Protected，由在成員宣告中包含 protected 修飾詞來選取。</span><span class="sxs-lookup"><span data-stu-id="556ea-124">Protected, which is selected by including a protected modifier in the member declaration.</span></span> <span data-ttu-id="556ea-125">受保護的直覺意義是「存取限於包含類別或衍生自包含類別的類型」。</span><span class="sxs-lookup"><span data-stu-id="556ea-125">The intuitive meaning of protected is “access limited to the containing class or types derived from the containing class”.</span></span>
- <span data-ttu-id="556ea-126">內部：在成員宣告中包含內部修飾詞，以選取此選項。</span><span class="sxs-lookup"><span data-stu-id="556ea-126">Internal, which is selected by including an internal modifier in the member declaration.</span></span> <span data-ttu-id="556ea-127">「內部」的直覺意義是「存取限於此元件」。</span><span class="sxs-lookup"><span data-stu-id="556ea-127">The intuitive meaning of internal is “access limited to this assembly”.</span></span>
- <span data-ttu-id="556ea-128">受保護的內部，其選取方式是在成員宣告中包含 protected 和 internal 修飾詞。</span><span class="sxs-lookup"><span data-stu-id="556ea-128">Protected internal, which is selected by including both a protected and an internal modifier in the member declaration.</span></span> <span data-ttu-id="556ea-129">受保護內部的直覺意義是「可在此元件記憶體取，以及衍生自包含類別的類型」。</span><span class="sxs-lookup"><span data-stu-id="556ea-129">The intuitive meaning of protected internal is “accessible within this assembly as well as types derived from the containing class”.</span></span>
- <span data-ttu-id="556ea-130">**私用保護，其選取方式是在成員宣告中包含私用和受保護的修飾詞。私用保護的直覺意義是「由衍生自包含類別的類型，在此元件中可供存取」。**</span><span class="sxs-lookup"><span data-stu-id="556ea-130">**Private protected, which is selected by including both a private and a protected modifier in the member declaration. The intuitive meaning of private protected is “accessible within this assembly by types derived from the containing class”.**</span></span>

-----

> <span data-ttu-id="556ea-131">視成員宣告發生的內容而定，只允許特定類型的已宣告存取範圍。</span><span class="sxs-lookup"><span data-stu-id="556ea-131">Depending on the context in which a member declaration takes place, only certain types of declared accessibility are permitted.</span></span> <span data-ttu-id="556ea-132">此外，當成員宣告不包含任何存取修飾詞時，宣告所處的內容會決定預設宣告的存取範圍。</span><span class="sxs-lookup"><span data-stu-id="556ea-132">Furthermore, when a member declaration does not include any access modifiers, the context in which the declaration takes place determines the default declared accessibility.</span></span> 
- <span data-ttu-id="556ea-133">命名空間隱含具有公開的已宣告存取範圍。</span><span class="sxs-lookup"><span data-stu-id="556ea-133">Namespaces implicitly have public declared accessibility.</span></span> <span data-ttu-id="556ea-134">命名空間宣告上不允許有任何存取修飾詞。</span><span class="sxs-lookup"><span data-stu-id="556ea-134">No access modifiers are allowed on namespace declarations.</span></span>
- <span data-ttu-id="556ea-135">直接在編譯單位或命名空間中宣告的類型（相對於其他類型）可能會有公用或內部宣告的存取範圍，而且預設為內部宣告的協助工具。</span><span class="sxs-lookup"><span data-stu-id="556ea-135">Types declared directly in compilation units or namespaces (as opposed to within other types) can have public or internal declared accessibility and default to internal declared accessibility.</span></span>
- <span data-ttu-id="556ea-136">類別成員可以有五種宣告存取範圍的任何一種，而且預設為私用宣告的存取範圍。</span><span class="sxs-lookup"><span data-stu-id="556ea-136">Class members can have any of the five kinds of declared accessibility and default to private declared accessibility.</span></span> <span data-ttu-id="556ea-137">[注意：宣告為類別成員的型別可以有五種宣告的存取範圍，而宣告為命名空間成員的型別可以只有公用或內部宣告的存取範圍。</span><span class="sxs-lookup"><span data-stu-id="556ea-137">[Note: A type declared as a member of a class can have any of the five kinds of declared accessibility, whereas a type declared as a member of a namespace can have only public or internal declared accessibility.</span></span> <span data-ttu-id="556ea-138">結束附注]</span><span class="sxs-lookup"><span data-stu-id="556ea-138">end note]</span></span>
- <span data-ttu-id="556ea-139">結構成員可以有公用、內部或私用的存取範圍，而且預設為私用宣告的存取範圍，因為結構是隱含密封的。</span><span class="sxs-lookup"><span data-stu-id="556ea-139">Struct members can have public, internal, or private declared accessibility and default to private declared accessibility because structs are implicitly sealed.</span></span> <span data-ttu-id="556ea-140">結構中引進的結構成員（也就是，不是由該結構繼承 *），不能有受保護*~~或~~受保護的內部**或私用的受保護**宣告存取範圍。</span><span class="sxs-lookup"><span data-stu-id="556ea-140">Struct members introduced in a struct (that is, not inherited by that struct) cannot have protected *,* ~~or~~ protected internal **, or private protected** declared accessibility.</span></span> <span data-ttu-id="556ea-141">[注意：宣告為結構成員的型別可以有公用、內部或私用的存取範圍，而宣告為命名空間成員的型別可以只有公用或內部宣告的存取範圍。</span><span class="sxs-lookup"><span data-stu-id="556ea-141">[Note: A type declared as a member of a struct can have public, internal, or private declared accessibility, whereas a type declared as a member of a namespace can have only public or internal declared accessibility.</span></span> <span data-ttu-id="556ea-142">結束附注]</span><span class="sxs-lookup"><span data-stu-id="556ea-142">end note]</span></span>
- <span data-ttu-id="556ea-143">介面成員隱含具有公開的已宣告存取範圍。</span><span class="sxs-lookup"><span data-stu-id="556ea-143">Interface members implicitly have public declared accessibility.</span></span> <span data-ttu-id="556ea-144">介面成員宣告上不允許有任何存取修飾詞。</span><span class="sxs-lookup"><span data-stu-id="556ea-144">No access modifiers are allowed on interface member declarations.</span></span>
- <span data-ttu-id="556ea-145">列舉成員隱含具有公開的已宣告存取範圍。</span><span class="sxs-lookup"><span data-stu-id="556ea-145">Enumeration members implicitly have public declared accessibility.</span></span> <span data-ttu-id="556ea-146">列舉成員宣告上不允許有任何存取修飾詞。</span><span class="sxs-lookup"><span data-stu-id="556ea-146">No access modifiers are allowed on enumeration member declarations.</span></span>

-----

> <span data-ttu-id="556ea-147">在程式 P 內的類型 T 中宣告之嵌套成員 M 的存取範圍定義域定義如下（注意 M 本身可能是類型）：</span><span class="sxs-lookup"><span data-stu-id="556ea-147">The accessibility domain of a nested member M declared in a type T within a program P, is defined as follows (noting that M itself might possibly be a type):</span></span>
- <span data-ttu-id="556ea-148">如果 M 的宣告存取範圍是公用的，則 M 的存取範圍網域會是 T 的存取範圍網域。</span><span class="sxs-lookup"><span data-stu-id="556ea-148">If the declared accessibility of M is public, the accessibility domain of M is the accessibility domain of T.</span></span>
- <span data-ttu-id="556ea-149">如果 M 的宣告存取範圍受到保護，請讓 D 成為 P 的程式文字和任何衍生自 T 之類型的程式文字的聯集，而這是在 P 外部宣告。M 的存取範圍定義域是 T 的存取範圍定義域與 D 的交集。</span><span class="sxs-lookup"><span data-stu-id="556ea-149">If the declared accessibility of M is protected internal, let D be the union of the program text of P and the program text of any type derived from T, which is declared outside P. The accessibility domain of M is the intersection of the accessibility domain of T with D.</span></span>
- <span data-ttu-id="556ea-150">**如果 M 的宣告存取範圍已受私用保護，let D 就是 P 的程式文字和任何衍生自 T 之類型的程式文字的交集。M 的存取範圍定義域是 T 的存取範圍定義域與 D 的交集。**</span><span class="sxs-lookup"><span data-stu-id="556ea-150">**If the declared accessibility of M is private protected, let D be the intersection of the program text of P and the program text of any type derived from T. The accessibility domain of M is the intersection of the accessibility domain of T with D.**</span></span>
- <span data-ttu-id="556ea-151">如果 M 的宣告存取範圍受到保護，let D 就是 T 的程式文字和任何衍生自 T 之類型的程式文字的聯集。M 的存取範圍定義域是 T 的存取範圍定義域與 D 的交集。</span><span class="sxs-lookup"><span data-stu-id="556ea-151">If the declared accessibility of M is protected, let D be the union of the program text of T and the program text of any type derived from T. The accessibility domain of M is the intersection of the accessibility domain of T with D.</span></span>
- <span data-ttu-id="556ea-152">如果 M 的宣告存取範圍是內部的，則 M 的存取範圍定義域是 T 的存取範圍定義域與 P 的程式文字的交集。</span><span class="sxs-lookup"><span data-stu-id="556ea-152">If the declared accessibility of M is internal, the accessibility domain of M is the intersection of the accessibility domain of T with the program text of P.</span></span>
- <span data-ttu-id="556ea-153">如果 M 的宣告存取範圍是私用的，M 的存取範圍網域就是 T 的程式文字。</span><span class="sxs-lookup"><span data-stu-id="556ea-153">If the declared accessibility of M is private, the accessibility domain of M is the program text of T.</span></span>

-----

> <span data-ttu-id="556ea-154">當受保護**或私用保護**的實例成員在宣告它的類別的程式文字之外存取時，以及當受保護的內部實例成員在宣告它的程式文字之外存取時，必須在衍生自其宣告所在類別的類別宣告內進行存取。</span><span class="sxs-lookup"><span data-stu-id="556ea-154">When a protected **or private protected** instance member is accessed outside the program text of the class in which it is declared, and when a protected internal instance member is accessed outside the program text of the program in which it is declared, the access shall take place within a class declaration that derives from the class in which it is declared.</span></span> <span data-ttu-id="556ea-155">此外，您必須透過衍生類別型別的實例或從它所構成的類別型別，來進行存取。</span><span class="sxs-lookup"><span data-stu-id="556ea-155">Furthermore, the access is required to take place through an instance of that derived class type or a class type constructed from it.</span></span> <span data-ttu-id="556ea-156">這項限制可防止一個衍生類別存取其他衍生類別的受保護成員，即使成員繼承自相同的基類也一樣。</span><span class="sxs-lookup"><span data-stu-id="556ea-156">This restriction prevents one derived class from accessing protected members of other derived classes, even when the members are inherited from the same base class.</span></span>

-----

> <span data-ttu-id="556ea-157">允許的存取修飾詞和類型宣告的預設存取，取決於宣告發生所在的內容（第9.5.2 節）：</span><span class="sxs-lookup"><span data-stu-id="556ea-157">The permitted access modifiers and the default access for a type declaration depend on the context in which the declaration takes place (§9.5.2):</span></span>
- <span data-ttu-id="556ea-158">在編譯單位或命名空間中宣告的類型，可以有公用或內部存取權。</span><span class="sxs-lookup"><span data-stu-id="556ea-158">Types declared in compilation units or namespaces can have public or internal access.</span></span> <span data-ttu-id="556ea-159">預設值為 [內部存取]。</span><span class="sxs-lookup"><span data-stu-id="556ea-159">The default is internal access.</span></span>
- <span data-ttu-id="556ea-160">在類別中宣告的類型可以有公用、受保護的內部、**私用保護**、受保護、內部或私用存取。</span><span class="sxs-lookup"><span data-stu-id="556ea-160">Types declared in classes can have public, protected internal, **private protected**, protected, internal, or private access.</span></span> <span data-ttu-id="556ea-161">預設為私用存取。</span><span class="sxs-lookup"><span data-stu-id="556ea-161">The default is private access.</span></span>
- <span data-ttu-id="556ea-162">結構中宣告的類型可以有公用、內部或私用存取。</span><span class="sxs-lookup"><span data-stu-id="556ea-162">Types declared in structs can have public, internal, or private access.</span></span> <span data-ttu-id="556ea-163">預設為私用存取。</span><span class="sxs-lookup"><span data-stu-id="556ea-163">The default is private access.</span></span>

-----

> <span data-ttu-id="556ea-164">靜態類別宣告受到下列限制：</span><span class="sxs-lookup"><span data-stu-id="556ea-164">A static class declaration is subject to the following restrictions:</span></span>
- <span data-ttu-id="556ea-165">靜態類別不應包含 sealed 或 abstract 修飾詞。</span><span class="sxs-lookup"><span data-stu-id="556ea-165">A static class shall not include a sealed or abstract modifier.</span></span> <span data-ttu-id="556ea-166">（不過，因為靜態類別無法具現化或衍生自，所以其行為就像是密封和抽象的一樣）。</span><span class="sxs-lookup"><span data-stu-id="556ea-166">(However, since a static class cannot be instantiated or derived from, it behaves as if it was both sealed and abstract.)</span></span>
- <span data-ttu-id="556ea-167">靜態類別不應包含類別基底規格（§16.2.5），而且無法明確指定基類或實作為實介面的清單。</span><span class="sxs-lookup"><span data-stu-id="556ea-167">A static class shall not include a class-base specification (§16.2.5) and cannot explicitly specify a base class or a list of implemented interfaces.</span></span> <span data-ttu-id="556ea-168">靜態類別隱含繼承自型別物件。</span><span class="sxs-lookup"><span data-stu-id="556ea-168">A static class implicitly inherits from type object.</span></span>
- <span data-ttu-id="556ea-169">靜態類別應該只包含靜態成員（§16.4.8）。</span><span class="sxs-lookup"><span data-stu-id="556ea-169">A static class shall only contain static members (§16.4.8).</span></span> <span data-ttu-id="556ea-170">[注意：所有常數和巢狀型別都會分類為靜態成員。</span><span class="sxs-lookup"><span data-stu-id="556ea-170">[Note: All constants and nested types are classified as static members.</span></span> <span data-ttu-id="556ea-171">結束附注]</span><span class="sxs-lookup"><span data-stu-id="556ea-171">end note]</span></span>
- <span data-ttu-id="556ea-172">靜態類別不應該有具有受保護 **、私用保護**或受保護內部宣告存取範圍的成員。</span><span class="sxs-lookup"><span data-stu-id="556ea-172">A static class shall not have members with protected **, private protected** or protected internal declared accessibility.</span></span>

> <span data-ttu-id="556ea-173">這是編譯時期錯誤，違反上述任何一項限制。</span><span class="sxs-lookup"><span data-stu-id="556ea-173">It is a compile-time error to violate any of these restrictions.</span></span> 

-----

> <span data-ttu-id="556ea-174">類別成員宣告可以有~~五~~**種可能的**宣告存取範圍（9.5.2）中的任何一種： public、 **private protected**、protected internal、protected、internal 或 private。</span><span class="sxs-lookup"><span data-stu-id="556ea-174">A class-member-declaration can have any one of the ~~five~~**six** possible kinds of declared accessibility (§9.5.2): public, **private protected**, protected internal, protected, internal, or private.</span></span> <span data-ttu-id="556ea-175">除了受保護的內部**和私**用保護**組合之外**，指定一個以上的存取修飾詞是編譯時期錯誤。</span><span class="sxs-lookup"><span data-stu-id="556ea-175">Except for the protected internal **and private protected** combination**s**, it is a compile-time error to specify more than one access modifier.</span></span> <span data-ttu-id="556ea-176">當類別成員宣告不包含任何存取修飾詞時，會假設為私用。</span><span class="sxs-lookup"><span data-stu-id="556ea-176">When a class-member-declaration does not include any access modifiers, private is assumed.</span></span>

-----

> <span data-ttu-id="556ea-177">非巢狀型別可以有公用或內部宣告的存取範圍，而且預設會有內部宣告的存取範圍。</span><span class="sxs-lookup"><span data-stu-id="556ea-177">Non-nested types can have public or internal declared accessibility and have internal declared accessibility by default.</span></span> <span data-ttu-id="556ea-178">巢狀型別也可以有這些形式的宣告存取範圍，再加上一或多個其他形式的宣告存取範圍，視包含的類型是否為類別或結構而定：</span><span class="sxs-lookup"><span data-stu-id="556ea-178">Nested types can have these forms of declared accessibility too, plus one or more additional forms of declared accessibility, depending on whether the containing type is a class or struct:</span></span>
- <span data-ttu-id="556ea-179">在類別中宣告的巢狀型別可以有~~五~~**種宣告**存取範圍的任何一種形式（公用、**私用保護**、受保護的內部、受保護、內部或私用），而且與其他類別成員一樣，預設為私用宣告的存取範圍。</span><span class="sxs-lookup"><span data-stu-id="556ea-179">A nested type that is declared in a class can have any of ~~five~~**six** forms of declared accessibility (public, **private protected**, protected internal, protected, internal, or private) and, like other class members, defaults to private declared accessibility.</span></span>
- <span data-ttu-id="556ea-180">在結構中宣告的巢狀型別可以有三種形式的宣告存取範圍（公用、內部或私用），而且就像其他結構成員一樣，預設為私用宣告的存取範圍。</span><span class="sxs-lookup"><span data-stu-id="556ea-180">A nested type that is declared in a struct can have any of three forms of declared accessibility (public, internal, or private) and, like other struct members, defaults to private declared accessibility.</span></span>

-----

> <span data-ttu-id="556ea-181">覆寫宣告所覆寫的方法，就稱為覆寫方法 M，針對 c 類別中所宣告的覆寫的基底方法，覆寫的基底方法是藉由檢查 C 的每個基類類型，從 C 的直接基底類別類型開始來決定繼續每個連續的直接基類型別，直到指定的基類型別中，至少有一個可存取的方法位於替代型別引數之後，與 M 具有相同的簽章。</span><span class="sxs-lookup"><span data-stu-id="556ea-181">The method overridden by an override declaration is known as the overridden base method For an override method M declared in a class C, the overridden base method is determined by examining each base class type of C, starting with the direct base class type of C and continuing with each successive direct base class type, until in a given base class type at least one accessible method is located which has the same signature as M after substitution of type arguments.</span></span> <span data-ttu-id="556ea-182">為了找出覆寫的基底方法，如果方法是公用的，則會將它視為可存取（如果它是受保護的）、如果它是受保護**的內部，** 或者它是內部**或私**用的，或是在與 C 相同的程式中宣告的。</span><span class="sxs-lookup"><span data-stu-id="556ea-182">For the purposes of locating the overridden base method, a method is considered accessible if it is public, if it is protected, if it is protected internal, or if it is **either** internal **or private protected** and declared in the same program as C.</span></span>

-----

> <span data-ttu-id="556ea-183">存取子修飾詞的使用受到下列限制：</span><span class="sxs-lookup"><span data-stu-id="556ea-183">The use of accessor-modifiers is governed by the following restrictions:</span></span>
- <span data-ttu-id="556ea-184">存取子修飾詞不能用在介面或明確介面成員的執行中。</span><span class="sxs-lookup"><span data-stu-id="556ea-184">An accessor-modifier shall not be used in an interface or in an explicit interface member implementation.</span></span>
- <span data-ttu-id="556ea-185">對於沒有覆寫修飾詞的屬性或索引子，只有在屬性或索引子同時具有 get 和 set 存取子，而且只允許在其中一個存取子上使用時，才允許存取子修飾詞。</span><span class="sxs-lookup"><span data-stu-id="556ea-185">For a property or indexer that has no override modifier, an accessor-modifier is permitted only if the property or indexer has both a get and set accessor, and then is permitted only on one of those accessors.</span></span>
- <span data-ttu-id="556ea-186">對於包含 override 修飾詞的屬性或索引子，存取子必須符合要覆寫之存取子的存取子修飾詞（如果有的話）。</span><span class="sxs-lookup"><span data-stu-id="556ea-186">For a property or indexer that includes an override modifier, an accessor shall match the accessor-modifier, if any, of the accessor being overridden.</span></span>
- <span data-ttu-id="556ea-187">存取子修飾詞必須宣告比屬性或索引子本身的宣告存取範圍嚴格的存取範圍。</span><span class="sxs-lookup"><span data-stu-id="556ea-187">The accessor-modifier shall declare an accessibility that is strictly more restrictive than the declared accessibility of the property or indexer itself.</span></span> <span data-ttu-id="556ea-188">精確：</span><span class="sxs-lookup"><span data-stu-id="556ea-188">To be precise:</span></span>
  - <span data-ttu-id="556ea-189">如果屬性或索引子具有已宣告的公用存取範圍，則存取子修飾詞可能是私用的**protected**、、protected internal、internal、protected 或 private。</span><span class="sxs-lookup"><span data-stu-id="556ea-189">If the property or indexer has a declared accessibility of public, the accessor-modifier may be either **private protected**, , protected internal, internal, protected, or private.</span></span>
  - <span data-ttu-id="556ea-190">如果屬性或索引子具有受保護內部的已宣告存取範圍，則存取子修飾詞可能是私用的**protected**、internal、protected 或 private。</span><span class="sxs-lookup"><span data-stu-id="556ea-190">If the property or indexer has a declared accessibility of protected internal, the accessor-modifier may be either **private protected**, internal, protected, or private.</span></span>
  - <span data-ttu-id="556ea-191">如果屬性或索引子具有內部或受保護的已宣告存取範圍，則存取子修飾詞應該是**私用或**私用。</span><span class="sxs-lookup"><span data-stu-id="556ea-191">If the property or indexer has a declared accessibility of internal or protected, the accessor-modifier shall be **either private protected or** private.</span></span>
  - <span data-ttu-id="556ea-192">**如果屬性或索引子具有私用 protected 的已宣告存取範圍，則存取子修飾詞應為私用。**</span><span class="sxs-lookup"><span data-stu-id="556ea-192">**If the property or indexer has a declared accessibility of private protected, the accessor-modifier shall be private.**</span></span>
  - <span data-ttu-id="556ea-193">如果屬性或索引子有已宣告的私用存取範圍，則可能不會使用任何存取子修飾詞。</span><span class="sxs-lookup"><span data-stu-id="556ea-193">If the property or indexer has a declared accessibility of private, no accessor-modifier may be used.</span></span>

-----

> <span data-ttu-id="556ea-194">因為結構不支援繼承，所以結構成員的宣告存取範圍無法受到保護、**私用保護**或受保護的內部。</span><span class="sxs-lookup"><span data-stu-id="556ea-194">Since inheritance isn’t supported for structs, the declared accessibility of a struct member cannot be protected, **private protected**, or protected internal.</span></span>

-----

## <a name="drawbacks"></a><span data-ttu-id="556ea-195">缺點</span><span class="sxs-lookup"><span data-stu-id="556ea-195">Drawbacks</span></span>
[drawbacks]: #drawbacks

<span data-ttu-id="556ea-196">就像任何語言功能一樣，我們還必須問您，是否重金換回其他語言的複雜性，以提供給可從功能獲益C#的程式主體。</span><span class="sxs-lookup"><span data-stu-id="556ea-196">As with any language feature, we must question whether the additional complexity to the language is repaid in the additional clarity offered to the body of C# programs that would benefit from the feature.</span></span>

## <a name="alternatives"></a><span data-ttu-id="556ea-197">替代方案</span><span class="sxs-lookup"><span data-stu-id="556ea-197">Alternatives</span></span>
[alternatives]: #alternatives

<span data-ttu-id="556ea-198">另一個替代方式是提供結合屬性和分析器的 API。</span><span class="sxs-lookup"><span data-stu-id="556ea-198">An alternative would be the provision of an API combining an attribute and an analyzer.</span></span> <span data-ttu-id="556ea-199">屬性是由程式設計人員在 `internal` 成員上放置，以指出該成員僅用於子類別，而分析器會檢查這些限制是否已遵守。</span><span class="sxs-lookup"><span data-stu-id="556ea-199">The attribute is placed by the programmer on an `internal` member to indicates that the member is intended to be used only in subclasses, and the analyzer checks that those restrictions are obeyed.</span></span> 

## <a name="unresolved-questions"></a><span data-ttu-id="556ea-200">未解決的問題</span><span class="sxs-lookup"><span data-stu-id="556ea-200">Unresolved questions</span></span>
[unresolved]: #unresolved-questions

<span data-ttu-id="556ea-201">此實作為完整的完成。</span><span class="sxs-lookup"><span data-stu-id="556ea-201">The implementation is largely complete.</span></span> <span data-ttu-id="556ea-202">唯一開啟的工作專案是針對 VB 繪製對應的規格。</span><span class="sxs-lookup"><span data-stu-id="556ea-202">The only open work item is drafting a corresponding specification for VB.</span></span>

## <a name="design-meetings"></a><span data-ttu-id="556ea-203">設計會議</span><span class="sxs-lookup"><span data-stu-id="556ea-203">Design meetings</span></span>

<span data-ttu-id="556ea-204">TBD</span><span class="sxs-lookup"><span data-stu-id="556ea-204">TBD</span></span>
