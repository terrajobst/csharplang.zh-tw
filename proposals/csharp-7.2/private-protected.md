---
ms.openlocfilehash: 6cf489595654236c18edee94c0af380e605c9571
ms.sourcegitcommit: f61a06970fa0562d2e40363fae3948eb168624ca
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/14/2020
ms.locfileid: "79485172"
---
# <a name="private-protected"></a>private protected

* [x] 提議
* [x] 原型：[完成](https://github.com/dotnet/roslyn/blob/master/docs/features/private-protected.md)
* [x] 執行：[完成](https://github.com/dotnet/roslyn/blob/master/docs/features/private-protected.md)
* [x] 規格：[完成](#detailed-design)

## <a name="summary"></a>摘要
[summary]: #summary

在中C#將 CLR `protectedAndInternal` 存取範圍層級公開為 `private protected`。

## <a name="motivation"></a>動機
[motivation]: #motivation

在許多情況下，API 包含的成員僅適用于提供該類型之元件中所包含的子類別。 雖然 CLR 會針對該目的提供存取範圍層級，但無法在中C#使用。 因此，API 擁有者會強制使用 `internal` 保護和自我專業領域或自訂分析器，或使用具有其他檔的 `protected`，其中說明，當成員出現在該類型的公開檔中時，它就不是公用 API 的一部分。  如需後者的範例，請參閱其名稱開頭為 `Common`的 Roslyn `CSharpCompilationOptions` 成員。

直接在中C#提供此存取層級的支援，可讓您在語言中以自然方式表示這些情況。

## <a name="detailed-design"></a>詳細設計
[design]: #detailed-design

### <a name="private-protected-access-modifier"></a>`private protected` 存取修飾詞

我們建議您新增新的存取修飾片語合 `private protected` （可在修飾詞之間以任何順序出現）。 這會對應到 protectedAndInternal 的 CLR 概念，並且會借用目前在[ C++/cli](https://docs.microsoft.com/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli#BKMK_Member_visibility)中使用的相同語法。

如果該子類別與成員位於相同的元件，則可以在其容器的子類別記憶體取已宣告 `private protected` 的成員。

我們修改語言規格，如下所示（粗體新增）。 區段編號不會顯示在下方，因為它們可能會根據其整合的規格版本而有所不同。

-----

> 成員的宣告存取範圍可以是下列其中一項：
- Public，其選取方式是在成員宣告中包含公用修飾詞。 「公用」的直覺意義是「存取不受限制」。
- Protected，由在成員宣告中包含 protected 修飾詞來選取。 受保護的直覺意義是「存取限於包含類別或衍生自包含類別的類型」。
- 內部：在成員宣告中包含內部修飾詞，以選取此選項。 「內部」的直覺意義是「存取限於此元件」。
- 受保護的內部，其選取方式是在成員宣告中包含 protected 和 internal 修飾詞。 受保護內部的直覺意義是「可在此元件記憶體取，以及衍生自包含類別的類型」。
- **私用保護，其選取方式是在成員宣告中包含私用和受保護的修飾詞。私用保護的直覺意義是「由衍生自包含類別的類型，在此元件中可供存取」。**

-----

> 視成員宣告發生的內容而定，只允許特定類型的已宣告存取範圍。 此外，當成員宣告不包含任何存取修飾詞時，宣告所處的內容會決定預設宣告的存取範圍。 
- 命名空間隱含具有公開的已宣告存取範圍。 命名空間宣告上不允許有任何存取修飾詞。
- 直接在編譯單位或命名空間中宣告的類型（相對於其他類型）可能會有公用或內部宣告的存取範圍，而且預設為內部宣告的協助工具。
- 類別成員可以有五種宣告存取範圍的任何一種，而且預設為私用宣告的存取範圍。 [注意：宣告為類別成員的型別可以有五種宣告的存取範圍，而宣告為命名空間成員的型別可以只有公用或內部宣告的存取範圍。 結束附注]
- 結構成員可以有公用、內部或私用的存取範圍，而且預設為私用宣告的存取範圍，因為結構是隱含密封的。 結構中引進的結構成員（也就是，不是由該結構繼承 *），不能有受保護*~~或~~受保護的內部**或私用的受保護**宣告存取範圍。 [注意：宣告為結構成員的型別可以有公用、內部或私用的存取範圍，而宣告為命名空間成員的型別可以只有公用或內部宣告的存取範圍。 結束附注]
- 介面成員隱含具有公開的已宣告存取範圍。 介面成員宣告上不允許有任何存取修飾詞。
- 列舉成員隱含具有公開的已宣告存取範圍。 列舉成員宣告上不允許有任何存取修飾詞。

-----

> 在程式 P 內的類型 T 中宣告之嵌套成員 M 的存取範圍定義域定義如下（注意 M 本身可能是類型）：
- 如果 M 的宣告存取範圍是公用的，則 M 的存取範圍網域會是 T 的存取範圍網域。
- 如果 M 的宣告存取範圍受到保護，請讓 D 成為 P 的程式文字和任何衍生自 T 之類型的程式文字的聯集，而這是在 P 外部宣告。M 的存取範圍定義域是 T 的存取範圍定義域與 D 的交集。
- **如果 M 的宣告存取範圍已受私用保護，let D 就是 P 的程式文字和任何衍生自 T 之類型的程式文字的交集。M 的存取範圍定義域是 T 的存取範圍定義域與 D 的交集。**
- 如果 M 的宣告存取範圍受到保護，let D 就是 T 的程式文字和任何衍生自 T 之類型的程式文字的聯集。M 的存取範圍定義域是 T 的存取範圍定義域與 D 的交集。
- 如果 M 的宣告存取範圍是內部的，則 M 的存取範圍定義域是 T 的存取範圍定義域與 P 的程式文字的交集。
- 如果 M 的宣告存取範圍是私用的，M 的存取範圍網域就是 T 的程式文字。

-----

> 當受保護**或私用保護**的實例成員在宣告它的類別的程式文字之外存取時，以及當受保護的內部實例成員在宣告它的程式文字之外存取時，必須在衍生自其宣告所在類別的類別宣告內進行存取。 此外，您必須透過衍生類別型別的實例或從它所構成的類別型別，來進行存取。 這項限制可防止一個衍生類別存取其他衍生類別的受保護成員，即使成員繼承自相同的基類也一樣。

-----

> 允許的存取修飾詞和類型宣告的預設存取，取決於宣告發生所在的內容（第9.5.2 節）：
- 在編譯單位或命名空間中宣告的類型，可以有公用或內部存取權。 預設值為 [內部存取]。
- 在類別中宣告的類型可以有公用、受保護的內部、**私用保護**、受保護、內部或私用存取。 預設為私用存取。
- 結構中宣告的類型可以有公用、內部或私用存取。 預設為私用存取。

-----

> 靜態類別宣告受到下列限制：
- 靜態類別不應包含 sealed 或 abstract 修飾詞。 （不過，因為靜態類別無法具現化或衍生自，所以其行為就像是密封和抽象的一樣）。
- 靜態類別不應包含類別基底規格（§16.2.5），而且無法明確指定基類或實作為實介面的清單。 靜態類別隱含繼承自型別物件。
- 靜態類別應該只包含靜態成員（§16.4.8）。 [注意：所有常數和巢狀型別都會分類為靜態成員。 結束附注]
- 靜態類別不應該有具有受保護 **、私用保護**或受保護內部宣告存取範圍的成員。

> 這是編譯時期錯誤，違反上述任何一項限制。 

-----

> 類別成員宣告可以有~~五~~**種可能的**宣告存取範圍（9.5.2）中的任何一種： public、 **private protected**、protected internal、protected、internal 或 private。 除了受保護的內部**和私**用保護**組合之外**，指定一個以上的存取修飾詞是編譯時期錯誤。 當類別成員宣告不包含任何存取修飾詞時，會假設為私用。

-----

> 非巢狀型別可以有公用或內部宣告的存取範圍，而且預設會有內部宣告的存取範圍。 巢狀型別也可以有這些形式的宣告存取範圍，再加上一或多個其他形式的宣告存取範圍，視包含的類型是否為類別或結構而定：
- 在類別中宣告的巢狀型別可以有~~五~~**種宣告**存取範圍的任何一種形式（公用、**私用保護**、受保護的內部、受保護、內部或私用），而且與其他類別成員一樣，預設為私用宣告的存取範圍。
- 在結構中宣告的巢狀型別可以有三種形式的宣告存取範圍（公用、內部或私用），而且就像其他結構成員一樣，預設為私用宣告的存取範圍。

-----

> 覆寫宣告所覆寫的方法，就稱為覆寫方法 M，針對 c 類別中所宣告的覆寫的基底方法，覆寫的基底方法是藉由檢查 C 的每個基類類型，從 C 的直接基底類別類型開始來決定繼續每個連續的直接基類型別，直到指定的基類型別中，至少有一個可存取的方法位於替代型別引數之後，與 M 具有相同的簽章。 為了找出覆寫的基底方法，如果方法是公用的，則會將它視為可存取（如果它是受保護的）、如果它是受保護**的內部，** 或者它是內部**或私**用的，或是在與 C 相同的程式中宣告的。

-----

> 存取子修飾詞的使用受到下列限制：
- 存取子修飾詞不能用在介面或明確介面成員的執行中。
- 對於沒有覆寫修飾詞的屬性或索引子，只有在屬性或索引子同時具有 get 和 set 存取子，而且只允許在其中一個存取子上使用時，才允許存取子修飾詞。
- 對於包含 override 修飾詞的屬性或索引子，存取子必須符合要覆寫之存取子的存取子修飾詞（如果有的話）。
- 存取子修飾詞必須宣告比屬性或索引子本身的宣告存取範圍嚴格的存取範圍。 精確：
  - 如果屬性或索引子具有已宣告的公用存取範圍，則存取子修飾詞可能是私用的**protected**、、protected internal、internal、protected 或 private。
  - 如果屬性或索引子具有受保護內部的已宣告存取範圍，則存取子修飾詞可能是私用的**protected**、internal、protected 或 private。
  - 如果屬性或索引子具有內部或受保護的已宣告存取範圍，則存取子修飾詞應該是**私用或**私用。
  - **如果屬性或索引子具有私用 protected 的已宣告存取範圍，則存取子修飾詞應為私用。**
  - 如果屬性或索引子有已宣告的私用存取範圍，則可能不會使用任何存取子修飾詞。

-----

> 因為結構不支援繼承，所以結構成員的宣告存取範圍無法受到保護、**私用保護**或受保護的內部。

-----

## <a name="drawbacks"></a>缺點
[drawbacks]: #drawbacks

就像任何語言功能一樣，我們還必須問您，是否重金換回其他語言的複雜性，以提供給可從功能獲益C#的程式主體。

## <a name="alternatives"></a>替代方案
[alternatives]: #alternatives

另一個替代方式是提供結合屬性和分析器的 API。 屬性是由程式設計人員在 `internal` 成員上放置，以指出該成員僅用於子類別，而分析器會檢查這些限制是否已遵守。 

## <a name="unresolved-questions"></a>未解決的問題
[unresolved]: #unresolved-questions

此實作為完整的完成。 唯一開啟的工作專案是針對 VB 繪製對應的規格。

## <a name="design-meetings"></a>設計會議

TBD
