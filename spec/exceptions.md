# <a name="exceptions"></a><span data-ttu-id="62861-101">例外狀況</span><span class="sxs-lookup"><span data-stu-id="62861-101">Exceptions</span></span>

<span data-ttu-id="62861-102">在 C# 中的例外狀況會提供結構化、 統一和型別安全的方式來處理系統層級和應用程式層級錯誤狀況。</span><span class="sxs-lookup"><span data-stu-id="62861-102">Exceptions in C# provide a structured, uniform, and type-safe way of handling both system level and application level error conditions.</span></span> <span data-ttu-id="62861-103">在 C# 中的例外狀況機制是相當類似於 c + +，但有一些重要差異：</span><span class="sxs-lookup"><span data-stu-id="62861-103">The exception mechanism in C# is quite similar to that of C++, with a few important differences:</span></span>

*  <span data-ttu-id="62861-104">在 C# 中，所有例外狀況必須衍生自的類別類型的執行個體所表示`System.Exception`。</span><span class="sxs-lookup"><span data-stu-id="62861-104">In C#, all exceptions must be represented by an instance of a class type derived from `System.Exception`.</span></span> <span data-ttu-id="62861-105">C + + 中的任何類型的任何值可用來表示例外狀況。</span><span class="sxs-lookup"><span data-stu-id="62861-105">In C++, any value of any type can be used to represent an exception.</span></span>
*  <span data-ttu-id="62861-106">在 C# 中，finally 區塊 ([try 陳述式](statements.md#the-try-statement)) 可用來撰寫一般執行和例外狀況中執行的終止程式碼。</span><span class="sxs-lookup"><span data-stu-id="62861-106">In C#, a finally block ([The try statement](statements.md#the-try-statement)) can be used to write termination code that executes in both normal execution and exceptional conditions.</span></span> <span data-ttu-id="62861-107">這類程式碼很難撰寫 c + + 中，而不複製程式碼。</span><span class="sxs-lookup"><span data-stu-id="62861-107">Such code is difficult to write in C++ without duplicating code.</span></span>
*  <span data-ttu-id="62861-108">在 C# 中，系統層級例外狀況例如溢位、 除數為零和 null 取值也定義了例外狀況類別和應用程式層級錯誤狀況與同等。</span><span class="sxs-lookup"><span data-stu-id="62861-108">In C#, system-level exceptions such as overflow, divide-by-zero, and null dereferences have well defined exception classes and are on a par with application-level error conditions.</span></span>

## <a name="causes-of-exceptions"></a><span data-ttu-id="62861-109">例外狀況的原因</span><span class="sxs-lookup"><span data-stu-id="62861-109">Causes of exceptions</span></span>

<span data-ttu-id="62861-110">兩個不同的方式，可以擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="62861-110">Exception can be thrown in two different ways.</span></span>

*  <span data-ttu-id="62861-111">A`throw`陳述式 ([throw 陳述式](statements.md#the-throw-statement)) 立即且無條件地擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="62861-111">A `throw` statement ([The throw statement](statements.md#the-throw-statement)) throws an exception immediately and unconditionally.</span></span> <span data-ttu-id="62861-112">控制永遠不會到達緊接`throw`。</span><span class="sxs-lookup"><span data-stu-id="62861-112">Control never reaches the statement immediately following the `throw`.</span></span>
*  <span data-ttu-id="62861-113">某些 C# 陳述式和運算式的處理期間所發生的例外狀況會導致在某些情況下發生例外狀況時無法正常完成的作業。</span><span class="sxs-lookup"><span data-stu-id="62861-113">Certain exceptional conditions that arise during the processing of C# statements and expression cause an exception in certain circumstances when the operation cannot be completed normally.</span></span> <span data-ttu-id="62861-114">例如，整數除法運算 ([除法運算子](expressions.md#division-operator)) 會擲回`System.DivideByZeroException`如果分母為零。</span><span class="sxs-lookup"><span data-stu-id="62861-114">For example, an integer division operation ([Division operator](expressions.md#division-operator)) throws a `System.DivideByZeroException` if the denominator is zero.</span></span> <span data-ttu-id="62861-115">請參閱[常見的例外狀況類別](exceptions.md#common-exception-classes)取得一份可能會發生這種方式的各種例外狀況。</span><span class="sxs-lookup"><span data-stu-id="62861-115">See [Common Exception Classes](exceptions.md#common-exception-classes) for a list of the various exceptions that can occur in this way.</span></span>

## <a name="the-systemexception-class"></a><span data-ttu-id="62861-116">System.Exception 類別</span><span class="sxs-lookup"><span data-stu-id="62861-116">The System.Exception class</span></span>

<span data-ttu-id="62861-117">`System.Exception`類別是所有例外狀況的基底類型。</span><span class="sxs-lookup"><span data-stu-id="62861-117">The `System.Exception` class is the base type of all exceptions.</span></span> <span data-ttu-id="62861-118">這個類別會有共用的所有例外狀況的幾個重要屬性：</span><span class="sxs-lookup"><span data-stu-id="62861-118">This class has a few notable properties that all exceptions share:</span></span>

*  <span data-ttu-id="62861-119">`Message` 是唯讀的屬性型別的`string`，包含人類看得懂的例外狀況的原因描述。</span><span class="sxs-lookup"><span data-stu-id="62861-119">`Message` is a read-only property of type `string` that contains a human-readable description of the reason for the exception.</span></span>
*  <span data-ttu-id="62861-120">`InnerException` 是唯讀的屬性型別的`Exception`。</span><span class="sxs-lookup"><span data-stu-id="62861-120">`InnerException` is a read-only property of type `Exception`.</span></span> <span data-ttu-id="62861-121">如果其值為非 null，它是指造成目前例外狀況的例外狀況，也就是在 catch 區塊中引發目前的例外狀況處理`InnerException`。</span><span class="sxs-lookup"><span data-stu-id="62861-121">If its value is non-null, it refers to the exception that caused the current exception—that is, the current exception was raised in a catch block handling the `InnerException`.</span></span> <span data-ttu-id="62861-122">否則，其值為 null，表示這個例外狀況不是由另一個例外狀況所造成的。</span><span class="sxs-lookup"><span data-stu-id="62861-122">Otherwise, its value is null, indicating that this exception was not caused by another exception.</span></span> <span data-ttu-id="62861-123">以這種方式鏈結在一起的例外狀況物件的數目可以是任意的。</span><span class="sxs-lookup"><span data-stu-id="62861-123">The number of exception objects chained together in this manner can be arbitrary.</span></span>

<span data-ttu-id="62861-124">這些屬性的值可以指定的執行個體建構函式的呼叫中`System.Exception`。</span><span class="sxs-lookup"><span data-stu-id="62861-124">The value of these properties can be specified in calls to the instance constructor for `System.Exception`.</span></span>

## <a name="how-exceptions-are-handled"></a><span data-ttu-id="62861-125">如何處理例外狀況</span><span class="sxs-lookup"><span data-stu-id="62861-125">How exceptions are handled</span></span>

<span data-ttu-id="62861-126">例外狀況會由`try`陳述式 ([try 陳述式](statements.md#the-try-statement))。</span><span class="sxs-lookup"><span data-stu-id="62861-126">Exceptions are handled by a `try` statement ([The try statement](statements.md#the-try-statement)).</span></span>

<span data-ttu-id="62861-127">發生例外狀況時，系統會搜尋最接近`catch`可以處理例外狀況，例外狀況的執行階段型別所決定的子句。</span><span class="sxs-lookup"><span data-stu-id="62861-127">When an exception occurs, the system searches for the nearest `catch` clause that can handle the exception, as determined by the run-time type of the exception.</span></span> <span data-ttu-id="62861-128">首先，目前的方法搜尋語彙封閉式`try`陳述式和相關聯的 catch 子句的 try 陳述式會被視為順序。</span><span class="sxs-lookup"><span data-stu-id="62861-128">First, the current method is searched for a lexically enclosing `try` statement, and the associated catch clauses of the try statement are considered in order.</span></span> <span data-ttu-id="62861-129">如果失敗，請呼叫目前方法的方法會搜尋語彙封閉式`try`目前方法的呼叫點封入陳述式。</span><span class="sxs-lookup"><span data-stu-id="62861-129">If that fails, the method that called the current method is searched for a lexically enclosing `try` statement that encloses the point of the call to the current method.</span></span> <span data-ttu-id="62861-130">此搜尋會繼續直到`catch`子句找到可以處理目前的例外狀況，藉由命名為相同的類別或基底類別之型別的執行階段擲回例外狀況的例外狀況類別。</span><span class="sxs-lookup"><span data-stu-id="62861-130">This search continues until a `catch` clause is found that can handle the current exception, by naming an exception class that is of the same class, or a base class, of the run-time type of the exception being thrown.</span></span> <span data-ttu-id="62861-131">A`catch`子句未命名的例外狀況類別可以處理任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="62861-131">A `catch` clause that doesn't name an exception class can handle any exception.</span></span>

<span data-ttu-id="62861-132">一旦找到相符的 catch 子句，系統會將控制權轉移到 catch 子句的第一個陳述式準備。</span><span class="sxs-lookup"><span data-stu-id="62861-132">Once a matching catch clause is found, the system prepares to transfer control to the first statement of the catch clause.</span></span> <span data-ttu-id="62861-133">Catch 子句執行開始之前，系統會先執行，依序任何`finally`子句所需的 try 陳述式相關聯的巢狀，比攔截到例外狀況。</span><span class="sxs-lookup"><span data-stu-id="62861-133">Before execution of the catch clause begins, the system first executes, in order, any `finally` clauses that were associated with try statements more nested that than the one that caught the exception.</span></span>

<span data-ttu-id="62861-134">如果不找到任何相符的 catch 子句，就會發生下列其中一種：</span><span class="sxs-lookup"><span data-stu-id="62861-134">If no matching catch clause is found, one of two things occurs:</span></span>

*  <span data-ttu-id="62861-135">如果搜尋相符的 catch 子句已達到靜態建構函式 ([靜態建構函式](classes.md#static-constructors)) 或靜態欄位初始設定式，則會顯示`System.TypeInitializationException`觸發靜態建構函式的引動過程之處擲回。</span><span class="sxs-lookup"><span data-stu-id="62861-135">If the search for a matching catch clause reaches a static constructor ([Static constructors](classes.md#static-constructors)) or static field initializer, then a `System.TypeInitializationException` is thrown at the point that triggered the invocation of the static constructor.</span></span> <span data-ttu-id="62861-136">內部例外狀況的`System.TypeInitializationException`包含原先擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="62861-136">The inner exception of the `System.TypeInitializationException` contains the exception that was originally thrown.</span></span>
*  <span data-ttu-id="62861-137">如果比對 catch 子句的搜尋已達到執行緒的初始啟動的程式碼，然後會終止執行緒的執行。</span><span class="sxs-lookup"><span data-stu-id="62861-137">If the search for matching catch clauses reaches the code that initially started the thread, then execution of the thread is terminated.</span></span> <span data-ttu-id="62861-138">這類終止的影響是由實作定義。</span><span class="sxs-lookup"><span data-stu-id="62861-138">The impact of such termination is implementation-defined.</span></span>

<span data-ttu-id="62861-139">解構函式執行期間所發生的例外狀況是值得特別一提。</span><span class="sxs-lookup"><span data-stu-id="62861-139">Exceptions that occur during destructor execution are worth special mention.</span></span> <span data-ttu-id="62861-140">如果解構函式執行期間發生的例外狀況，而且未攔截到例外狀況，然後該解構函式的執行已終止，並 （如果有的話） 的基底類別的解構函式呼叫。</span><span class="sxs-lookup"><span data-stu-id="62861-140">If an exception occurs during destructor execution, and that exception is not caught, then the execution of that destructor is terminated and the destructor of the base class (if any) is called.</span></span> <span data-ttu-id="62861-141">如果沒有基底類別 (如果是做為`object`型別) 或如果沒有基底類別解構函式，則會捨棄例外狀況。</span><span class="sxs-lookup"><span data-stu-id="62861-141">If there is no base class (as in the case of the `object` type) or if there is no base class destructor, then the exception is discarded.</span></span>

## <a name="common-exception-classes"></a><span data-ttu-id="62861-142">常見的例外狀況類別</span><span class="sxs-lookup"><span data-stu-id="62861-142">Common Exception Classes</span></span>

<span data-ttu-id="62861-143">某些 C# 作業會擲回下列例外狀況。</span><span class="sxs-lookup"><span data-stu-id="62861-143">The following exceptions are thrown by certain C# operations.</span></span>

|                                      |                |
|--------------------------------------|----------------|
| `System.ArithmeticException`         | <span data-ttu-id="62861-144">在算術運算期間所發生的例外狀況 (例如 `System.DivideByZeroException` 和 `System.OverflowException`) 的基底類別。</span><span class="sxs-lookup"><span data-stu-id="62861-144">A base class for exceptions that occur during arithmetic operations, such as `System.DivideByZeroException` and `System.OverflowException`.</span></span> | 
| `System.ArrayTypeMismatchException`  | <span data-ttu-id="62861-145">陣列的存放區失敗，因為實際的預存的項目類型是與陣列的實際型別不相容時，便會擲回。</span><span class="sxs-lookup"><span data-stu-id="62861-145">Thrown when a store into an array fails because the actual type of the stored element is incompatible with the actual type of the array.</span></span> | 
| `System.DivideByZeroException`       | <span data-ttu-id="62861-146">當發生除以零的整數值的嘗試時，便會擲回。</span><span class="sxs-lookup"><span data-stu-id="62861-146">Thrown when an attempt to divide an integral value by zero occurs.</span></span> | 
| `System.IndexOutOfRangeException`    | <span data-ttu-id="62861-147">當嘗試透過索引小於零或超出陣列界限的陣列編製索引時，便會擲回。</span><span class="sxs-lookup"><span data-stu-id="62861-147">Thrown when an attempt to index an array via an index that is less than zero or outside the bounds of the array.</span></span> | 
| `System.InvalidCastException`        | <span data-ttu-id="62861-148">基底類型或介面從衍生類型的明確轉換在執行階段失敗時擲回。</span><span class="sxs-lookup"><span data-stu-id="62861-148">Thrown when an explicit conversion from a base type or interface to a derived type fails at run time.</span></span> | 
| `System.NullReferenceException`      | <span data-ttu-id="62861-149">時擲回`null`參考會在讓需要參考的物件。</span><span class="sxs-lookup"><span data-stu-id="62861-149">Thrown when a `null` reference is used in a way that causes the referenced object to be required.</span></span> | 
| `System.OutOfMemoryException`        | <span data-ttu-id="62861-150">當嘗試配置記憶體時擲回 (透過`new`) 就會失敗。</span><span class="sxs-lookup"><span data-stu-id="62861-150">Thrown when an attempt to allocate memory (via `new`) fails.</span></span> | 
| `System.OverflowException`           | <span data-ttu-id="62861-151">`checked` 內容中的算術運算溢位時擲回。</span><span class="sxs-lookup"><span data-stu-id="62861-151">Thrown when an arithmetic operation in a `checked` context overflows.</span></span> | 
| `System.StackOverflowException`      | <span data-ttu-id="62861-152">當有太多暫止方法呼叫; 耗盡執行堆疊時擲回通常是用來指示非常深或無限遞迴。</span><span class="sxs-lookup"><span data-stu-id="62861-152">Thrown when the execution stack is exhausted by having too many pending method calls; typically indicative of very deep or unbounded recursion.</span></span> | 
| `System.TypeInitializationException` | <span data-ttu-id="62861-153">靜態建構函式會擲回例外狀況，但不含任何時擲回`catch`子句存在攔截它。</span><span class="sxs-lookup"><span data-stu-id="62861-153">Thrown when a static constructor throws an exception, and no `catch` clauses exists to catch it.</span></span> | 
