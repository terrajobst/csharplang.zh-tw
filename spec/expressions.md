---
ms.openlocfilehash: f61039abd6bd557ac0ea625e6aac1c8bafa57b02
ms.sourcegitcommit: e134bb7058e9848120b93b345f96d6ac0cb8c815
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/17/2020
ms.locfileid: "71704081"
---
# <a name="expressions"></a>運算式

運算式是一串運算子和運算元。 本章定義運算元和運算子的語法、評估順序，以及運算式的意義。

## <a name="expression-classifications"></a>運算式分類

運算式分類為下列其中一項：

*  值。 每個值都有關聯型別。
*  變數。 每個變數都有相關聯的類型，亦即變數的宣告類型。
*  命名空間。 具有此分類的運算式只能出現在*member_access*的左邊（[成員存取](expressions.md#member-access)）。 在任何其他內容中，分類為命名空間的運算式會導致編譯時期錯誤。
*  類型。 具有此分類的運算式只能顯示為*member_access*的左邊（[成員存取](expressions.md#member-access)），或做為 `as` 運算子（[as 運算子](expressions.md#the-as-operator)）的運算元、`is` 運算子（[is 運算子](expressions.md#the-is-operator)）或 `typeof` 運算子（[typeof 運算子](expressions.md#the-typeof-operator)）。 在任何其他內容中，分類為類型的運算式會導致編譯時期錯誤。
*  方法群組，這是由成員查閱（[成員查閱](expressions.md#member-lookup)）所產生的一組多載方法。 方法群組可以有相關聯的實例運算式和關聯的類型引數清單。 叫用實例方法時，評估實例運算式的結果會成為 `this` （[此存取](expressions.md#this-access)）所表示的實例。 在*invocation_expression* （[調用運算式](expressions.md#invocation-expressions)）、 *delegate_creation_expression* （[委派建立運算式](expressions.md#delegate-creation-expressions)）和 is 運算子的左邊都允許方法群組，而且可以隱含地轉換成相容的委派類型（[方法群組轉換](conversions.md#method-group-conversions)）。 在任何其他內容中，分類為方法群組的運算式會導致編譯時期錯誤。
*  Null 常值。 具有此分類的運算式可以隱含地轉換成參考型別或可為 null 的類型。
*  匿名函式。 具有此分類的運算式可以隱含地轉換成相容的委派類型或運算式樹狀架構類型。
*  屬性存取。 每個屬性存取都有相關聯的類型，即屬性的類型。 此外，屬性存取可能會有相關聯的實例運算式。 叫用實例屬性存取的存取子（`get` 或 `set` 區塊）時，評估實例運算式的結果會成為 `this` 所表示的實例（[此存取權](expressions.md#this-access)）。
*  事件存取。 每個事件存取都有相關聯的類型，亦即事件的類型。 此外，事件存取可能會有相關聯的實例運算式。 事件存取可能會顯示為 `+=` 和 `-=` 運算子（[事件指派](expressions.md#event-assignment)）的左運算元。 在任何其他內容中，歸類為事件存取的運算式會導致編譯時期錯誤。
*  索引子存取。 每個索引子存取都有相關聯的類型，也就是索引子的元素類型。 此外，索引子存取具有相關聯的實例運算式和相關聯的引數清單。 叫用索引子存取的存取子（`get` 或 `set` 區塊）時，評估實例運算式的結果會成為 `this` 所表示的實例（[此存取權](expressions.md#this-access)），而評估引數清單的結果會成為調用的參數清單。
*  無。 當運算式為傳回型別為 `void`的方法調用時，就會發生這種情況。 分類為沒有任何內容的運算式僅在*statement_expression* （[expression 語句](statements.md#expression-statements)）的內容中有效。

運算式的最終結果絕對不是命名空間、類型、方法群組或事件存取。 如先前所述，這些運算式類別是只在特定內容中允許的中繼結構。

屬性存取或索引子存取一律會藉由執行*get 存取*子或*set 存取*子的調用，重新分類為值。 特定存取子是由屬性或索引子存取的內容所決定：如果存取是指派的目標，則會叫用*set 存取*子來指派新的值（[簡單指派](expressions.md#simple-assignment)）。 否則，會叫用*get 存取*子來取得目前的值（[運算式的值](expressions.md#values-of-expressions)）。

### <a name="values-of-expressions"></a>運算式的值

大部分牽涉到運算式的結構，最後都需要運算式來表示***值***。 在這種情況下，如果實際運算式表示命名空間、類型、方法群組，或沒有任何值，就會發生編譯時期錯誤。 不過，如果運算式表示屬性存取、索引子存取或變數，則會隱含地取代屬性、索引子或變數的值：

*  變數的值只是目前儲存在變數所識別之儲存位置中的值。 您必須先將變數視為明確指派（[明確指派](variables.md#definite-assignment)），才能取得其值，否則會發生編譯時期錯誤。
*  屬性存取運算式的值是藉由叫用屬性的*get 存取*子取得。 如果屬性沒有*get 存取*子，就會發生編譯時期錯誤。 否則，會執行函式成員調用（動態多載[解析的編譯階段檢查](expressions.md#compile-time-checking-of-dynamic-overload-resolution)），而調用的結果會成為屬性存取運算式的值。
*  索引子存取運算式的值是藉由叫用索引子的*get 存取*子取得。 如果索引子沒有*get 存取*子，就會發生編譯時期錯誤。 否則，會使用與索引子存取運算式相關聯的引數清單來執行函數成員調用（動態多載[解析的編譯時間檢查](expressions.md#compile-time-checking-of-dynamic-overload-resolution)），而叫用的結果會成為索引子存取運算式的值。

## <a name="static-and-dynamic-binding"></a>靜態和動態繫結

根據組成運算式的類型或值（引數、運算元、接收者）來判斷作業意義的程式，通常稱為「系結」（ ***binding***）。 例如，方法呼叫的意義是根據接收者和引數的類型來決定。 運算子的意義取決於其運算元的類型。

在C#中，作業的意義通常是在編譯時期根據其組成運算式的編譯時間類型來決定。 同樣地，如果運算式包含錯誤，則會偵測到錯誤並由編譯器回報。 這種方法稱為***靜態***系結。

不過，如果運算式是動態運算式（也就是型別 `dynamic`），這表示它所參與的任何系結都應該根據其執行時間型別（也就是它在執行時間所代表之物件的實際型別），而不是編譯時期的型別。 因此，這類作業的系結會延後，直到執行程式時發生作業的時間。 這稱為「***動態繫結***」。

當作業動態繫結時，編譯器不會執行任何檢查。 相反地，如果執行時間系結失敗，則會在執行時間將錯誤報表為例外狀況。

中C#的下列作業受限於系結：

*  成員存取： `e.M`
*  方法調用： `e.M(e1, ..., eN)`
*  委派調用：`e(e1, ..., eN)`
*  元素存取： `e[e1, ..., eN]`
*  物件建立： `new C(e1, ..., eN)`
*  多載的一元運算子： `+`、`-`、`!`、`~`、`++`、`--`、`true`、`false`
*  多載的二元運算子： `+`、`-`、`*`、`/`、`%`、`&`、`&&`、`|`、`||`、`??`、`^`、`<<`、`>>`、`==`、`!=`、`>`、`<`、`>=`、`<=`
*  指派運算子： `=`、`+=`、`-=`、`*=`、`/=`、`%=`、`&=`、`|=`、`^=`、`<<=`、`>>=`
*  隱含和明確轉換

當不涉及動態運算式時， C#預設為靜態系結，這表示選取進程中會使用組成運算式的編譯階段類型。 不過，以上所列作業中的其中一個組成運算式是動態運算式時，則會改為動態系結運算。

### <a name="binding-time"></a>裝訂-時間

靜態系結會在編譯時期進行，而動態系結會在執行時間進行。 在下列各節中，「系結時間」一詞指的是編譯時間或執行時間，***端***視系結髮生的時間而定。

下列範例說明靜態和動態系結和系結時間的概念：
```csharp
object  o = 5;
dynamic d = 5;

Console.WriteLine(5);  // static  binding to Console.WriteLine(int)
Console.WriteLine(o);  // static  binding to Console.WriteLine(object)
Console.WriteLine(d);  // dynamic binding to Console.WriteLine(int)
```

前兩個呼叫會以靜態方式系結：根據其引數的編譯時間類型來挑選 `Console.WriteLine` 的多載。 因此，系結時間為編譯時間。

第三個呼叫會以動態方式系結：根據其引數的執行時間類型來挑選 `Console.WriteLine` 的多載。 之所以會發生這種情況，是因為引數是動態運算式--其編譯時期型別為 `dynamic`。 因此，第三個呼叫的系結時間是執行時間。

### <a name="dynamic-binding"></a>動態繫結

動態系結的目的是允許C#程式與***動態物件***互動，也就是不遵循C#類型系統一般規則的物件。 動態物件可能是來自具有不同類型系統之其他程式設計語言的物件，也可能是以程式設計方式設定的物件，以針對不同的作業執行自己的系結語義。

動態物件用來實作為其本身的語義的機制是定義的。 定義了指定的介面----由動態物件所實作為，以通知C#執行時間其具有特殊的語義。 因此，每當動態物件上的作業動態系結時，它們自己的系結語義，而C#不是本檔中所指定的，就會接管。

雖然動態系結的目的是要允許與動態物件互通， C#但允許所有物件上的動態系結，不論它們是否為動態的。 這樣可以更順暢地整合動態物件，因為它們的作業結果可能本身不是動態物件，而是程式設計人員在編譯時期的未知型別。 此外，動態繫結也有助於消除容易出錯的反映型程式碼，即使沒有任何物件是動態物件也是如此。

下列各節將針對語言中的每個結構，精確地描述套用動態系結時的架構、編譯時間檢查（如果有的話），以及編譯時間結果和運算式分類。

### <a name="types-of-constituent-expressions"></a>組成運算式的類型

當作業以靜態方式系結時，構成運算式的類型（例如接收者、引數、索引或運算元）一律視為該運算式的編譯時間類型。

當作業動態系結時，會根據組成運算式的編譯時間類型，以不同的方式來決定組成運算式的類型：

*  編譯時間類型 `dynamic` 的構成運算式會被視為具有運算式在執行時間評估為之實際值的類型。
*  其編譯時期型別為型別參數的組成運算式，會被視為具有型別參數在執行時間系結的型別
*  否則，構成運算式會被視為具有其編譯時期型別。

## <a name="operators"></a>運算子

運算式是由***運算元***和***運算子***所構成。 運算式的運算子會指出要將哪些運算套用到運算元。 運算子範例包括 `+`、`-`、`*`、`/` 及 `new`。 運算元範例包括常值、欄位、區域變數及運算式。

運算子有三種類型：

*  一元運算子。 一元運算子會採用一個運算元，並使用前置詞標記法（例如 `--x`）或後置標記法（例如 `x++`）。
*  二元運算子。 二元運算子接受兩個運算元，並使用中置標記法（例如 `x + y`）。
*  三元運算子。 只有一個三元運算子，`?:`，exists;它會採用三個運算元，並使用中置標記法（`c ? x : y`）。

運算式中運算子的評估順序是由運算子（[運算子優先順序和關聯](expressions.md#operator-precedence-and-associativity)性）的***優先順序***和***關聯***性所決定。

運算式中的運算元會由左至右評估。 例如，在 `F(i) + G(i++) * H(i)`中，會使用 `i`的舊值來呼叫方法 `F`，然後以 `i`的舊值呼叫方法 `G`，最後會以 `H` 的新值呼叫方法 `i`。 這與運算子優先順序不同，而且不相關。

部分運算子可以***多載***。 運算子多載可針對一或兩個運算元屬於使用者定義的類別或結構類型（[運算子](expressions.md#operator-overloading)多載）的作業，指定使用者定義的運算子執行。

### <a name="operator-precedence-and-associativity"></a>運算子優先順序和關聯性

當運算式包含多個運算子時，運算子的「優先順序」會控制評估個別運算子的順序。 例如，運算式 `x + y * z` 會評估為 `x + (y * z)`，因為 `*` 運算子的優先順序高於 binary `+` 運算子。 運算子的優先順序是由其相關聯文法生產的定義所建立。 例如， *additive_expression*包含以 `+` 或 `-` 運算子分隔的一系列*multiplicative_expression*，因而讓 `+` 和 `-` 運算子的優先順序低於 `*`、`/`和 `%` 運算子。

下表依優先順序從最高到最低的順序來匯總所有運算子：

| __區段__                                                                                   | __分類__                | __運算子__ | 
|-----------------------------------------------------------------------------------------------|-----------------------------|---------------|
| [主要運算式](expressions.md#primary-expressions)                                     | 主要                     | `x.y`  `f(x)`  `a[x]`  `x++`  `x--`  `new`  `typeof`  `default`  `checked`  `unchecked`  `delegate` | 
| [一元運算子](expressions.md#unary-operators)                                             | 一元                       | `+`  `-`  `!`  `~`  `++x`  `--x`  `(T)x` | 
| [算術運算子](expressions.md#arithmetic-operators)                                   | 乘法類 (Multiplicative)              | `*`  `/`  `%` | 
| [算術運算子](expressions.md#arithmetic-operators)                                   | 加法類 (Additive)                    | `+`  `-`      | 
| [移位運算子](expressions.md#shift-operators)                                             | Shift                       | `<<`  `>>`    | 
| [關係和類型測試運算子](expressions.md#relational-and-type-testing-operators) | 關係和型別測試 | `<`  `>`  `<=`  `>=`  `is`  `as` | 
| [關係和類型測試運算子](expressions.md#relational-and-type-testing-operators) | 相等                    | `==`  `!=`    | 
| [邏輯運算子](expressions.md#logical-operators)                                         | 邏輯 AND                 | `&`           | 
| [邏輯運算子](expressions.md#logical-operators)                                         | 邏輯 XOR                 | `^`           | 
| [邏輯運算子](expressions.md#logical-operators)                                         | 邏輯 OR                  | <code>&#124;</code>           |
| [條件邏輯運算子](expressions.md#conditional-logical-operators)                 | 條件式 AND             | `&&`          | 
| [條件邏輯運算子](expressions.md#conditional-logical-operators)                 | 條件式 OR              | <code>&#124;&#124;</code>          | 
| [Null 聯合運算子](expressions.md#the-null-coalescing-operator)                   | Null 聯合             | `??`          | 
| [條件運算子](expressions.md#conditional-operator)                                   | 條件式                 | `?:`          | 
| [指派運算子](expressions.md#assignment-operators)，[匿名函數運算式](expressions.md#anonymous-function-expressions)  | 指派和 lambda 運算式 | `=`  `*=`  `/=`  `%=`  `+=`  `-=`  `<<=`  `>>=`  `&=`  `^=`  <code>&#124;=</code>  `=>` | 

當兩個具有相同優先順序的運算子之間發生運算元時，運算子的關聯性會控制作業的執行順序：

*  除了指派運算子和 null 聯合運算子之外，所有二元運算子都是***左關聯***的，這表示作業是由左至右執行。 例如，`x + y + z` 會判斷值為 `(x + y) + z`。
*  指派運算子、null 聯合運算子和條件運算子（`?:`）都是***靠右關聯***的，這表示作業是由右至左執行。 例如，`x = y = z` 會判斷值為 `x = (y = z)`。

您可以使用括弧來控制優先順序和關聯性。 例如，`x + y * z` 會先將 `y` 乘以 `z`，然後再將結果加到 `x`，而 `(x + y) * z` 則會先將 `x` 與 `y` 相加，然後再將結果乘以 `z`。

### <a name="operator-overloading"></a>運算子多載

所有一元和二元運算子都有預先定義的實作為可在任何運算式中自動使用的。 除了預先定義的執行之外，也可以藉由在類別和結構（[運算子](classes.md#operators)）中包含 `operator` 宣告，來引進使用者定義的實作為。 使用者定義的運算子執行一律優先于預先定義的運算子實作為：只有在沒有適用的使用者定義運算子實作為時，才會考慮預先定義的運算子實作為，如[一元運算子](expressions.md#unary-operator-overload-resolution)多載解析和[二元運算子](expressions.md#binary-operator-overload-resolution)多載解析中所述。

可多載的***一元運算子***為：
```csharp
+   -   !   ~   ++   --   true   false
```

雖然不會在運算式中明確使用 `true` 和 `false` （因此不會包含在[運算子優先順序和關聯](expressions.md#operator-precedence-and-associativity)性的優先順序資料表中），但它們會被視為運算子，因為它們是在數個運算式內容中叫用的：布林運算式（[布林運算式](expressions.md#boolean-expressions)）和條件式邏輯運算子（條件式[邏輯運算子](expressions.md#conditional-logical-operators)[）的](expressions.md#conditional-operator)運算式。

可多載的***二元運算子***為：
```csharp
+   -   *   /   %   &   |   ^   <<   >>   ==   !=   >   <   >=   <=
```

只有上列運算子可以多載。 特別的是，您無法多載成員存取、方法叫用或 `=`、`&&`、`||`、`??`、`?:`、`=>`、`checked`、`unchecked`、`new`、`typeof`、`default`、`as`和 `is` 運算子。

二元運算子多載時，對應的指派運算子 (若有) 也會隱含地多載。 例如，運算子 `*` 的多載也是運算子 `*=`的多載。 這會在[複合指派](expressions.md#compound-assignment)中進一步說明。 請注意，指派運算子本身（`=`）無法多載。 指派一律會對變數執行簡單的位複製值。

轉換作業（例如 `(T)x`）會藉由提供使用者定義的轉換（[使用者定義的轉換](conversions.md#user-defined-conversions)）來進行多載。

元素存取（例如 `a[x]`）不會被視為可多載的運算子。 而是透過索引子（[索引子](classes.md#indexers)）來支援使用者定義的索引。

在運算式中，運算子是使用運算子標記法來參考，而在宣告中，運算子則是使用功能性標記法來參考。 下表顯示一元和二元運算子的運算子和功能標記法之間的關聯性。 在第一個專案中， *op*代表任何多載的一元前置運算子。 在第二個專案中， *op*代表一元後置 `++` 和 `--` 運算子。 在第三個專案中， *op*表示任何可多載的二元運算子。


| __運算子標記法__ | __功能標記法__ |
|-----------------------|-------------------------|
| `op x`                | `operator op(x)`        | 
| `x op`                | `operator op(x)`        | 
| `x op y`              | `operator op(x,y)`      | 

使用者定義的運算子宣告一律需要至少其中一個參數屬於包含運算子宣告的類別或結構類型。 因此，使用者定義的運算子不可能具有與預先定義之運算子相同的簽章。

使用者定義的運算子宣告無法修改運算子的語法、優先順序或關聯性。 例如，`/` 運算子一律是二元運算子，且一律具有以[運算子優先順序和關聯](expressions.md#operator-precedence-and-associativity)性指定的優先順序層級，而且一律為左關聯。

雖然使用者定義的運算子可以執行其所 pleases 的任何計算，但強烈建議您不要採用以直覺方式產生的結果。 例如，`operator ==` 的執行應該比較兩個運算元是否相等，並傳回適當的 `bool` 結果。

透過[條件式邏輯運算子](expressions.md#conditional-logical-operators)在[主要運算式](expressions.md#primary-expressions)中個別運算子的描述會指定運算子的預先定義的執行，以及適用于每個運算子的任何其他規則。 這些描述會使用***一元運算子***多載解析、***二元運算子***多載解析和***數值提升***的詞彙，其定義可在下列各節中找到。

### <a name="unary-operator-overload-resolution"></a>一元運算子多載解析

`op x` 或 `x op`形式的作業，其中 `op` 是可多載的一元運算子，而 `x` 是類型 `X`的運算式，其處理方式如下：

*  `X` 針對作業 `operator op(x)` 所提供的候選使用者定義運算子集合，是使用[候選使用者定義運算子](expressions.md#candidate-user-defined-operators)的規則來決定。
*  如果候選使用者定義的運算子集合不是空的，則這會成為作業的候選運算子集。 否則，預先定義的一元 `operator op` 實作為，包括其提升的形式，就會成為作業的候選運算子集。 指定運算子的預先定義實作為運算子（[主要運算式](expressions.md#primary-expressions)和[一元運算子](expressions.md#unary-operators)）的描述。
*  多載解析的多載解析[規則會套用](expressions.md#overload-resolution)至候選運算子集合，以選取與引數清單 `(x)`相關的最佳運算子，而這個運算子會成為多載解析程式的結果。 如果多載解析無法選取單一最佳運算子，則會發生系結時錯誤。

### <a name="binary-operator-overload-resolution"></a>二元運算子多載解析

`x op y`格式的作業，其中 `op` 是可多載的二元運算子，`x` 是 `X`類型的運算式，而 `y` 是類型 `Y`的運算式，其處理方式如下：

*  `X` 和 `Y` 為作業 `operator op(x,y)` 所提供的候選使用者定義運算子集合，是由所決定。 集合是由 `X` 所提供的候選運算子和 `Y`所提供的候選運算子所組成，每一個都是使用[候選使用者定義運算子](expressions.md#candidate-user-defined-operators)的規則來決定。 如果 `X` 和 `Y` 是相同的類型，或如果 `X` 和 `Y` 衍生自通用基底類型，則共用候選運算子只會出現在組合的一次。
*  如果候選使用者定義的運算子集合不是空的，則這會成為作業的候選運算子集。 否則，預先定義的二進位 `operator op` 的實作為，包括其提升的形式，就會變成作業的候選運算子集。 指定運算子的預先定義實作為運算子（透過[條件式邏輯運算子](expressions.md#conditional-logical-operators)的[算術運算子](expressions.md#arithmetic-operators)）的描述。 針對預先定義的列舉和委派運算子，唯一會考慮的運算子是由列舉或委派型別所定義，這是其中一個運算元的系結時間型別。
*  多載解析的多載解析[規則會套用](expressions.md#overload-resolution)至候選運算子集合，以選取與引數清單 `(x,y)`相關的最佳運算子，而這個運算子會成為多載解析程式的結果。 如果多載解析無法選取單一最佳運算子，則會發生系結時錯誤。

### <a name="candidate-user-defined-operators"></a>候選使用者定義的運算子

假設類型 `T` 和作業 `operator op(A)`（其中 `op` 是可多載的運算子，而 `A` 是引數清單），則由 `T` 為 `operator op(A)` 所提供的候選使用者定義運算子集合如下所示：

*  判斷 `T0`的類型。 如果 `T` 是可為 null 的型別，`T0` 是它的基礎型別，否則 `T0` 等於 `T`。
*  針對 `T0` 中的所有 `operator op` 宣告，以及這類運算子的所有提升形式，如果至少有一個運算子適用于引數清單 `A`的（適用的函式[成員](expressions.md#applicable-function-member)），則候選運算子集合會包含 `T0`中所有這類適用的運算子。
*  否則，如果 `object``T0`，候選運算子的集合就會是空的。
*  否則，`T0` 提供的候選運算子集合是 `T0`的直接基底類別所提供的候選運算子集合; 如果 `T0` 是類型參數，則為 `T0` 的有效基底類別。

### <a name="numeric-promotions"></a>數值升級

數值提升包含自動執行預先定義的一元和二元數值運算子之運算元的某些隱含轉換。 數值提升並不是不同的機制，而是將多載解析套用至預先定義之運算子的效果。 數值升級特別不會影響使用者定義運算子的評估，雖然可以實作為使用者定義的運算子來呈現類似的效果。

作為數值升級的範例，請考慮二元 `*` 運算子的預先定義的執行：

```csharp
int operator *(int x, int y);
uint operator *(uint x, uint y);
long operator *(long x, long y);
ulong operator *(ulong x, ulong y);
float operator *(float x, float y);
double operator *(double x, double y);
decimal operator *(decimal x, decimal y);
```

當多載解析規則（多載[解析](expressions.md#overload-resolution)）套用至這組運算子時，其效果會從運算元類型中選取隱含轉換存在的第一個運算子。 例如，針對作業 `b * s`，其中 `b` 是 `byte`，而 `s` 是 `short`時，多載解析會選取 `operator *(int,int)` 做為最佳運算子。 因此，效果是 `b` 和 `s` 會轉換成 `int`，而結果的類型會 `int`。 同樣地，針對作業 `i * d`，其中 `i` 是 `int`，而 `d` 是 `double`時，多載解析會選取 `operator *(double,double)` 做為最佳運算子。

#### <a name="unary-numeric-promotions"></a>一元數值提升

針對預先定義的 `+`、`-`和 `~` 一元運算子的運算元，會進行一元數值升級。 一元數值提升只包含將類型 `sbyte`、`byte`、`short`、`ushort`或 `char` 的運算元轉換成類型 `int`。 此外，對於一元 `-` 運算子，一元數值提升會將類型 `uint` 的運算元轉換為類型 `long`。

#### <a name="binary-numeric-promotions"></a>二進位數值升級

針對預先定義的 `+`、`-`、`*`、`/`、`%`、`&`、`|`、`^`、`==`、`!=`、`>`、`<`、`>=`和 `<=` 二元運算子的運算元，會進行二進位數值升級。 二進位數值提升會隱含地將兩個運算元轉換成一般類型，如果是非關聯式運算子，也會變成作業的結果類型。 二進位數值提升包含套用下列規則，順序如下所示：

*  如果任一個運算元的類型 `decimal`，則會將另一個運算元轉換成類型 `decimal`，如果另一個運算元的類型是 `float` 或 `double`，就會發生系結時錯誤。
*  否則，如果任一運算元的類型 `double`，則會將另一個運算元轉換成類型 `double`。
*  否則，如果任一運算元的類型 `float`，則會將另一個運算元轉換成類型 `float`。
*  否則，如果任一運算元的類型 `ulong`，則會將另一個運算元轉換成類型 `ulong`，如果另一個運算元的類型是 `sbyte`、`short`、`int`或 `long`，就會發生系結時錯誤。
*  否則，如果任一運算元的類型 `long`，則會將另一個運算元轉換成類型 `long`。
*  否則，如果任一運算元的類型是 `uint`，而另一個運算元的類型是 `sbyte`、`short`或 `int`，則兩個運算元都會轉換成類型 `long`。
*  否則，如果任一運算元的類型 `uint`，則會將另一個運算元轉換成類型 `uint`。
*  否則，兩個運算元都會轉換成類型 `int`。

請注意，第一個規則不允許混用 `decimal` 類型與 `double` 和 `float` 類型的任何作業。 此規則的原因是 `decimal` 類型和 `double` 與 `float` 類型之間沒有隱含轉換。

另請注意，當另一個運算元屬於帶正負號的整數類資料類型時，運算元不可能屬於類型 `ulong`。 原因是沒有可代表完整範圍 `ulong` 的整數類資料類型，以及帶正負號的整數類資料類型。

在上述兩種情況下，cast 運算式可以用來將一個運算元明確轉換成與另一個運算元相容的類型。

在範例中
```csharp
decimal AddPercent(decimal x, double percent) {
    return x * (1.0 + percent / 100.0);
}
```
發生系結時間錯誤，因為 `decimal` 無法乘以 `double`。 錯誤的解決方式是將第二個運算元明確轉換為 `decimal`，如下所示：

```csharp
decimal AddPercent(decimal x, double percent) {
    return x * (decimal)(1.0 + percent / 100.0);
}
```

### <a name="lifted-operators"></a>提升運算子

***提升運算子***允許在不可為 null 的實數值型別上運作的預先定義和使用者定義運算子，也可以搭配這些類型的可為 null 形式來使用。 提升運算子是根據符合特定需求的預先定義和使用者定義運算子所建立，如下所述：

*   一元運算子的

    ```csharp
    +  ++  -  --  !  ~
    ```

    如果運算元和結果類型都是不可為 null 的實數值型別，則會有一種形式的運算子。 藉由將單一 `?` 修飾詞新增至運算元和結果類型，即可建立此提升形式。 如果運算元為 null，則提升運算子會產生 null 值。 否則，提升運算子會解除包裝運算元、套用基礎運算子，並將結果包裝起來。

*   二元運算子

    ```csharp
    +  -  *  /  %  &  |  ^  <<  >>
    ```

    如果運算元和結果類型都是不可為 null 的實數值型別，則會有一種形式的運算子。 藉由將單一 `?` 修飾詞加入至每個運算元和結果類型，即可建立此提升格式。 如果一個或兩個運算元都是 null （例外狀況是 `bool?` 類型的 `&` 和 `|` 運算子（如[布林邏輯運算子](expressions.md#boolean-logical-operators)中所述），則提升運算子會產生 null 值。 否則，提升運算子會解除包裝運算元、套用基礎運算子，並將結果包裝起來。

*   適用于等號比較運算子

    ```csharp
    ==  !=
    ```

    如果運算元類型既不是可為 null 的實值型別，而且結果型別是 `bool`，則運算子的一種提升形式存在。 藉由將單一 `?` 修飾詞加入至每個運算元類型，即可建立此提升表單。 提升運算子會將兩個 null 值視為相等，並將 null 值與任何非 null 值不相等。 如果兩個運算元都不是 null，則提升的運算子會解除包裝運算元並套用基礎運算子，以產生 `bool` 結果。

*   針對關聯式運算子

    ```csharp
    <  >  <=  >=
    ```

    如果運算元類型既不是可為 null 的實值型別，而且結果型別是 `bool`，則運算子的一種提升形式存在。 藉由將單一 `?` 修飾詞加入至每個運算元類型，即可建立此提升表單。 如果一個或兩個運算元都是 null，則提升運算子會產生值 `false`。 否則，提升運算子會解除包裝運算元並套用基礎運算子，以產生 `bool` 結果。

## <a name="member-lookup"></a>成員查閱

成員查閱是一種程式，會決定類型內容中名稱的意義。 成員查詢可以做為評估運算式中的*simple_name* （[簡單名稱](expressions.md#simple-names)）或*member_access* （[成員存取](expressions.md#member-access)）的一部分。 如果*simple_name*或*member_access*會當做*invocation_expression*的*primary_expression* （[方法調用](expressions.md#method-invocations)）發生，則會將該成員視為叫用。

如果成員是方法或事件，或者如果它是委派類型（[委派](delegates.md)）或類型 `dynamic` （[動態類型](types.md#the-dynamic-type)）的常數、欄位或屬性，則會將成員視為*invocable*。

成員查閱不僅會考慮成員的名稱，也會考慮成員所擁有之類型參數的數目，以及是否可存取該成員。 基於成員查詢的目的，泛型方法和嵌套泛型型別具有在其個別宣告中指出的類型參數數目，而且所有其他成員都有零型別參數。

在類型 `T` 中，具有 `K` 類型參數之名稱的成員查閱 `N` 會依照下列方式處理：

*  首先，會決定一組名為 `N` 的可存取成員：
    * 如果 `T` 是型別參數，則集合會是在指定為 `T`之主要條件約束或次要條件約束（[類型參數條件約束](classes.md#type-parameter-constraints)）之每個類型中，名為 `N` 之可存取成員集合的聯集，以及 `object`中名為 `N` 的可存取成員集合。
    * 否則，此集合是由 `T`中名為 `N` 的所有可存取（[成員存取](basic-concepts.md#member-access)）成員所組成，包括繼承的成員和 `object`中名為 `N` 的可存取成員。 如果 `T` 是結構化型別，則會藉由替代類型引數來取得成員集合，如[結構化類型的成員](classes.md#members-of-constructed-types)中所述。 包含 `override` 修飾詞的成員會從集合中排除。
*  接下來，如果 `K` 為零，則會移除其宣告包含類型參數的所有巢狀型別。 如果 `K` 不是零，則會移除具有不同類型參數數目的所有成員。 請注意，當 `K` 為零時，不會移除具有型別參數的方法，因為型別推斷進程（[型別推斷](expressions.md#type-inference)）可能可以推斷型別引數。
*  接下來，如果叫用該成員，則會從*集合中移除*所有非*invocable*的成員。
*  接下來，會從集合中移除其他成員所隱藏的成員。 針對集合中的每個成員 `S.M`，其中 `S` 是宣告成員 `M` 的類型，則會套用下列規則：
    * 如果 `M` 是常數、欄位、屬性、事件或列舉成員，則會從集合中移除 `S` 的基底類型中宣告的所有成員。
    * 如果 `M` 是類型宣告，則在 `S` 的基底類型中宣告的所有非類型都會從集合中移除，而且所有具有相同類型 `M` 參數數目的類型宣告，都會從集合 `S` 中移除。
    * 如果 `M` 是方法，則會從集合中移除在 `S` 的基底類型中宣告的所有非方法成員。
*  接下來，會從集合中移除類別成員所隱藏的介面成員。 只有當 `T` 是型別參數，而且 `T` 同時具有 `object` 的有效基類和非空白的有效介面集（[型別參數條件約束](classes.md#type-parameter-constraints)）時，這個步驟才會生效。 針對集合中的每個成員 `S.M`，其中 `S` 是宣告成員 `M` 的類型，如果 `S` 是 `object`以外的類別宣告，則會套用下列規則：
    * 如果 `M` 是常數、欄位、屬性、事件、列舉成員或類型宣告，則會從集合中移除在介面宣告中宣告的所有成員。
    * 如果 `M` 是方法，則會從集合中移除介面宣告中宣告的所有非方法成員，並從集合中移除與在介面宣告中宣告之 `M` 簽章相同的所有方法。
*  最後，移除隱藏的成員後，就會決定查閱的結果：
    * 如果集合是由不是方法的單一成員所組成，則這個成員就是查閱的結果。
    * 否則，如果集合僅包含方法，則這個方法群組就是查閱的結果。
    * 否則，查閱是不明確的，而且會發生系結時錯誤。

針對類型參數和介面以外類型中的成員查閱，以及在介面中為嚴格單一繼承的成員查閱（繼承鏈中的每個介面都只有零或一個直接基底介面），查閱規則的效果為只有衍生的成員會隱藏具有相同名稱或簽章的基底成員。 這類的單一繼承查閱永遠不會造成混淆。 在多個繼承介面中，成員查閱可能引發的多義性會在[介面成員存取](interfaces.md#interface-member-access)中說明。

### <a name="base-types"></a>基底類型

基於成員查閱的目的，會將類型 `T` 視為具有下列基底類型：

*  如果 `object``T`，則 `T` 沒有基底類型。
*  如果 `T` 是*enum_type*，`T` 的基底類型為 `System.Enum`、`System.ValueType`和 `object`的類別類型。
*  如果 `T` 是*struct_type*，`T` 的基底類型是 `System.ValueType` 和 `object`的類別類型。
*  如果 `T` 是*class_type*，`T` 的基底類型是 `T`的基類，包括類別類型 `object`。
*  如果 `T` 是*interface_type*，`T` 的基底類型是 `T` 的基底介面，而類別類型 `object`。
*  如果 `T` 是*array_type*，`T` 的基底類型是 `System.Array` 和 `object`的類別類型。
*  如果 `T` 是*delegate_type*，`T` 的基底類型是 `System.Delegate` 和 `object`的類別類型。

## <a name="function-members"></a>函數成員

函數成員是包含可執行語句的成員。 函式成員一律是類型的成員，而且不能是命名空間的成員。 C#定義下列函數成員類別：

*  方法
*  屬性
*  「事件」
*  索引子
*  使用者定義的運算子
*  實例構造函式
*  靜態建構函式
*  解構函式

除了析構函式和靜態函式（無法明確叫用）以外，函數成員中包含的語句會透過函式成員調用來執行。 撰寫函式成員調用的實際語法取決於特定的函式成員分類。

函式成員調用的引數清單（[引數](expressions.md#argument-lists)清單）提供函式成員之參數的實際值或變數參考。

叫用泛型方法可能會採用型別推斷來判斷要傳遞給方法的型別引數集合。 此程式會在[型別推斷](expressions.md#type-inference)中說明。

調用方法、索引子、運算子和實例的函式會採用多載解析，以判斷要叫用的一組候選函式成員。 此程式會在多載[解析](expressions.md#overload-resolution)中說明。

一旦在系結階段識別特定的函式成員（可能是透過多載解析），就會在動態多載[解析的編譯階段檢查](expressions.md#compile-time-checking-of-dynamic-overload-resolution)中說明叫用函式成員的實際執行時間程式。

下表摘要說明可明確叫用的六個函式成員類別的結構中所發生的處理。 在資料表中，`e`、`x`、`y`和 `value` 指出分類為變數或值的運算式，`T` 表示分類為類型的運算式，`F` 是方法的簡單名稱，而 `P` 是屬性的簡單名稱。


| __建構__     | __範例__    | __描述__ |
|-------------------|----------------|-----------------|
| 方法引動過程 | `F(x,y)`       | 會套用多載解析，以選取在包含類別或結構中 `F` 的最佳方法。 使用引數清單 `(x,y)`叫用方法。 如果未 `static`此方法，則會 `this`實例運算式。 | 
|                   | `T.F(x,y)`     | 會套用多載解析，以選取類別或結構 `T`中 `F` 的最佳方法。 如果未 `static`方法，就會發生系結時錯誤。 使用引數清單 `(x,y)`叫用方法。 | 
|                   | `e.F(x,y)`     | 會套用多載解析，以在 `e`類型所提供的類別、結構或介面中選取最佳方法 F。 如果 `static`方法，就會發生系結時錯誤。 使用實例運算式叫用方法 `e` 和引數清單 `(x,y)`。 | 
| 屬性存取   | `P`            | 會叫用包含類別或結構中屬性 `P` 的 `get` 存取子。 如果 `P` 為僅限寫入，就會發生編譯時期錯誤。 如果未 `static``P`，則會 `this`實例運算式。 | 
|                   | `P = value`    | 包含類別或結構中屬性 `P` 的 `set` 存取子，會使用引數清單 `(value)`來叫用。 如果 `P` 是唯讀的，就會發生編譯時期錯誤。 如果未 `static``P`，則會 `this`實例運算式。 | 
|                   | `T.P`          | 會叫用類別或結構 `T` 中 `P` 屬性（property）的 `get` 存取子。 如果未 `static` `P`，或 `P` 為僅限寫入，就會發生編譯時期錯誤。 | 
|                   | `T.P = value`  | 類別或結構 `T` 中屬性 `P` 的 `set` 存取子，會以引數清單 `(value)`叫用。 如果未 `static` `P`，或 `P` 是唯讀的，就會發生編譯時期錯誤。 | 
|                   | `e.P`          | `e` 的類型所指定之類別、結構或介面中的屬性 `P` `get` 存取子，會以實例運算式 `e`來叫用。 如果 `P` `static` 或 `P` 為僅限寫入，則會發生系結時錯誤。 | 
|                   | `e.P = value`  | `e` 類型所指定之類別、結構或介面中的屬性 `P` 的 `set` 存取子，會以實例運算式 `e` 和引數清單 `(value)`叫用。 如果 `P` `static` 或 `P` 是唯讀的，就會發生系結時錯誤。 | 
| 事件存取      | `E += value`   | 會叫用包含類別或結構中事件 `E` 的 `add` 存取子。 如果 `E` 不是靜態的，則會 `this`實例運算式。 | 
|                   | `E -= value`   | 會叫用包含類別或結構中事件 `E` 的 `remove` 存取子。 如果 `E` 不是靜態的，則會 `this`實例運算式。 | 
|                   | `T.E += value` | 會叫用類別或結構 `T` 中事件 `E` 的 `add` 存取子。 如果 `E` 不是靜態的，就會發生系結時錯誤。 | 
|                   | `T.E -= value` | 會叫用類別或結構 `T` 中事件 `E` 的 `remove` 存取子。 如果 `E` 不是靜態的，就會發生系結時錯誤。 | 
|                   | `e.E += value` | `e` 的類型所指定之類別、結構或介面中事件 `E` 的 `add` 存取子，會以實例運算式 `e`來叫用。 如果 `E` 是靜態的，就會發生系結時錯誤。 | 
|                   | `e.E -= value` | `e` 的類型所指定之類別、結構或介面中事件 `E` 的 `remove` 存取子，會以實例運算式 `e`來叫用。 如果 `E` 是靜態的，就會發生系結時錯誤。 | 
| 索引子存取    | `e[x,y]`       | 會套用多載解析，以選取 e 類型所指定之類別、結構或介面中的最佳索引子。 索引子的 `get` 存取子會使用實例運算式來叫用 `e` 和引數清單 `(x,y)`。 如果索引子為僅限寫入，則會發生系結時錯誤。 | 
|                   | `e[x,y] = value` | 會套用多載解析，以在 `e`類型所提供的類別、結構或介面中選取最佳索引子。 索引子的 `set` 存取子會使用實例運算式來叫用 `e` 和引數清單 `(x,y,value)`。 如果索引子是唯讀的，就會發生系結時錯誤。 | 
| 運算子調用 | `-x`         | 會套用多載解析，以在 `x`的類型所指定的類別或結構中選取最佳的一元運算子。 使用引數清單 `(x)`叫用選取的運算子。 | 
|                     | `x + y`      | 會套用多載解析，以在 `x` 類型和 `y`所指定的類別或結構中選取最佳的二元運算子。 使用引數清單 `(x,y)`叫用選取的運算子。 | 
| 實例的函式呼叫 | `new T(x,y)` | 會套用多載解析，以在類別或結構 `T`中選取最佳實例的分析函數。 使用引數清單 `(x,y)`叫用實例的函式。 | 

### <a name="argument-lists"></a>引數清單

每個函式成員和委派調用都包含引數清單，可為函式成員的參數提供實際的值或變數參考。 指定函式成員調用之引數清單的語法，取決於函式成員分類：

*  若為實例的構造函式、方法、索引子和委派，引數會指定為*argument_list*，如下所述。 針對索引子，叫用 `set` 存取子時，引數清單會另外包含指定為指派運算子之右運算元的運算式。
*  對於屬性而言，當叫用 `get` 存取子時，引數清單是空的，而且會包含在叫用 `set` 存取子時，指定為指派運算子右運算元的運算式。
*  對於事件，引數清單是由指定為 `+=` 或 `-=` 運算子右運算元的運算式所組成。
*  針對使用者定義的運算子，引數清單是由一元運算子的單一運算元或二元運算子的兩個運算元所組成。

屬性（[屬性](classes.md#properties)）、事件（[事件](classes.md#events)）和使用者定義運算子（[運算子](classes.md#operators)）的引數一律會當做值參數（[值參數](classes.md#value-parameters)）傳遞。 索引子（[索引](classes.md#indexers)器）的引數一律會當做值參數（[值參數](classes.md#value-parameters)）或參數陣列（[參數陣列](classes.md#parameter-arrays)）傳遞。 這些函數成員分類不支援參考和輸出參數。

實例函式、方法、索引子或委派調用的引數會指定為*argument_list*：

```antlr
argument_list
    : argument (',' argument)*
    ;

argument
    : argument_name? argument_value
    ;

argument_name
    : identifier ':'
    ;

argument_value
    : expression
    | 'ref' variable_reference
    | 'out' variable_reference
    ;
```

*Argument_list*由一個或多個*引數*所組成，並以逗號分隔。 每個引數都包含一個選擇性的*argument_name*後面接著一個*argument_value*。 具有*argument_name*的*引數*稱為***具名引數***，而沒有*argument_name* *的引數*是***位置引數***。 位置引數會出現在*argument_list*中的具名引數後面，這是錯誤。

*Argument_value*可以採用下列其中一種形式：

*  *運算式*，表示引數會當做值參數（[值參數](classes.md#value-parameters)）傳遞。
*  關鍵字 `ref` 後面接著*variable_reference* （[變數參考](variables.md#variable-references)），表示引數會當做參考參數（[參考參數](classes.md#reference-parameters)）傳遞。 必須先明確指派變數（[明確指派](variables.md#definite-assignment)），才可以將它當做參考參數傳遞。 關鍵字 `out` 後面接著*variable_reference* （[變數參考](variables.md#variable-references)），表示引數會當做輸出參數（[輸出參數](classes.md#output-parameters)）傳遞。 在將變數當做輸出參數傳遞的函式成員調用之後，會將變數視為明確指派（[明確指派](variables.md#definite-assignment)）。

#### <a name="corresponding-parameters"></a>對應的參數

針對引數清單中的每個引數，在所叫用的函式成員或委派中必須有對應的參數。

下列所使用的參數清單的決定方式如下：

*  針對在類別中定義的虛擬方法和索引子，會從函式成員的最特定宣告或覆寫中挑選參數清單，從接收者的靜態類型開始，然後搜尋其基類。
*  如果是介面方法和索引子，則會從介面型別開始並搜尋基底介面，以從最特定的成員定義來挑選參數清單。 如果找不到唯一的參數清單，則會構造具有無法存取名稱的參數清單，而且不會建立選擇性參數，因此叫用不能使用已命名的參數或省略選擇性的引數。
*  對於部分方法，會使用定義部分方法宣告的參數清單。
*  對於所有其他函式成員和委派，只有一個參數清單，這是使用的一個。

引數或參數的位置會定義為引數清單或參數清單中之前的引數或參數的數目。

函式成員引數的對應參數建立方式如下：

*  實例（instance）、方法、索引子和委派之*argument_list*中的引數：
    * 位置引數，在參數清單中的相同位置發生固定參數時，會對應至該參數。
    * 具有以其一般格式叫用之參數陣列的函式成員的位置引數，會對應到參數陣列，這必須在參數清單中的相同位置。
    * 函式成員的位置引數，其中包含以其展開格式叫用的參數陣列，其中不會在參數清單中的相同位置發生固定參數，而會對應至參數陣列中的元素。
    * 具名引數會對應至參數清單中相同名稱的參數。
    * 針對索引子，叫用 `set` 存取子時，指定為指派運算子右運算元的運算式會對應到 `set` 存取子宣告的隱含 `value` 參數。
*  對於屬性，當叫用 `get` 存取子時，不會有任何引數。 叫用 `set` 存取子時，指定為指派運算子右運算元的運算式會對應到 `set` 存取子宣告的隱含 `value` 參數。
*  若為使用者定義的一元運算子（包括轉換），單一運算元會對應至運算子宣告的單一參數。
*  若為使用者定義的二進位運算子，左邊的運算元會對應到第一個參數，右運算元則對應至運算子宣告的第二個參數。

#### <a name="run-time-evaluation-of-argument-lists"></a>引數清單的執行時間評估

在執行時間處理函式成員調用（動態多載[解析的編譯階段檢查](expressions.md#compile-time-checking-of-dynamic-overload-resolution)）期間，引數清單的運算式或變數參考會依序從左至右評估，如下所示：

*  針對值參數，會評估引數運算式，並執行對應參數類型的隱含轉換（[隱含](conversions.md#implicit-conversions)轉換）。 產生的值會變成函數成員調用中 value 參數的初始值。
*  針對參考或輸出參數，會評估變數參考，而產生的儲存位置會變成函式成員調用中的參數所代表的儲存位置。 如果當做參考或輸出參數提供的變數參考是*reference_type*的陣列元素，則會執行執行時間檢查，以確保陣列的元素類型與參數的類型相同。 如果此檢查失敗，則會擲回 `System.ArrayTypeMismatchException`。

方法、索引子和實例的函式可能會將其最右邊的參數宣告為參數陣列（[參數陣列](classes.md#parameter-arrays)）。 這類函式成員會以其一般格式叫用，或根據適用的（適用的函式[成員](expressions.md#applicable-function-member)）展開的形式來叫用：

*  以一般格式叫用具有參數陣列的函式成員時，為參數陣列提供的引數必須是可隱含轉換（[隱含轉換](conversions.md#implicit-conversions)）為參數陣列類型的單一運算式。 在此情況下，參數陣列的作用會與值參數完全相同。
*  以擴充的形式叫用具有參數陣列的函式成員時，叫用必須為參數陣列指定零或多個位置引數，其中每個引數都是可隱含轉換（[隱含轉換](conversions.md#implicit-conversions)）為參數陣列之元素類型的運算式。 在此情況下，調用會使用對應引數數目的長度來建立參數陣列類型的實例、使用指定的引數值初始化陣列實例的元素，並使用新建立的陣列實例作為實際的引數.

引數清單的運算式一律會依照寫入的順序進行評估。 因此，範例
```csharp
class Test
{
    static void F(int x, int y = -1, int z = -2) {
        System.Console.WriteLine("x = {0}, y = {1}, z = {2}", x, y, z);
    }

    static void Main() {
        int i = 0;
        F(i++, i++, i++);
        F(z: i++, x: i++);
    }
}
```
產生下列輸出
```console
x = 0, y = 1, z = 2
x = 4, y = -1, z = 3
```

陣列的共同變異數規則（[陣列共變數](arrays.md#array-covariance)）允許陣列類型的值 `A[]` 為數組 `B[]`類型之實例的參考，但前提是從 `B` 到 `A`會有隱含的參考轉換。 基於這些規則，當*reference_type*的陣列元素當做參考或輸出參數傳遞時，需要執行時間檢查，以確保陣列的實際元素類型與參數的完全相同。 在範例中
```csharp
class Test
{
    static void F(ref object x) {...}

    static void Main() {
        object[] a = new object[10];
        object[] b = new string[10];
        F(ref a[0]);        // Ok
        F(ref b[1]);        // ArrayTypeMismatchException
    }
}
```
`F` 的第二個調用會導致 `System.ArrayTypeMismatchException` 擲回，因為 `b` 的實際元素類型是 `string` 而不是 `object`。

以擴充的形式叫用具有參數陣列的函式成員時，會將調用的處理方式，與使用陣列初始化運算式（[陣列建立運算式](expressions.md#array-creation-expressions)）插入展開的參數前後相同。 例如，假設宣告
```csharp
void F(int x, int y, params object[] args);
```
下列方法的展開形式調用
```csharp
F(10, 20);
F(10, 20, 30, 40);
F(10, 20, 1, "hello", 3.0);
```
完全對應至
```csharp
F(10, 20, new object[] {});
F(10, 20, new object[] {30, 40});
F(10, 20, new object[] {1, "hello", 3.0});
```

特別要注意的是，當參數陣列指定了零個引數時，就會建立空陣列。

當具有對應選擇性參數的函式成員省略引數時，會隱含地傳遞函數成員宣告的預設引數。 因為這些一律是常數，所以其評估不會影響其餘引數的評估順序。

### <a name="type-inference"></a>型別推斷

呼叫泛型方法時，若未指定型別引數，***型別推斷***程式會嘗試推斷呼叫的型別引數。 型別推斷的存在可讓您使用更方便的語法來呼叫泛型方法，並可讓程式設計人員避免指定多餘的型別資訊。 例如，假設有方法宣告：
```csharp
class Chooser
{
    static Random rand = new Random();

    public static T Choose<T>(T first, T second) {
        return (rand.Next(2) == 0)? first: second;
    }
}
```
不需要明確指定類型引數，就可以叫用 `Choose` 方法：
```csharp
int i = Chooser.Choose(5, 213);                 // Calls Choose<int>

string s = Chooser.Choose("foo", "bar");        // Calls Choose<string>
```

透過型別推斷，`int` 和 `string` 的型別引數是由方法的引數所決定。

型別推斷會在方法調用（[方法](expressions.md#method-invocations)調用）的系結時間處理中發生，並在叫用的多載解析步驟之前進行。 在方法調用中指定特定方法群組，而且未在方法調用中指定任何類型引數時，類型推斷會套用至方法群組中的每個泛型方法。 如果型別推斷成功，則會使用推斷的型別引數來決定後續多載解析的引數類型。 如果多載解析選擇要叫用的泛型方法，則會使用推斷的型別引數做為叫用的實際型別引數。 如果特定方法的型別推斷失敗，則該方法不會參與多載解析。 型別推斷本身的失敗不會造成系結時錯誤。 不過，當多載解析找不到任何適用的方法時，通常會導致系結時錯誤。

如果提供的引數數目與方法中的參數數目不同，則推斷會立即失敗。 否則，假設泛型方法具有下列簽章：
```csharp
Tr M<X1,...,Xn>(T1 x1, ..., Tm xm)
```

使用表單的方法呼叫 `M(E1...Em)` 型別推斷的工作是尋找每個型別 `X1...Xn` 參數 `S1...Sn` 的唯一型別引數，以便讓呼叫 `M<S1...Sn>(E1...Em)` 變成有效的。

在推斷的過程中，每個型別參數 `Xi` 都會固定為特定型別 *，`Si` 或未*與一組相關聯的*界限*一併*修復*。 每個範圍都是 `T`的類型。 一開始，每個類型變數 `Xi` 都不會與一組空的界限一併修復。

型別推斷會在階段中進行。 每個階段都會根據上一個階段的結果，嘗試推斷更多型別變數的型別引數。 第一個階段會進行界限的初始推斷，而第二個階段會將類型變數修正為特定類型，並推斷進一步的範圍。 第二個階段可能必須重複數次。

*注意：* 只有在呼叫泛型方法時，才會進行型別推斷。 方法群組轉換的型別推斷會在[方法群組的轉換](expressions.md#type-inference-for-conversion-of-method-groups)和尋找[一組運算式](expressions.md#finding-the-best-common-type-of-a-set-of-expressions)的最佳一般型別中加以說明，並找出一組運算式的最佳常見型別。

#### <a name="the-first-phase"></a>第一個階段

針對每個方法引數 `Ei`：

*   如果 `Ei` 是匿名函式，則會從 `Ei` 將*明確的參數型別推斷*（[明確的參數型](expressions.md#explicit-parameter-type-inferences)別推斷）設為 `Ti`
*   否則，如果 `Ei` 的類型為 `U`，而 `xi` 是值參數，則會*從*`U`*到*`Ti`進行*下限推斷*。
*   否則，如果 `Ei` 的類型為 `U`，而 `xi` 是 `ref` 或 `out` 參數，那麼就會*從*`U`*到*`Ti`進行*完全推斷*。
*   否則，就不會對這個引數進行推斷。


#### <a name="the-second-phase"></a>第二個階段

第二個階段會繼續進行，如下所示：

*   所有*未固定的類型變數*`Xi` 不*相依于*（相依[性）任何](expressions.md#dependence)`Xj` 都已修正（[修正](expressions.md#fixing)）。
*   如果不存在這類類型變數，則所有未*固定*的類型變數 `Xi` 皆為下列所有保留的*固定*：
    *   至少有一個類型變數 `Xj` 相依于 `Xi`
    *   `Xi` 具有非空白的界限集合
*   如果沒有這類類型變數，而且仍然有未*固定*的類型變數，型別推斷就會失敗。
*   否則，如果沒有任何進一步的未*固定*類型變數存在，型別推斷就會成功。
*   否則，對於具有對應參數類型的所有引數 `Ei` `Ti`*其中輸出類型*（[輸出類型](expressions.md#output-types)）包含未*固定*的類型變數 `Xj` 但*輸入類型*（[輸入類型](expressions.md#input-types)）不是，則會*從*`Ei`*到*`Ti`進行*輸出類型推斷*（[輸出類型推斷](expressions.md#output-type-inferences)）。 然後會重複第二個階段。

#### <a name="input-types"></a>輸入類型

如果 `E` 是方法群組或隱含類型的匿名函式，且 `T` 是委派類型或運算式樹狀架構類型，則 `T` 的所有參數類型都會是*類型*`T`的*輸入類型*`E`。

####  <a name="output-types"></a>輸出類型

如果 `E` 是方法群組或匿名函式，而 `T` 是委派型別或運算式樹狀架構型別，則 `T` 的傳回型別就是*型*別為 `T`之 `E` 的*輸出型*別。

#### <a name="dependence"></a>夜間

未*固定*的類型變數 `Xi`*直接相依于*未固定的類型變數 `Xj` 如果針對 `Tk` 具有類型 `Xj` 的某些引數 `Ek`，`Ek` 的*輸入類型*`Tk`，而 `Xi` 出現在類型 `Ek` 的*輸出類型*`Tk`中。

`Xj`*取決*于 `Xi`，如果 `Xj`*直接相依于*`Xi`，或 `Xi`*直接*相依于 `Xk`，`Xk` 則*取決於*`Xj`。 因此「相依于」是可轉移的，但不是「直接相依于」的反的關閉。

#### <a name="output-type-inferences"></a>輸出類型推斷

*輸出類型推斷*是*從*運算式 `E`*到*類型 `T` 以下列方式進行：

*  如果 `E` 是具有推斷傳回類型的匿名函式 `U`[（推斷](expressions.md#inferred-return-type)的傳回型別），而 `T` 是具有傳回型別 `Tb`的委派型別或運算式樹狀結構型別，則會*從*`U`*到*`Tb`進行*較低*的系結推斷（[較低](expressions.md#lower-bound-inferences)系結）。
*  否則，如果 `E` 是方法群組，而 `T` 是具有參數類型 `T1...Tk` 和傳回類型 `Tb`的委派類型或運算式樹狀結構類型，而且 `E` 具有類型 `T1...Tk` 的多載解析會產生傳回類型 `U`的單一方法，則會*從*`U`*到*`Tb`進行*下限推斷*。
*  否則，如果 `E` 是具有類型 `U`的運算式，則會*從*`U`*到*`T`進行*較低*系結的推斷。
*  否則，就不會進行推斷。

#### <a name="explicit-parameter-type-inferences"></a>明確參數型別推斷

*明確的參數型別推斷*是*從*運算式 `E`*到*型別 `T` 以下列方式進行：

*  如果 `E` 是明確類型的匿名函式，且參數類型為 `U1...Uk`，而且 `T` 是具有參數類型 `V1...Vk` 的委派類型或運算式樹狀結構類型，然後針對每個`Ui` 進行 *完全推斷*（[確切推斷](expressions.md#exact-inferences)）*從*`Ui`*到*對應的 0。

#### <a name="exact-inferences"></a>確切推斷

*從*類型 `U`*到*類型 `V` 的*確切推斷*，如下所示：

*  如果 `V` 為未*固定*的 `Xi` 之一，則 `U` 會加入至 `Xi`的確切界限集合。

*  否則，會藉由檢查是否有下列情況來決定 `V1...Vk` 和 `U1...Uk`：

   *  `V` 是陣列類型 `V1[...]` 而且 `U` 是相同次序的陣列類型 `U1[...]`
   *  `V` 是類型 `V1?` 而且 `U` 是類型 `U1?`
   *  `V` 是結構化型別 `C<V1...Vk>`而且 `U` 是結構化型別 `C<U1...Uk>`

   如果套用上述任何一種情況，則會*從*每*個 `Ui` 對*對應的 `Vi`進行*完全推斷*。

*  否則不會進行推斷。

#### <a name="lower-bound-inferences"></a>下限推斷

*從*類型 `U`*到*類型 `V` 的*下限推斷*，如下所示：

*  如果 `V` 為未*固定*的 `Xi` 之一，則 `U` 會加入至 `Xi`的下限集合。
*  否則，如果 `V` 是類型 `V1?`而且 `U` 是類型 `U1?` 則會從 `U1` 到 `V1`進行下限推斷。
*  否則，會藉由檢查是否有下列情況來決定 `U1...Uk` 和 `V1...Vk`：
   *  `V` 是陣列類型 `V1[...]` 而且 `U` 是相同次序的陣列類型 `U1[...]` （或其有效基底類型為 `U1[...]`的類型參數）
   *  `V` 是 `IEnumerable<V1>`、`ICollection<V1>` 或 `IList<V1>` 的其中一個，而 `U` 是一維陣列類型 `U1[]`（或其有效基底類型為 `U1[]`的類型參數）
   *  `V` 是一種結構化的類別、結構、介面或委派類型 `C<V1...Vk>` 而且有唯一的類型 `C<U1...Uk>` 讓 `U` （或者，如果 `U` 是類型參數、其有效的基類或其有效介面集的任何成員）與、繼承自（直接或間接），或直接或間接的 `C<U1...Uk>`。

      （「唯一性」限制表示在案例介面中 `C<T> {} class U: C<X>, C<Y> {}`，從 `U` 推斷到 `C<T>` 時，不會進行推斷，因為 `U1` 可以 `X` 或 `Y`）。

   如果套用上述任何一種情況，則會*從*每個 `Ui`*到*對應 `Vi` 進行推斷，如下所示：

   *  如果 `Ui` 不知道是參考型別，則會進行*完全推斷*
   *  否則，如果 `U` 是陣列型別，則會進行*較低界限的推斷*
   *  否則，如果 `V` `C<V1...Vk>`，則推斷取決於 `C`的第 i 個類型參數：
      *  如果它是協變數，則會進行*較低界限的推斷*。
      *  如果它是逆變性，則會進行*上限推斷*。
      *  如果它是不變的，則會進行*完全推斷*。
*  否則，就不會進行推斷。

#### <a name="upper-bound-inferences"></a>上限推斷

*從*類型 `U`*到*類型 `V` 的*上限推斷*，如下所示：

*  如果 `V` 為未*固定*的 `Xi` 之一，則 `U` 會加入至 `Xi`的上限集合。
*  否則，會藉由檢查是否有下列情況來決定 `V1...Vk` 和 `U1...Uk`：
   *  `U` 是陣列類型 `U1[...]` 而且 `V` 是相同次序的陣列類型 `V1[...]`
   *  `U` 是 `IEnumerable<Ue>`、`ICollection<Ue>` 或 `IList<Ue>` 的其中一個，而 `V` 是一維陣列類型 `Ve[]`
   *  `U` 是類型 `U1?` 而且 `V` 是類型 `V1?`
   *  `U` 是結構化的類別、結構、介面或委派類型 `C<U1...Uk>` 而且 `V` 是與相同的類別、結構、介面或委派類型、繼承自（直接或間接），或實作為唯一類型的（直接或間接） `C<V1...Vk>`

      （「唯一性」限制表示如果我們有 `interface C<T>{} class V<Z>: C<X<Z>>, C<Y<Z>>{}`，則從 `C<U1>` 推斷到 `V<Q>`時，不會進行推斷。 推斷不會從 `U1` 進行，`X<Q>` 或 `Y<Q>`）。

   如果套用上述任何一種情況，則會*從*每個 `Ui`*到*對應 `Vi` 進行推斷，如下所示：
   *  如果 `Ui` 不知道是參考型別，則會進行*完全推斷*
   *  否則，如果 `V` 是陣列類型，則會進行*上限推斷*
   *  否則，如果 `U` `C<U1...Uk>`，則推斷取決於 `C`的第 i 個類型參數：
      *  如果它是協變數，則會進行*上限推斷*。
      *  如果是反變數，則會進行*較低界限的推斷*。
      *  如果它是不變的，則會進行*完全推斷*。
*  否則，就不會進行推斷。   

#### <a name="fixing"></a>修正

未*固定的類型變數*`Xi` 具有一組界限，如下*所示：*

*  *候選類型*的集合 `Uj` 一開始就是 `Xi`界限集合中的所有類型集合。
*  接著，我們會檢查每個 `Xi` 的系結：對於 `Xi` 所有與 `U` 不完全相同的 `U` 之每個完全系結的 `Uj`，會從候選集合中移除。 對於 `Xi` 的每個下限 `U`，會從候選集合中移除*不*是從 `U` 隱含轉換的所有類型 `Uj`。 針對 `Xi` 的每個上限 `U`，*不*會從候選集合中移除隱含轉換成 `U` 的所有類型 `Uj`。
*  如果剩餘的候選類型 `Uj` 有一個唯一的類型 `V`，其中隱含轉換至所有其他候選類型，則 `Xi` 會固定到 `V`。
*  否則，型別推斷會失敗。

#### <a name="inferred-return-type"></a>推斷的傳回型別

匿名函式的推斷傳回類型 `F` 會在型別推斷和多載解析期間使用。 只能針對所有參數類型為已知的匿名函式來判斷推斷的傳回類型，因為它們是明確指定的，可透過匿名函式轉換來提供，或在封閉式泛型的型別推斷期間推斷方法調用。

***推斷的結果類型***的判斷方式如下：

*  如果 `F` 的主體是具有型別的*運算式*，則 `F` 的推斷結果型別就是該運算式的型別。
*  如果 `F` 的主體是*區塊*，而且區塊的 `return` 語句中的運算式集合具有最佳的一般類型 `T` （[尋找一組運算式的最佳一般類型](expressions.md#finding-the-best-common-type-of-a-set-of-expressions)），則會 `T`所推斷的結果 `F` 類型。
*  否則，將無法推斷 `F`的結果類型。

推斷的傳回***型***別的判斷方式如下：

*  如果 `F` 是非同步，而且 `F` 的主體是分類為「無」（[運算式分類](expressions.md#expression-classifications)）的運算式，或是不含任何傳回語句的語句區塊，則推斷的傳回型別會 `System.Threading.Tasks.Task`
*  如果 `F` 是非同步，而且具有 `T`的推斷結果類型，則會 `System.Threading.Tasks.Task<T>`推斷的傳回類型。
*  如果 `F` 是非非同步，而且具有 `T`的推斷結果型別，則會 `T`推斷的傳回型別。
*  否則，將無法推斷 `F`的傳回型別。

做為涉及匿名函式之型別推斷的範例，請考慮在 `System.Linq.Enumerable` 類別中宣告的 `Select` 擴充方法：
```csharp
namespace System.Linq
{
    public static class Enumerable
    {
        public static IEnumerable<TResult> Select<TSource,TResult>(
            this IEnumerable<TSource> source,
            Func<TSource,TResult> selector)
        {
            foreach (TSource element in source) yield return selector(element);
        }
    }
}
```

假設 `System.Linq` 命名空間是使用 `using` 子句匯入，而且指定了類別 `Customer` 並具有類型 `string`的 `Name` 屬性，則可以使用 `Select` 方法來選取客戶清單的名稱：
```csharp
List<Customer> customers = GetCustomerList();
IEnumerable<string> names = customers.Select(c => c.Name);
```

`Select` 的擴充方法叫用（[擴充方法調用](expressions.md#extension-method-invocations)）是藉由將調用重寫為靜態方法調用來處理：
```csharp
IEnumerable<string> names = Enumerable.Select(customers, c => c.Name);
```

由於未明確指定類型引數，因此會使用型別推斷來推斷型別引數。 首先，`customers` 引數與 `source` 參數相關，推斷 `T` `Customer`。 然後，使用上述的匿名函式型別推斷程式，`c` 的型別 `Customer`，而運算式 `c.Name` 與 `selector` 參數的傳回型別相關，推斷 `S` 為 `string`。 因此，調用相當於
```csharp
Sequence.Select<Customer,string>(customers, (Customer c) => c.Name)
```
而結果的類型為 `IEnumerable<string>`。

下列範例示範匿名函式型別推斷如何在泛型方法調用中的引數之間，使用「flow」型別資訊。 假設有方法：
```csharp
static Z F<X,Y,Z>(X value, Func<X,Y> f1, Func<Y,Z> f2) {
    return f2(f1(value));
}
```

調用的型別推斷：
```csharp
double seconds = F("1:15:30", s => TimeSpan.Parse(s), t => t.TotalSeconds);
```
如下所示：首先，引數 `"1:15:30"` 與 `value` 參數相關，推斷 `X` 以 `string`。 然後，會為第一個匿名函式（`s`）指定 `string`的推斷型別，而且運算式 `TimeSpan.Parse(s)` 與 `f1`的傳回型別相關，推斷 `Y` 要 `System.TimeSpan`。 最後，第二個匿名函式的參數（`t`）會獲得推斷的型別 `System.TimeSpan`，而運算式 `t.TotalSeconds` 與 `f2`的傳回型別相關，推斷 `Z` 要 `double`。 因此，調用的結果是 `double`類型。

#### <a name="type-inference-for-conversion-of-method-groups"></a>方法群組轉換的型別推斷

類似于泛型方法的呼叫，當包含泛型方法的方法群組 `M` 轉換成給定的委派類型 `D` （[方法群組轉換](conversions.md#method-group-conversions)）時，也必須套用型別推斷。 提供方法
```csharp
Tr M<X1...Xn>(T1 x1 ... Tm xm)
```
和方法群組 `M` 指派給委派類型 `D` 推斷類型的工作是尋找類型引數 `S1...Sn` 讓運算式：
```csharp
M<S1...Sn>
```
與 `D`變得相容（[委派](delegates.md#delegate-declarations)宣告）。

不同于泛型方法呼叫的類型推斷演算法，在此情況下，只有引數*類型*，沒有引數*運算式*。 特別的是，沒有任何匿名函式，因此不需要推斷的多個階段。

相反地，所有 `Xi` 都會被視為未*固定*的，而且會*從*`Uj` `D` 的每個引數型別*到*`M`的對應參數類型 `Tj` 進行*較低*系結的推斷。 如果 `Xi` 找不到任何界限，則型別推斷會失敗。 否則，所有 `Xi` 都會*固定*為對應的 `Si`，這是型別推斷的結果。

#### <a name="finding-the-best-common-type-of-a-set-of-expressions"></a>尋找一組運算式的最佳一般類型

在某些情況下，必須為一組運算式推斷一般類型。 特別的是，以這種方式找到隱含類型陣列的元素類型，以及具有*區塊*主體的匿名函式的傳回類型。

直覺上，假設有一組運算式 `E1...Em` 此推斷應該相當於呼叫方法
```csharp
Tr M<X>(X x1 ... X xm)
```
with `Ei` 做為引數。

更精確的說，推斷是以未*固定*的型別變數 `X`來開始。 然後，系統會*從*每個 `Ei` 進行*輸出類型推斷* *，以*`X`。 最後，`X` 是*固定*的，而且如果成功，所產生的型別 `S` 就是運算式所產生的最佳一般型別。 如果沒有這類 `S` 存在，運算式就沒有最佳的一般類型。

### <a name="overload-resolution"></a>多載解析

多載解析是一種系結時間機制，可讓您選取要叫用的最佳函式成員，方法是指定引數清單和一組候選函數成員。 多載解析會選取函式成員，以在內C#的下列不同內容中叫用：

*  在*invocation_expression* （[方法調用](expressions.md#method-invocations)）中名為的方法的調用。
*  在*object_creation_expression* （[物件建立運算式](expressions.md#object-creation-expressions)）中名為的實例函式的調用。
*  透過*element_access* （專案[存取](expressions.md#element-access)）的索引子存取子調用。
*  運算式中參考之預先定義或使用者定義的運算子（[一元運算子](expressions.md#unary-operator-overload-resolution)多載解析和[二元運算子](expressions.md#binary-operator-overload-resolution)多載解析）的調用。

這些內容中的每一個都會以其獨特的方式定義一組候選函式成員和引數清單，如以上所列的詳細說明。 例如，方法調用的候選集合不包含標記為 `override` （[成員查閱](expressions.md#member-lookup)）的方法，而且如果衍生類別中的任何方法適用（[方法調用](expressions.md#method-invocations)），則基類中的方法不是候選項目。

一旦識別出候選函式成員和引數清單之後，在所有情況下，最佳函式成員的選取範圍都相同：

*  假設有一組適用的候選函式成員，就會找到該集合中的最佳函式成員。 如果集合僅包含一個函式成員，則該函式成員就是最佳的函式成員。 否則，最佳的函式成員就是一個優於指定引數清單的所有其他函式成員的函式成員，前提是每個函式成員都會使用[更好](expressions.md#better-function-member)的函式成員中的規則來與其他所有函式成員進行比較。 如果沒有一個比所有其他函式成員更好的函式成員，則函式成員調用是不明確的，而且會發生系結時錯誤。

下列章節會定義詞彙適用函式***成員***和***更好***的函式成員的確切意義。

#### <a name="applicable-function-member"></a>適用的函式成員

當下列所有條件都成立時，函式成員就會被視為適用于引數清單 `A` 的函式***成員***：

*  `A` 中的每個引數都會對應至函式成員宣告中的參數（如[對應的參數](expressions.md#corresponding-parameters)中所述），而且任何沒有引數對應的參數都是選擇性參數。
*  針對 `A`中的每個引數，引數的參數傳遞模式（亦即，value、`ref`或 `out`）等同于對應參數的參數傳遞模式，以及
   *  針對值參數或參數陣列，隱含轉換（[隱含轉換](conversions.md#implicit-conversions)）會從引數到對應參數的類型，或
   *  若為 `ref` 或 `out` 參數，引數的類型與對應參數的類型相同。 畢竟，`ref` 或 `out` 參數是所傳遞之引數的別名。

對於包含參數陣列的函式成員，如果函式成員適用于上述規則，則會被視為適用于其***一般形式***。 如果包含參數陣列的函式成員不適用其一般格式，則函式成員可能會改為適用于其***擴充形式***：

*  藉由將函式成員宣告中的參數陣列取代為參數陣列之元素類型的零個或多個值參數，讓引數清單中的引數數目 `A` 符合參數的總數目，來建立展開的表單。 如果 `A` 的引數數目比函式成員宣告中的固定參數數少，則無法構造函式成員的展開形式，因此不適用。
*  否則，如果對中的每個引數 `A`，引數的參數傳遞模式等同于對應參數的參數傳遞模式，則適用展開的表單。
   *  若為 fixed 值參數或擴充所建立的值參數，隱含轉換（[隱含轉換](conversions.md#implicit-conversions)）會從引數的類型存在對應的參數類型中，或
   *  若為 `ref` 或 `out` 參數，引數的類型與對應參數的類型相同。

#### <a name="better-function-member"></a>更好的函式成員

為了決定較好的函式成員，會將移除的引數清單結構化，其中只包含引數運算式本身出現在原始引數清單中的順序。

每個候選函式成員的參數清單會以下列方式進行結構化：

*  如果函式成員僅適用于展開的形式，則會使用展開的表單。
*  不含對應引數的選擇性參數會從參數清單中移除
*  這些參數會重新排序，使其出現在引數清單中與對應引數相同的位置。

假設引數清單 `A` 具有一組引數運算式 `{E1, E2, ..., En}` 以及兩個適用的函式成員 `Mp` 和 `Mq` 參數類型 `{P1, P2, ..., Pn}` 和 `{Q1, Q2, ..., Qn}`，則 `Mp` 定義為比 `Mq`***更好***的函式成員。

*  針對每個引數，從 `Ex` 到 `Qx` 的隱含轉換不會優於從 `Ex` 到 `Px`的隱含轉換。
*  針對至少一個引數，從 `Ex` 到 `Px` 的轉換比從 `Ex` 轉換為 `Qx`的效果更好。

執行此評估時，如果 `Mp` 或 `Mq` 適用于其展開的格式，則 `Px` 或 `Qx` 會以參數清單的展開形式來參考參數。

如果參數類型序列 `{P1, P2, ..., Pn}` 和 `{Q1, Q2, ..., Qn}` 相等（也就是每個 `Pi` 都有對應 `Qi`的識別轉換），則會依序套用下列系結規則，以判斷更好的函式成員。

*  如果 `Mp` 是非泛型方法，而 `Mq` 是泛型方法，則 `Mp` 比 `Mq`好。
*  否則，如果 `Mp` 適用于其標準格式，且 `Mq` 具有 `params` 陣列，而且只適用于其展開的格式，則 `Mp` 會優於 `Mq`。
*  否則，如果 `Mp` 的宣告參數數超過 `Mq`，則 `Mp` 比 `Mq`好。 如果這兩個方法都有 `params` 陣列，而且只適用于其展開的形式，就會發生這種情況。
*  否則，如果 `Mp` 的所有參數都有對應的引數，而預設引數必須在 `Mq` 中取代為至少一個選擇性參數，則 `Mp` 比 `Mq`更好。
*  否則，如果 `Mp` 具有比 `Mq`更多的特定參數類型，則 `Mp` 會優於 `Mq`。 讓 `{R1, R2, ..., Rn}` 和 `{S1, S2, ..., Sn}` 代表 `Mp` 和 `Mq`的未具現化和未展開的參數類型。 `Mp`的參數類型比 `Mq`更具體的是，如果每個參數的 `Rx` 不是特定于 `Sx`，而且至少有一個參數，則 `Rx` 比 `Sx`更明確：
   *  型別參數比非型別參數較不明確。
   *  如果至少有一個型別引數較明確，而且沒有任何型別引數比另一個中的對應型別引數更明確，則結構化型別會以遞迴方式比另一個結構化型別更明確（具有相同的型別引數數目）。
   *  如果第一個陣列類型的專案類型比第二個數組類型的專案類型更明確，則陣列型別會比另一個陣列型別更明確（具有相同的維度數目）。
*  否則，如果一個成員是一個非提升運算子，另一個則是提升運算子，則不會提升。
*  否則，函數成員都不會更好。

#### <a name="better-conversion-from-expression"></a>從運算式進行更好的轉換

針對從運算式 `E` 轉換為類型 `T1`的隱含轉換 `C1`，以及從運算式 `E` 轉換成類型 `T2`的隱含轉換 `C2`，如果 `C1` 不完全符合 `C2` 且至少包含下列其中一個保留，則 `E` 會是***更好的轉換***：

* `E` 完全符合 `T1` （[完全相符的運算式](expressions.md#exactly-matching-expression)）
* `T1` 比 `T2` 更好的轉換目標（[較佳的轉換目標](expressions.md#better-conversion-target)）

#### <a name="exactly-matching-expression"></a>完全相符的運算式

指定運算式 `E` 和類型 `T`時，如果下列其中一項保留，`E` 完全符合 `T`：

*  `E` 具有 `S`類型，而且從 `S` 到的身分識別轉換已存在 `T`
*  `E` 是匿名函式，`T` 是委派類型 `D` 或運算式樹狀架構類型 `Expression<D>` 和下列其中一項保留：
   *  在 `D` （推斷的傳回[型](expressions.md#inferred-return-type)別）的參數清單內容中，`E` 的推斷傳回型別 `X` 存在，而且從 `X` 到傳回型別的識別轉換存在 `D`
   *  `E` 是非非同步，而且 `D` 有傳回型別 `Y` 或 `E` 是非同步，而且 `D` 有傳回型別 `Task<Y>`，而下列其中一項保留：
      * `E` 的主體是完全符合 `Y` 的運算式
      * `E` 的主體是語句區塊，其中每個傳回語句都會傳回完全符合的運算式 `Y`

#### <a name="better-conversion-target"></a>較佳的轉換目標

假設有兩種不同的型別 `T1` 和 `T2`，如果沒有從 `T2` 到 `T1` 的隱含轉換，則 `T1` 是比 `T2` 更好的轉換目標，而且至少會有下列其中一項保留：

*  從 `T1` 到 `T2` 的隱含轉換已存在
*  `T1` 是委派類型 `D1` 或運算式樹狀結構類型 `Expression<D1>`，`T2` 是委派類型 `D2` 或運算式樹狀結構類型 `Expression<D2>`，`D1` 有傳回類型 `S1` 和下列其中一項保留：
   * `D2` 傳回 void
   * `D2` 具有 `S2`的傳回類型，而 `S1` 是比 `S2` 更佳的轉換目標
*  `T1` 為 `Task<S1>`，`T2` 為 `Task<S2>`，而 `S1` 是比 `S2` 更佳的轉換目標
*  `T1` 是 `S1` 或 `S1?`，其中 `S1` 是帶正負號的整數類資料類型，而 `T2` `S2` 或 `S2?`，其中 `S2` 是不帶正負號的整數類資料類型。 尤其是：
   * `S1` 為 `sbyte`，`S2` 為 `byte`、`ushort`、`uint`或 `ulong`
   * `S1` 為 `short`，`S2` 為 `ushort`、`uint`或 `ulong`
   * `S1` 為 `int`，`S2` 為 `uint`，或 `ulong`
   * `S1` 為 `long`，`S2` 為 `ulong`

#### <a name="overloading-in-generic-classes"></a>泛型類別中的多載

雖然宣告的簽章必須是唯一的，但類型引數的替代可能會產生相同的簽章。 在這種情況下，上述多載解析的中斷規則會挑選最特定的成員。

下列範例會根據此規則顯示有效和不正確多載：

```csharp
interface I1<T> {...}

interface I2<T> {...}

class G1<U>
{
    int F1(U u);                  // Overload resolution for G<int>.F1
    int F1(int i);                // will pick non-generic

    void F2(I1<U> a);             // Valid overload
    void F2(I2<U> a);
}

class G2<U,V>
{
    void F3(U u, V v);            // Valid, but overload resolution for
    void F3(V v, U u);            // G2<int,int>.F3 will fail

    void F4(U u, I1<V> v);        // Valid, but overload resolution for    
    void F4(I1<V> v, U u);        // G2<I1<int>,int>.F4 will fail

    void F5(U u1, I1<V> v2);      // Valid overload
    void F5(V v1, U u2);

    void F6(ref U u);             // valid overload
    void F6(out V v);
}
```

### <a name="compile-time-checking-of-dynamic-overload-resolution"></a>動態多載解析的編譯階段檢查

對於大部分動態系結的作業而言，解析的可能候選項目集在編譯時期是未知的。 不過在某些情況下，候選集合在編譯時期是已知的：

*  使用動態引數的靜態方法呼叫
*  接收者不是動態運算式的實例方法呼叫
*  接收者不是動態運算式的索引子呼叫
*  使用動態引數的函式呼叫

在這些情況下，會針對每個候選項目執行有限的編譯時間檢查，以查看是否有任何可能會在執行時間套用。這項檢查包含下列步驟：

*  部分型別推斷：不直接或間接相依于型別 `dynamic` 之引數的任何型別引數，都會使用[型別推斷](expressions.md#type-inference)的規則來推斷。 其餘的類型引數不明。
*  部分適用性檢查：適用性是根據適用的函式[成員](expressions.md#applicable-function-member)進行檢查，但忽略其類型不明的參數。
*  如果沒有候選項通過這項測試，就會發生編譯時期錯誤。

### <a name="function-member-invocation"></a>函數成員調用

本節說明在執行時間執行特定函式成員時所發生的程式。 假設系結時間進程已經判斷要叫用的特定成員，可能的方法是將多載解析套用至一組候選函式成員。

為了描述叫用程式，函式成員分成兩個類別：

*  靜態函式成員。 這些是實例的構造函式、靜態方法、靜態屬性存取子和使用者定義的運算子。 靜態函式成員一律為非虛擬。
*  實例函式成員。 這些是實例方法、實例屬性存取子和索引子存取子。 實例函式成員為非虛擬或虛擬，而且一律會在特定實例上叫用。 實例是由實例運算式所計算，並可在函式成員中以 `this` （[此存取權](expressions.md#this-access)）的形式存取。

函式成員調用的執行時間處理包含下列步驟，其中 `M` 是函數成員，而如果 `M` 是實例成員，`E` 是實例運算式：

*  如果 `M` 是靜態函式成員：
   * 引數清單會依照[引數](expressions.md#argument-lists)清單中的說明進行評估。
   * 叫用 `M`。

*  如果 `M` 是在*value_type*中宣告的實例函式成員：
   * 評估 `E`。 如果此評估導致例外狀況，則不會執行任何進一步的步驟。
   * 如果 `E` 未分類為變數，則會建立 `E`類型的暫存區域變數，並將 `E` 的值指派給該變數。 `E` 接著會重新分類為該暫存區域變數的參考。 暫存變數可在 `M`內以 `this` 的方式來存取，但不能以任何其他方法來存取。 因此，只有當 `E` 是真正的變數時，呼叫端才能夠觀察 `M` 對 `this`進行的變更。
   * 引數清單會依照[引數](expressions.md#argument-lists)清單中的說明進行評估。
   * 叫用 `M`。 `E` 所參考的變數會成為 `this`所參考的變數。

*  如果 `M` 是在*reference_type*中宣告的實例函式成員：
   * 評估 `E`。 如果此評估導致例外狀況，則不會執行任何進一步的步驟。
   * 引數清單會依照[引數](expressions.md#argument-lists)清單中的說明進行評估。
   * 如果 `E` 的類型是*value_type*，則會執行「裝箱轉換」（「[裝箱轉換](types.md#boxing-conversions)」）來將 `E` 轉換為類型 `object`，而 `E` 會被視為在下列步驟中 `object` 的類型。 在此情況下，`M` 只能是 `System.Object`的成員。
   * 已檢查 `E` 的值為有效。 如果 `E` 的值為 `null`，則會擲回 `System.NullReferenceException`，而且不會執行任何進一步的步驟。
   * 會決定要叫用的函式成員實作為：
     * 如果 `E` 的系結時間類型是介面，則叫用的函式成員就是由 `E`所參考之實例的執行時間類型所提供的 `M` 的執行。 這個函式成員的決定方式是套用介面對應規則（[介面對應](interfaces.md#interface-mapping)），以判斷 `E`所參考之實例的執行時間類型所提供的 `M` 的執行。
     * 否則，如果 `M` 是虛擬函式成員，則叫用的函式成員就是由 `E`所參考之實例的執行時間類型所提供的 `M` 的執行。 這個函式成員的決定方式，是套用用來判斷 `M` 之最衍生的實（[虛擬方法](classes.md#virtual-methods)）的規則（相對於 `E`所參考之實例的執行時間型別）。
     * 否則，`M` 為非虛擬函式成員，而要叫用的函式成員則 `M` 本身。
   * 叫用上述步驟中判斷的函式成員實作為。 `E` 所參考的物件會成為 `this`所參考的物件。

#### <a name="invocations-on-boxed-instances"></a>在已裝箱實例上的調用

在下列情況中，可以透過*value_type*的盒裝實例來叫用在*value_type*中實作用的函式成員：

*  當函式成員是繼承自類型 `object` 之方法的 `override`，而且會透過類型 `object`的實例運算式來叫用。
*  當函式成員是介面函數成員的執行，而且是透過*interface_type*的實例運算式來叫用時。
*  當函式成員透過委派叫用時。

在這些情況下，會將盒裝實例視為包含*value_type*的變數，而這個變數會變成函式成員調用內 `this` 所參考的變數。 特別是，這表示當函式成員在已裝箱的實例上叫用時，函式成員可能會修改包含在已加入盒裝實例中的值。

## <a name="primary-expressions"></a>主要運算式

主要運算式包含最簡單的運算式形式。

```antlr
primary_expression
    : primary_no_array_creation_expression
    | array_creation_expression
    ;

primary_no_array_creation_expression
    : literal
    | interpolated_string_expression
    | simple_name
    | parenthesized_expression
    | member_access
    | invocation_expression
    | element_access
    | this_access
    | base_access
    | post_increment_expression
    | post_decrement_expression
    | object_creation_expression
    | delegate_creation_expression
    | anonymous_object_creation_expression
    | typeof_expression
    | checked_expression
    | unchecked_expression
    | default_value_expression
    | nameof_expression
    | anonymous_method_expression
    | primary_no_array_creation_expression_unsafe
    ;
```

主要運算式會分割*array_creation_expression*s 與*primary_no_array_creation_expression*s 之間。 以這種方式來處理陣列建立運算式，而不是將它與其他簡單的運算式形式一起列出，而是讓文法不允許可能令人混淆的程式碼，例如
```csharp
object o = new int[3][1];
```
否則會解讀為
```csharp
object o = (new int[3])[1];
```

### <a name="literals"></a>常值

由*常*值（[常](lexical-structure.md#literals)值）組成的*primary_expression*會分類為值。


### <a name="interpolated-strings"></a>插入字串

*Interpolated_string_expression*包含 `$` 符號，後面接著一般或逐字字串常值，其中的洞會以 `{` 和 `}`分隔，並括住運算式和格式設定規格。 內插字串運算式是指已細分為個別 token 的*interpolated_string_literal*結果，如插入[字串常](lexical-structure.md#interpolated-string-literals)值中所述。

```antlr
interpolated_string_expression
    : '$' interpolated_regular_string
    | '$' interpolated_verbatim_string
    ;

interpolated_regular_string
    : interpolated_regular_string_whole
    | interpolated_regular_string_start interpolated_regular_string_body interpolated_regular_string_end
    ;

interpolated_regular_string_body
    : interpolation (interpolated_regular_string_mid interpolation)*
    ;

interpolation
    : expression
    | expression ',' constant_expression
    ;

interpolated_verbatim_string
    : interpolated_verbatim_string_whole
    | interpolated_verbatim_string_start interpolated_verbatim_string_body interpolated_verbatim_string_end
    ;

interpolated_verbatim_string_body
    : interpolation (interpolated_verbatim_string_mid interpolation)+
    ;
```

插補中的*constant_expression*必須隱含轉換成 `int`。

*Interpolated_string_expression*會分類為值。 如果它會立即轉換成 `System.IFormattable` 或具有隱含插入字串轉換的 `System.FormattableString` （[隱含插入字串轉換](conversions.md#implicit-interpolated-string-conversions)），則字串插值運算式就會有該類型。 否則，它的類型 `string`。

如果字串插值的類型是 `System.IFormattable` 或 `System.FormattableString`，則其意義就是對 `System.Runtime.CompilerServices.FormattableStringFactory.Create`的呼叫。 如果類型是 `string`，則運算式的意義就是呼叫 `string.Format`。 在這兩種情況下，呼叫的引數清單都包含一個格式字串常值，其中包含每個插補的預留位置，以及對應至預留位置之每個運算式的引數。

格式字串常值的結構如下所示，其中 `N` 是*interpolated_string_expression*中的插補數目：

*  如果*interpolated_regular_string_whole*或*interpolated_verbatim_string_whole*遵循 `$` 正負號，則格式字串常值就是該 token。
*  否則，格式字串常值包含： 
   *  首先*interpolated_regular_string_start*或*interpolated_verbatim_string_start*
   *  然後，將每個數位從 `0` `I` 到 `N-1`： 
      * `I` 的十進位標記法
      * 然後，如果對應的*插補*具有*constant_expression*，`,` （逗號），後面接著其值的十進位標記法*constant_expression*
      * 接著， *interpolated_regular_string_mid*、 *interpolated_regular_string_end*、 *interpolated_verbatim_string_mid*或*interpolated_verbatim_string_end*緊接在對應的插補後面。

後續引數就是*插補*（如果有的話）中的*運算式*（如果有的話）。

TODO：範例。


### <a name="simple-names"></a>簡單名稱

*Simple_name*包含識別碼，並選擇性地加上類型引數清單：

```antlr
simple_name
    : identifier type_argument_list?
    ;
```

*Simple_name*的格式 `I` 或形式 `I<A1,...,Ak>`，其中 `I` 是單一識別碼，而 `<A1,...,Ak>` 是選擇性的*type_argument_list*。 若未指定*type_argument_list* ，請考慮將 `K` 為零。 *Simple_name*的評估和分類方式如下：

*  如果 `K` 為零，且*simple_name*出現在*區塊*內，而且如果*區塊*的（或封閉*區塊*的）本機變數宣告空間（宣告[）包含](basic-concepts.md#declarations)本機變數、參數或具有名稱 `I`的常數，則*simple_name*會參考該區域變數、參數或常數，並將其分類為變數或值。
*  如果 `K` 為零，且*simple_name*出現在泛型方法宣告的主體內，而且如果該宣告包含名稱為 `I`的型別參數，則*simple_name*會參考該型別參數。
*  否則，針對每個實例類型 `T` （[實例類型](classes.md#the-instance-type)），從立即封入類型宣告的實例類型開始，並繼續進行每個封入類別或結構宣告的實例類型（如果有的話）：
   *  如果 `K` 為零，且 `T` 的宣告包含名稱為 `I`的類型參數，則*simple_name*會參考該類型參數。
   *  否則，如果 `T` 中 `I` 的成員查閱（[成員查閱](expressions.md#member-lookup)）與 `K` 型別引數，則會產生符合的結果：
      * 如果 `T` 是立即封入類別或結構型別的實例型別，而且查閱識別一或多個方法，則結果會是具有 `this`之相關聯實例運算式的方法群組。 如果指定了類型引數清單，則會使用它來呼叫泛型方法（[方法調用](expressions.md#method-invocations)）。
      * 否則，如果 `T` 是立即封入類別或結構型別的實例型別，而且查閱識別出實例成員，而且如果參考發生在實例的函式、實例方法或實例存取子的主體內，則結果會與表單 `this.I`的成員存取權（[成員存取](expressions.md#member-access)）相同。 只有當 `K` 為零時，才會發生這種情況。
      * 否則，結果會與表單 `T.I` 或 `T.I<A1,...,Ak>`的成員存取權（[成員存取權](expressions.md#member-access)）相同。 在此情況下，這是*simple_name*參考實例成員的系結時錯誤。

*  否則，針對每個命名空間 `N`，從發生*simple_name*的命名空間開始，繼續進行每個封入命名空間（如果有的話），並以全域命名空間結束，直到實體找到之後，才會評估下列步驟：
   *  如果 `K` 為零，且 `I` 是 `N`中的命名空間名稱，則：
      * 如果*simple_name*發生所在的位置是以 `N` 的命名空間宣告括住，且命名空間宣告包含*extern_alias_directive*或*using_alias_directive* ，將名稱 `I` 與命名空間或類型產生關聯，則*simple_name*會不明確，且會發生編譯時期錯誤。
      * 否則， *simple_name*會參考 `N`中名為 `I` 的命名空間。
   *  否則，如果 `N` 包含名稱 `I` 的可存取型別，且 `K` 型別參數，則：
      * 如果 `K` 為零，且發生*simple_name*的位置是以 `N` 的命名空間宣告括住，且命名空間宣告包含*extern_alias_directive*或*using_alias_directive*關聯名稱 `I` 與命名空間或類型，則*simple_name*不明確，且會發生編譯時期錯誤。
      * 否則， *namespace_or_type_name*會參考以指定的型別引數所構成的型別。
   *  否則，如果發生*simple_name*的位置是以 `N`的命名空間宣告括住：
      * 如果 `K` 為零，且命名空間宣告包含*extern_alias_directive*或*using_alias_directive*將名稱 `I` 與匯入的命名空間或類型產生關聯，則*simple_name*會參考該命名空間或類型。
      * 否則，如果由*using_namespace_directive*s 與*using_static_directive*的命名空間宣告所匯入的命名空間和類型宣告，只包含一個可存取的類型或非延伸的靜態成員（名稱 `I`，而 `K` 類型參數），則*simple_name*會參考以給定類型引數所建立的類型或成員。
      * 否則，如果命名空間宣告的*using_namespace_directive*s 所匯入的命名空間和類型包含一個以上的可存取類型或非擴充方法的靜態成員名稱 `I` 並 `K` 類型參數，則*simple_name*會是不明確的，而且會發生錯誤。

   請注意，這整個步驟與處理*namespace_or_type_name* （[命名空間和型別名稱](basic-concepts.md#namespace-and-type-names)）中的對應步驟完全平行。

*  否則，不會定義*simple_name* ，而且會發生編譯時期錯誤。


### <a name="parenthesized-expressions"></a>以括弧括住的運算式

*Parenthesized_expression*包含以括弧括住的*運算式*。

```antlr
parenthesized_expression
    : '(' expression ')'
    ;
```

藉由評估括弧內的*運算式*來評估*parenthesized_expression* 。 如果括弧內的*運算式*代表命名空間或類型，則會發生編譯時期錯誤。 否則， *parenthesized_expression*的結果會是包含*運算式*的評估結果。

### <a name="member-access"></a>成員存取

*Member_access*由*primary_expression*、 *predefined_type*或*qualified_alias_member*組成，後面接著 "`.`" 權杖，後面接著一個*識別碼*，可選擇性地加上*type_argument_list*。

```antlr
member_access
    : primary_expression '.' identifier type_argument_list?
    | predefined_type '.' identifier type_argument_list?
    | qualified_alias_member '.' identifier
    ;

predefined_type
    : 'bool'   | 'byte'  | 'char'  | 'decimal' | 'double' | 'float' | 'int' | 'long'
    | 'object' | 'sbyte' | 'short' | 'string'  | 'uint'   | 'ulong' | 'ushort'
    ;
```

*Qualified_alias_member*的生產環境是在[命名空間別名限定詞](namespaces.md#namespace-alias-qualifiers)中定義。

*Member_access*的格式為 `E.I` 或表單 `E.I<A1, ..., Ak>`，其中 `E` 是主要運算式，`I` 是單一識別碼，而 `<A1, ..., Ak>` 是選擇性的*type_argument_list*。 若未指定*type_argument_list* ，請考慮將 `K` 為零。

*Primary_expression*類型為 `dynamic` 的*member_access*會動態繫結（[動態](expressions.md#dynamic-binding)系結）。 在此情況下，編譯器會將成員存取分類為 `dynamic`類型的屬性存取。 下列規則會在執行時間套用*member_access*的意義，並使用執行時間類型，而不是*primary_expression*的編譯時間類型。 如果此執行時間分類會導致方法群組，則成員存取必須是*invocation_expression*的*primary_expression* 。

*Member_access*的評估和分類方式如下：

*  如果 `K` 為零，且 `E` 是命名空間，而 `E` 包含名稱為 `I`的嵌套命名空間，則結果會是該命名空間。
*  否則，如果 `E` 是命名空間，而 `E` 包含名稱 `I` 的可存取型別，而且 `K` 型別參數，則結果會是以給定型別引數所構成的型別。
*  如果 `E` 是*predefined_type*或分類為類型的*primary_expression* ，如果 `E` 不是型別參數，而且 `I` 中 `E` 的成員查閱（[成員查閱](expressions.md#member-lookup)） `K`型別參數會產生相符項，則會評估  並分類如下：
   *  如果 `I` 識別型別，則結果會是以給定型別引數所構成的型別。
   *  如果 `I` 識別一個或多個方法，則結果會是沒有相關聯實例運算式的方法群組。 如果指定了類型引數清單，則會使用它來呼叫泛型方法（[方法調用](expressions.md#method-invocations)）。
   *  如果 `I` 識別 `static` 屬性，則結果會是沒有相關聯實例運算式的屬性存取。
   *  如果 `I` 識別 `static` 欄位：
      * 如果欄位是 `readonly` 且參考發生在宣告欄位之類別或結構的靜態函式外，則結果會是值，也就是 `E`中靜態欄位 `I` 的值。
      * 否則，結果會是變數，也就是 `E`中 `I` 的靜態欄位。
   *  如果 `I` 識別 `static` 事件：
      * 如果參考發生在宣告事件的類別或結構中，而事件是在沒有*event_accessor_declarations* （[事件](classes.md#events)）的情況下宣告，則 `E.I` 的處理方式完全如同 `I` 是靜態欄位一樣。
      * 否則，結果會是沒有相關聯實例運算式的事件存取。
   *  如果 `I` 識別常數，則結果會是值，也就是該常數的值。
    * 如果 `I` 識別列舉成員，則結果會是值，也就是該列舉成員的值。
    * 否則，`E.I` 是不正確成員參考，而且發生編譯時期錯誤。
*  如果 `E` 是屬性存取、索引子存取、變數或值、 `T`的類型，以及 `K` 類型引數的 `T` 中的成員查閱（[成員查閱](expressions.md#member-lookup)`I`）會產生相符項，則會評估 `E.I` 並將其分類如下：
   *  首先，如果 `E` 是屬性或索引子存取，則會取得屬性或索引子存取的值（[運算式的值](expressions.md#values-of-expressions)），並將 `E` 重新分類為值。
   *  如果 `I` 識別一個或多個方法，則結果會是具有 `E`之相關聯實例運算式的方法群組。 如果指定了類型引數清單，則會使用它來呼叫泛型方法（[方法調用](expressions.md#method-invocations)）。
   *  如果 `I` 識別實例屬性，則為，
      * 如果 `E` 是 `this`，`I` 會識別不含 setter 的自動執行屬性（[自動實作為屬性](classes.md#automatically-implemented-properties)），而參考會在類別或結構類型 `T`的實常式序中發生; 然後，結果會是一個變數，也就是由 `I` 所指定的 `T` 實例中，由 `this`所指定之 auto 屬性的隱藏支援欄位。
      * 否則，結果會是具有 `E`之相關聯實例運算式的屬性存取。
   *  如果 `T` 是*class_type* ，而 `I` 識別該*class_type*的實例欄位：
      * 如果 `E` 的值為 `null`，則會擲回 `System.NullReferenceException`。
      * 否則，如果欄位是 `readonly`，而參考發生在宣告欄位之類別的實例（instance）（class）的方法之外，則結果會是值，也就是 `E`所參考物件中的欄位 `I` 值。
      * 否則，結果會是一個變數，也就是 `E`所參考物件中 `I` 欄位。
   *  如果 `T` 是*struct_type* ，而 `I` 識別該*struct_type*的實例欄位：
      * 如果 `E` 是值，或如果 `readonly` 欄位，而參考出現在宣告該欄位之結構的實例函式外部，則結果會是值，也就是在 `E`所指定的結構實例中，欄位 `I` 的值。
      * 否則，結果會是一個變數，也就是在 `E`所指定的結構實例中 `I` 的欄位。
   *  如果 `I` 識別實例事件：
      * 如果參考發生在宣告事件的類別或結構中，而事件是在沒有*event_accessor_declarations* （[事件](classes.md#events)）的情況下宣告，而且參考不會做為 `+=` 或 `-=` 運算子的左邊，則 `E.I` 的處理方式就如同 `I` 為實例欄位一樣。
      * 否則，結果會是具有 `E`之相關聯實例運算式的事件存取。
*  否則，會嘗試處理 `E.I` 做為擴充方法調用（[擴充方法](expressions.md#extension-method-invocations)調用）。 如果失敗，`E.I` 是不正確成員參考，而且發生系結時錯誤。

#### <a name="identical-simple-names-and-type-names"></a>相同的簡單名稱和類型名稱

在表單 `E.I`的成員存取中，如果 `E` 是單一識別碼，而且如果 `E` 的意義是*simple_name* （[簡單名稱](expressions.md#simple-names)）是常數、欄位、屬性、區域變數或參數，且其類型與 `E` 做為*type_name* （[命名空間和類型名稱](basic-concepts.md#namespace-and-type-names)）的意義相同，則允許 `E` 的兩種可能意義。 `E.I` 的兩個可能意義永遠不明確，因為 `I` 必須是這兩種情況下 `E` 類型的成員。 換句話說，規則只允許存取靜態成員和巢狀型別的 `E`，否則會發生編譯時期錯誤。 例如：
```csharp
struct Color
{
    public static readonly Color White = new Color(...);
    public static readonly Color Black = new Color(...);

    public Color Complement() {...}
}

class A
{
    public Color Color;                // Field Color of type Color

    void F() {
        Color = Color.Black;           // References Color.Black static member
        Color = Color.Complement();    // Invokes Complement() on Color field
    }

    static void G() {
        Color c = Color.White;         // References Color.White static member
    }
}
```

#### <a name="grammar-ambiguities"></a>文法多義性

*Simple_name* （[簡單名稱](expressions.md#simple-names)）和*member_access* （[成員存取](expressions.md#member-access)）的生產可能會增加運算式文法中的多義性。 例如，語句：
```csharp
F(G<A,B>(7));
```
可以使用兩個引數（`G < A` 和 `B > (7)`）來解讀為 `F` 的呼叫。 或者，也可以使用一個引數來解讀 `F` 的呼叫，這是使用兩個型別引數和一個一般引數呼叫泛型方法 `G`。

如果可以將一系列的 token 剖析（在內容中）為*simple_name* （[簡單名稱](expressions.md#simple-names)）、 *member_access* （[成員存取](expressions.md#member-access)），或*pointer_member_access* （[指標成員存取](unsafe-code.md#pointer-member-access)）以*type_argument_list* （型別[引數](types.md#type-arguments)）結束，則會檢查緊接在結尾 `>` token 後面的權杖。 如果它是下列其中一個
```csharp
(  )  ]  }  :  ;  ,  .  ?  ==  !=  |  ^
```
然後， *type_argument_list*會保留為*simple_name*、 *member_access*或*pointer_member_access*的一部分，而且會捨棄權杖順序的任何其他可能剖析。 否則，即使沒有其他可能的 token 序列剖析，也不會將*type_argument_list*視為*simple_name*、 *member_access*或*pointer_member_access*的一部分。 請注意，剖析*namespace_or_type_name*中的*type_argument_list* （[命名空間和型別名稱](basic-concepts.md#namespace-and-type-names)）時，不會套用這些規則。 陳述式
```csharp
F(G<A,B>(7));
```
根據這項規則，會以一個引數來解讀 `F` 的呼叫，這是使用兩個型別引數和一個一般引數呼叫泛型方法 `G`。 語句
```csharp
F(G < A, B > 7);
F(G < A, B >> 7);
```
每個都會以兩個引數來解讀 `F` 的呼叫。 陳述式
```csharp
x = F < A > +y;
```
將會解讀為小於運算子、大於運算子和一元加號運算子，如同已 `x = (F < A) > (+y)`寫入語句，而不是*type_argument_list*後面接著二元加號運算子的*simple_name* 。 在語句中
```csharp
x = y is C<T> + z;
```
`C<T>` 的權杖會以*type_argument_list*的*namespace_or_type_name*來解讀。

### <a name="invocation-expressions"></a>叫用運算式

*Invocation_expression*用來叫用方法。

```antlr
invocation_expression
    : primary_expression '(' argument_list? ')'
    ;
```

如果至少有下列其中一個保留，則*invocation_expression*會動態繫結（[動態](expressions.md#dynamic-binding)系結）：

* *Primary_expression*具有編譯時間類型 `dynamic`。
* 選擇性*argument_list*的至少一個引數具有編譯時間類型 `dynamic` 而且*primary_expression*沒有委派類型。

在此情況下，編譯器會將*invocation_expression*分類為 `dynamic`類型的值。 下列規則會在執行時間套用*invocation_expression*的意義，並使用執行時間型別，而不是*primary_expression*和引數的編譯時間型別，這些都是編譯時間類型 `dynamic`。 如果*primary_expression*沒有 `dynamic`的編譯時間類型，則方法調用會經歷有限的編譯時間檢查，如動態多載[解析的編譯階段檢查](expressions.md#compile-time-checking-of-dynamic-overload-resolution)中所述。

*Invocation_expression*的*primary_expression*必須是方法群組或*delegate_type*的值。 如果*primary_expression*是方法群組，則*invocation_expression*是方法調用（[方法調用](expressions.md#method-invocations)）。 如果*primary_expression*是*delegate_type*的值，則*Invocation_expression*是委派調用（[委派調用](expressions.md#delegate-invocations)）。 如果*primary_expression*不是方法群組，也不是*delegate_type*的值，則會發生系結時錯誤。

選擇性的*argument_list* （[引數清單](expressions.md#argument-lists)）提供方法之參數的值或變數參考。

評估*invocation_expression*的結果分類如下：

*  如果*invocation_expression*叫用傳回 `void`的方法或委派，則結果為「無」。 只有在*statement_expression* （[運算式語句](statements.md#expression-statements)）或*lambda_expression* （匿名函式[運算式](expressions.md#anonymous-function-expressions)）的內容中，才允許分類為任何內容的運算式。 否則會發生系結時錯誤。
*  否則，結果會是方法或委派所傳回之類型的值。

#### <a name="method-invocations"></a>方法調用

若為方法調用， *invocation_expression*的*primary_expression*必須是方法群組。 方法群組會識別要叫用的一個方法，或用來選擇要叫用之特定方法的多載方法集合。 在後者的情況下，判斷要叫用的特定方法是根據*argument_list*中引數類型所提供的內容。

`M(A)`形式之方法調用的系結時間處理，其中 `M` 是方法群組（可能包括*type_argument_list*），而 `A` 是選擇性的*argument_list*，其中包含下列步驟：

*  方法調用的一組候選方法會被結構化。 針對與方法群組相關聯的每個方法 `F` `M`：
   *  如果 `F` 不是泛型，則在下列情況中，`F` 是候選項：
      * `M` 沒有類型引數清單，且
      * `F` 適用于 `A` （適用的函式[成員](expressions.md#applicable-function-member)）。
   *  如果 `F` 是泛型，而且 `M` 沒有類型引數清單，則 `F` 在下列情況下是候選項：
      * 型別推斷（[型別推斷](expressions.md#type-inference)）成功、推斷呼叫的型別引數清單，以及
      * 一旦推斷的型別引數取代為對應的方法型別參數，F 的參數清單中的所有結構化類型都滿足其條件約束（[滿足條件約束](types.md#satisfying-constraints)），而 `F` 的參數清單則適用于 `A` （適用的函式[成員](expressions.md#applicable-function-member)）。
   *  如果 `F` 是泛型，而 `M` 包含型別引數清單，則 `F` 在下列情況下是候選項：
      * `F` 具有與類型引數清單中所提供相同的方法類型參數數目，而
      * 一旦類型引數取代為對應的方法類型參數，F 的參數清單中的所有結構化類型都滿足其條件約束（[滿足條件約束](types.md#satisfying-constraints)），而 `F` 的參數清單則適用于 `A` （[適用](expressions.md#applicable-function-member)的函式成員）。
*  候選方法集合會縮小為僅包含來自最多衍生類型的方法：針對集合中 `C.F` 的每個方法，其中 `C` 是宣告方法 `F` 的類型，則會從集合中移除 `C` 的基底類型中宣告的所有方法。 此外，如果 `C` 是 `object`以外的類別類型，則在介面類別型中宣告的所有方法都會從集合中移除。 （第二個規則只有在方法群組是在具有 object 以外的有效基類和非空白的有效介面集的類型參數上進行成員查詢的結果時才會影響）。
*  如果產生的候選方法集合是空的，則會放棄沿著下列步驟進行的進一步處理，並改為嘗試將調用當做擴充方法調用（[擴充方法](expressions.md#extension-method-invocations)調用）來處理。 如果失敗，則不存在任何適用的方法，而且會發生系結時錯誤。
*  候選方法集合的最佳方法是使用多載[解析](expressions.md#overload-resolution)的多載解析規則來識別。 如果無法識別單一最佳方法，則方法調用不明確，且會發生系結時錯誤。 執行多載解析時，泛型方法的參數會在取代對應方法類型參數的類型引數（提供或推斷）之後考慮。
*  會執行所選最佳方法的最終驗證：
   * 方法會在方法群組的內容中進行驗證：如果最佳方法是靜態方法，則方法群組必須從*simple_name*或透過類型的*member_access*產生。 如果最佳方法是實例方法，則方法群組必須從*simple_name*、透過變數或值的*member_access* ，或*base_access*產生。 如果這兩項需求都不成立，就會發生系結時錯誤。
   * 如果最佳方法是泛型方法，則會根據泛型方法上所宣告的條件約束（[滿足條件約束](types.md#satisfying-constraints)）來檢查類型引數（提供或推斷）。 如果任何類型引數不符合類型參數上的對應條件約束，就會發生系結時錯誤。

當方法在系結時間由上述步驟選取並驗證之後，就會根據動態多載[解析的編譯時間檢查](expressions.md#compile-time-checking-of-dynamic-overload-resolution)中所述的函式成員調用規則來處理實際的執行時間調用。

上述解析規則的直覺效果如下所示：若要找出方法調用所叫用的特定方法，請從方法調用所指示的類型開始，然後繼續繼承鏈，直到至少有一個適用的為止。找到可存取的非覆寫方法宣告。 然後在該類型中宣告的適用、可存取、非覆寫方法集合上執行類型推斷和多載解析，並藉由選取來叫用方法。 如果找不到任何方法，請改為嘗試將調用當做擴充方法叫用來處理。

#### <a name="extension-method-invocations"></a>擴充方法調用

在方法調用中（在[盒裝實例上的調用](expressions.md#invocations-on-boxed-instances)），其中一個形式
```csharp
expr . identifier ( )

expr . identifier ( args )

expr . identifier < typeargs > ( )

expr . identifier < typeargs > ( args )
```
如果調用的正常處理找不到適用的方法，就會嘗試將此結構當做擴充方法調用來處理。 如果*expr*或任何引數*具有編譯*時間類型 `dynamic`，則不會套用擴充方法。

目標是尋找最佳的*type_name* `C`，以便進行對應的靜態方法調用：
```csharp
C . identifier ( expr )

C . identifier ( expr , args )

C . identifier < typeargs > ( expr )

C . identifier < typeargs > ( expr , args )
```

`Ci.Mj` 的擴充方法***符合下列條件***：

*  `Ci` 是非泛型、非嵌套的類別
*  `Mj` 的名稱是*identifier*
*  套用至引數當做靜態方法（如上所示）時，可以存取並適用 `Mj`
*  從*expr*到 `Mj`的第一個參數型別都有隱含的識別、參考或裝箱轉換。

搜尋 `C` 會如下所示：

*  從最接近的封入命名空間宣告開始，繼續進行每個封入的命名空間宣告，並以包含的編譯單位結束，後續嘗試會尋找一組候選的延伸方法：
   * 如果指定的命名空間或編譯單位直接包含 `Ci` 具有合格擴充方法 `Mj`的非泛型型別宣告，則這些擴充方法的集合會是候選集合。
   * 如果類型 `Ci` 由*using_static_declarations*匯入，而且在指定的命名空間或編譯 `Mj`單位中由*using_namespace_directive*s 所匯入的命名空間中直接宣告，則這些擴充方法的集合會是候選集合。
*  如果在任何封閉式命名空間宣告或編譯單位中找不到候選集合，則會發生編譯時期錯誤。
*  否則，多載解析會套用至候選集合，如（多載[解析](expressions.md#overload-resolution)）中所述。 如果找不到單一的最佳方法，就會發生編譯時期錯誤。
*  `C` 是將最佳方法宣告為擴充方法的類型。

使用 `C` 做為目標時，方法呼叫接著會當做靜態方法調用（動態多載[解析的編譯時間檢查](expressions.md#compile-time-checking-of-dynamic-overload-resolution)）來處理。

上述規則表示實例方法的優先順序高於擴充方法，內部命名空間宣告中提供的擴充方法優先順序高於外部命名空間宣告中提供的擴充方法，以及該延伸模組直接在命名空間中宣告的方法，其優先順序高於使用 namespace 指示詞彙入到同一個命名空間中的擴充方法。 例如：
```csharp
public static class E
{
    public static void F(this object obj, int i) { }

    public static void F(this object obj, string s) { }
}

class A { }

class B
{
    public void F(int i) { }
}

class C
{
    public void F(object obj) { }
}

class X
{
    static void Test(A a, B b, C c) {
        a.F(1);              // E.F(object, int)
        a.F("hello");        // E.F(object, string)

        b.F(1);              // B.F(int)
        b.F("hello");        // E.F(object, string)

        c.F(1);              // C.F(object)
        c.F("hello");        // C.F(object)
    }
}
```

在範例中，`B`的方法優先于第一個擴充方法，而 `C`的方法優先于這兩個擴充方法。

```csharp
public static class C
{
    public static void F(this int i) { Console.WriteLine("C.F({0})", i); }
    public static void G(this int i) { Console.WriteLine("C.G({0})", i); }
    public static void H(this int i) { Console.WriteLine("C.H({0})", i); }
}

namespace N1
{
    public static class D
    {
        public static void F(this int i) { Console.WriteLine("D.F({0})", i); }
        public static void G(this int i) { Console.WriteLine("D.G({0})", i); }
    }
}

namespace N2
{
    using N1;

    public static class E
    {
        public static void F(this int i) { Console.WriteLine("E.F({0})", i); }
    }

    class Test
    {
        static void Main(string[] args)
        {
            1.F();
            2.G();
            3.H();
        }
    }
}
```

此範例的輸出為：
```console
E.F(1)
D.G(2)
C.H(3)
```
`D.G` 優先于 `C.G`，`E.F` 優先于 `D.F` 和 `C.F`。

#### <a name="delegate-invocations"></a>委派調用

若為委派調用， *invocation_expression*的*primary_expression*必須是*delegate_type*的值。 此外，將*delegate_type*視為具有與*delegate_type*相同之參數清單的函式成員， *delegate_type*必須是適用于*invocation_expression* *argument_list*的相關（適用函式[成員](expressions.md#applicable-function-member)）。

`D(A)`形式的委派調用的執行時間處理，其中 `D` 是*delegate_type*的*primary_expression* ，而 `A` 是選擇性的*argument_list*，其中包含下列步驟：

*  評估 `D`。 如果此評估導致例外狀況，則不會執行任何進一步的步驟。
*  已檢查 `D` 的值為有效。 如果 `D` 的值為 `null`，則會擲回 `System.NullReferenceException`，而且不會執行任何進一步的步驟。
*  否則，`D` 是委派實例的參考。 函式成員調用（動態多載[解析的編譯階段檢查](expressions.md#compile-time-checking-of-dynamic-overload-resolution)）會在委派的調用清單中的每個可呼叫實體上執行。 對於由實例和實例方法所組成的可呼叫實體，調用的實例是包含在可呼叫實體中的實例。

### <a name="element-access"></a>元素存取

*Element_access*由*primary_no_array_creation_expression*組成，後面接著 "`[`" token，後面接著*argument_list*，後面接著 "`]`" 權杖。 *Argument_list*由一個或多個*引數*s 組成，並以逗號分隔。

```antlr
element_access
    : primary_no_array_creation_expression '[' expression_list ']'
    ;
```

*Element_access*的*argument_list*不能包含 `ref` 或 `out` 引數。

如果至少有下列其中一個保留，則*element_access*會動態繫結（[動態](expressions.md#dynamic-binding)系結）：

* *Primary_no_array_creation_expression*具有編譯時間類型 `dynamic`。
* *Argument_list*的至少一個運算式具有編譯時間型別 `dynamic`，而*primary_no_array_creation_expression*沒有陣列型別。

在此情況下，編譯器會將*element_access*分類為 `dynamic`類型的值。 下列規則會在執行時間套用*element_access*的意義，並使用執行時間類型，而不是*primary_no_array_creation_expression*的編譯時間類型，以及具有編譯時間類型 `dynamic`的*argument_list*運算式。 如果*primary_no_array_creation_expression*沒有 `dynamic`的編譯時間類型，則專案存取會進行有限的編譯時間檢查，如動態多載[解析的編譯階段檢查](expressions.md#compile-time-checking-of-dynamic-overload-resolution)中所述。

如果*element_access*的*primary_no_array_creation_expression*是*array_type*的值，則*element_access*是陣列存取（[陣列存取](expressions.md#array-access)）。 否則， *primary_no_array_creation_expression*必須是具有一或多個索引子成員之類別、結構或介面類別型的變數或值，在此情況下， *element_access*是索引子存取（[索引子存取](expressions.md#indexer-access)）。

#### <a name="array-access"></a>陣列存取

針對陣列存取， *element_access*的*primary_no_array_creation_expression*必須是*array_type*的值。 此外，陣列存取的*argument_list*不允許包含具名引數。*Argument_list*中的運算式數目必須與*array_type*的次序相同，而且每個運算式都必須是類型 `int`、`uint`、`long`、`ulong`，或必須隱含地轉換成其中一或多個類型。

評估陣列存取的結果是陣列之元素類型的變數，也就是由*argument_list*中運算式的值所選取的陣列元素。

`P[A]`格式之陣列存取的執行時間處理，其中 `P` 是*array_type*的*primary_no_array_creation_expression* ，而 `A` 是一個*argument_list*，其中包含下列步驟：

*  評估 `P`。 如果此評估導致例外狀況，則不會執行任何進一步的步驟。
*  *Argument_list*的索引運算式會依照順序（由左至右）進行評估。 遵循每個索引運算式的評估，會執行隱含轉換（[隱含](conversions.md#implicit-conversions)轉換）為下列其中一種類型： `int`、`uint`、`long`、`ulong`。 選擇此清單中的第一個類型，其隱含轉換存在。 例如，如果索引運算式的類型是 `short` 則會執行隱含轉換成 `int`，因為從 `short` 隱含轉換到 `int`，以及從 `short` 到 `long` 都是可行的。 如果索引運算式的評估或後續的隱含轉換造成例外狀況，則不會評估進一步的索引運算式，也不會執行任何進一步的步驟。
*  已檢查 `P` 的值為有效。 如果 `P` 的值為 `null`，則會擲回 `System.NullReferenceException`，而且不會執行任何進一步的步驟。
*  *Argument_list*中每個運算式的值都會針對 `P`所參考陣列實例的每個維度的實際界限進行檢查。 如果一個或多個值超出範圍，則會擲回 `System.IndexOutOfRangeException`，且不會執行任何進一步的步驟。
*  索引運算式所指定之陣列元素的位置會計算出來，而此位置會成為陣列存取的結果。

#### <a name="indexer-access"></a>索引子存取

針對索引子存取， *element_access*的*primary_no_array_creation_expression*必須是類別、結構或介面類別型的變數或值，而且此類型必須執行一或多個適用于*element_access* *argument_list*的索引子。

`P[A]`形式的索引子存取的系結時間處理，其中 `P` 是類別、結構或介面類別型 `T`的*primary_no_array_creation_expression* ，而 `A` 是*argument_list*，其中包含下列步驟：

*  `T` 所提供的索引子集合。 此集合包含 `T` 中宣告的所有索引子，或不是 `override` 宣告的 `T` 基底類型，而且可在目前的內容中存取（[成員存取](basic-concepts.md#member-access)）。
*  此集合會縮減為適用且不會被其他索引子隱藏的索引子。 下列規則會套用至集合中的每個索引子 `S.I`，其中 `S` 是用來宣告索引子 `I` 的類型：
   * 如果 `I` 不適用於 `A` （適用的函式[成員](expressions.md#applicable-function-member)），則 `I` 會從集合中移除。
   * 如果 `I` 適用于 `A` （適用的函式[成員](expressions.md#applicable-function-member)），則會從集合中移除 `S` 基底類型中宣告的所有索引子。
   * 如果 `I` 適用于 `A` （適用的函式[成員](expressions.md#applicable-function-member)），而 `S` 是 `object`以外的類別類型，則會從集合中移除在介面中宣告的所有索引子。
*  如果候選索引子的結果集是空的，則不會有適用的索引子存在，而且會發生系結時錯誤。
*  候選索引子集合的最佳索引子是使用多載[解析](expressions.md#overload-resolution)的多載解析規則來識別。 如果無法識別單一的最佳索引子，則索引子存取是不明確的，而且會發生系結時錯誤。
*  *Argument_list*的索引運算式會依照順序（由左至右）進行評估。 處理索引子存取的結果是分類為索引子存取的運算式。 索引子存取運算式會參考上述步驟中判斷的索引子，並具有 `P` 的相關聯實例運算式，以及 `A`的相關聯引數清單。

視使用的內容而定，索引子存取會導致*get 存取*子或索引子的*set 存取*子的調用。 如果索引子存取是指派的目標，則會叫用*set 存取*子來指派新的值（[簡單指派](expressions.md#simple-assignment)）。 在所有其他情況下，會叫用*get 存取*子來取得目前的值（[運算式的值](expressions.md#values-of-expressions)）。

### <a name="this-access"></a>此存取權

*This_access*包含保留字 `this`。

```antlr
this_access
    : 'this'
    ;
```

只有在實例的的*區塊*、實例方法或實例存取子中，才允許*this_access* 。 它具有下列其中一種意義：

*  當 `this` 用於類別之實例函式內的*primary_expression*時，它會分類為值。 值的類型是發生使用之類別的實例類型（[實例類型](classes.md#the-instance-type)），而值則是所要建立之物件的參考。
*  當 `this` 用於類別的實例方法或實例存取子中的*primary_expression*時，它會分類為值。 值的類型是發生使用之類別的實例類型（[實例類型](classes.md#the-instance-type)），而值則是對其叫用方法或存取子之物件的參考。
*  當 `this` 用於結構之實例函式內的*primary_expression*時，它會分類為變數。 變數的類型是發生使用之結構的實例類型（[實例類型](classes.md#the-instance-type)），而變數則代表所要建立的結構。 結構之實例函式的 `this` 變數的行為與結構類型的 `out` 參數完全相同，特別是這表示變數必須在實例的每個執行路徑中明確指派。
*  當 `this` 用於結構之實例方法或實例存取子中的*primary_expression*時，它會分類為變數。 變數的類型是發生使用之結構的實例類型（[實例類型](classes.md#the-instance-type)）。
   * 如果方法或存取子不是反覆運算[器（iterator](classes.md#iterators)），則 `this` 變數代表已叫用方法或存取子的結構，且其行為與結構類型的 `ref` 參數完全相同。
   * 如果方法或存取子是反覆運算器，則 `this` 變數代表已叫用方法或存取子的結構複本，其行為與結構類型的值參數完全相同。

在先前所列內容以外的*primary_expression*中使用 `this`，是編譯時期錯誤。 特別的是，您無法在靜態方法、靜態屬性存取子或欄位宣告的*variable_initializer*中參考 `this`。

### <a name="base-access"></a>基底存取

*Base_access*包含保留字 `base` 後面接著「`.`」標記和識別碼，或是以方括弧括住的*argument_list* ：

```antlr
base_access
    : 'base' '.' identifier
    | 'base' '[' expression_list ']'
    ;
```

*Base_access*可用來存取在目前類別或結構中以類似方式命名的成員所隱藏的基類成員。 只有在實例的的*區塊*、實例方法或實例存取子中，才允許*base_access* 。 當 `base.I` 發生在類別或結構中時，`I` 必須代表該類別或結構之基類的成員。 同樣地，當 `base[E]` 發生在類別中時，適用的索引子必須存在於基類中。

在系結時期，`base.I` 和 `base[E]` 形式的*base_access*運算式會以 `((B)this).I` 和 `((B)this)[E]`的撰寫方式來進行評估，其中 `B` 是在其中進行結構的類別或結構的基類（base class）。 因此，`base.I` 和 `base[E]` 對應至 `this.I` 和 `this[E]`，但 `this` 會視為基類的實例。

當*base_access*參考虛擬函式成員（方法、屬性或索引子）時，會在執行時間（動態多載[解析的編譯階段檢查](expressions.md#compile-time-checking-of-dynamic-overload-resolution)）上判斷要叫用的函式成員已變更。 所叫用的函式成員是藉由尋找與 `B` 相關之函式成員的最衍生實（[虛擬方法](classes.md#virtual-methods)）來決定（而不是針對 `this`的執行時間型別，如同平常在非基底存取中一般）。 因此，在 `virtual` 函式成員的 `override` 中， *base_access*可以用來叫用函式成員的繼承實作用。 如果*base_access*所參考的函式成員是抽象的，則會發生系結時錯誤。

### <a name="postfix-increment-and-decrement-operators"></a>後置遞增和遞減運算子

```antlr
post_increment_expression
    : primary_expression '++'
    ;

post_decrement_expression
    : primary_expression '--'
    ;
```

後置遞增或遞減運算的運算元必須是分類為變數、屬性存取或索引子存取的運算式。 運算的結果是與運算元相同類型的值。

如果*primary_expression*具有編譯時期類型 `dynamic` 則運算子會動態系結（[動態](expressions.md#dynamic-binding)系結）、 *post_increment_expression*或*post_decrement_expression*具有編譯時間類型 `dynamic`，而且下列規則會在執行時間使用*primary_expression*的執行時間類型來套用。

如果後置遞增或遞減運算的運算元是屬性或索引子存取，則屬性或索引子必須同時具有 `get` 和 `set` 存取子。 如果不是這種情況，就會發生系結時錯誤。

一元運算子多載解析（[一元運算子](expressions.md#unary-operator-overload-resolution)多載解析）適用于選取特定的運算子執行。 預先定義的 `++` 和 `--` 運算子存在於下列類型： `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`char`、`float`、`double`、`decimal`和任何列舉類型。 預先定義的 `++` 運算子會傳回將1加入運算元所產生的值，而預先定義的 `--` 運算子則會傳回從運算元減去1所產生的值。 在 `checked` 內容中，如果此加法或減法的結果超出結果型別的範圍，且結果型別為整數型別或列舉型別，則會擲回 `System.OverflowException`。

`x++` 或 `x--` 格式的後置遞增或遞減運算的執行時間處理包含下列步驟：

*   如果 `x` 分類為變數：
    * 評估 `x` 以產生變數。
    * 會儲存 `x` 的值。
    * 會叫用選取的運算子，並將 `x` 的儲存值當做其引數。
    * 運算子所傳回的值會儲存在評估 `x`所指定的位置。
    * 儲存的 `x` 值會變成作業的結果。
*   如果 `x` 分類為屬性或索引子存取：
    * 實例運算式（如果 `x` 不是 `static`），而且會評估與 `x` 相關聯的引數清單（如果 `x` 是索引子存取），而結果會用於後續的 `get` 和 `set` 存取子調用。
    * 會叫用 `x` 的 `get` 存取子，並儲存傳回的值。
    * 會叫用選取的運算子，並將 `x` 的儲存值當做其引數。
    * `x` 的 `set` 存取子會以運算子所傳回的值做為其 `value` 引數來叫用。
    * 儲存的 `x` 值會變成作業的結果。

`++` 和 `--` 運算子也支援前置詞標記法（[前置遞增和遞減運算子](expressions.md#prefix-increment-and-decrement-operators)）。 一般來說，`x++` 或 `x--` 的結果是作業之前 `x` 的值，而 `++x` 或 `--x` 的結果是作業之後 `x` 的值。 不論是哪一種情況，在作業之後，`x` 本身都具有相同的值。

您可以使用後置或首碼標記法來叫用 `operator ++` 或 `operator --` 的實作為方法。 這兩種標記法不可能有個別的運算子實現。

### <a name="the-new-operator"></a>new 運算子

`new` 運算子是用來建立類型的新實例。

有三種形式的 `new` 運算式：

*  物件建立運算式是用來建立類別類型和實數值型別的新實例。
*  陣列建立運算式是用來建立陣列類型的新實例。
*  委派建立運算式是用來建立委派類型的新實例。

`new` 運算子意指建立類型的實例，但不一定會隱含記憶體的動態配置。 特別是，實數值型別的實例不需要超過其所在變數的額外記憶體，而且當 `new` 用來建立實數值型別的實例時，並不會發生動態配置。

#### <a name="object-creation-expressions"></a>物件建立運算式

*Object_creation_expression*可用來建立*class_type*或*value_type*的新實例。

```antlr
object_creation_expression
    : 'new' type '(' argument_list? ')' object_or_collection_initializer?
    | 'new' type object_or_collection_initializer
    ;

object_or_collection_initializer
    : object_initializer
    | collection_initializer
    ;
```

*Object_creation_expression*的*類型*必須是*class_type*、 *value_type*或*type_parameter*。 *類型*不能是 `abstract` *class_type*。

只有當*類型*是*class_type*或*struct_type*時，才允許選擇性的*argument_list* （[引數清單](expressions.md#argument-lists)）。

物件建立運算式可以省略函式引數清單並括住括弧，前提是它包含物件初始化運算式或集合初始化運算式。 省略函式引數清單和括住的括弧，相當於指定空的引數清單。

處理包含物件初始化運算式或集合初始化運算式的物件建立運算式包含第一次處理實例的程式，然後處理物件初始化運算式（[物件初始化運算式](expressions.md#object-initializers)）或集合初始化運算式（[集合](expressions.md#collection-initializers)初始化運算式）所指定的成員或專案初始化。

如果選擇性*argument_list*中的任何引數具有編譯時間型別 `dynamic` 則*object_creation_expression*會動態系結（[動態](expressions.md#dynamic-binding)系結），而下列規則會在執行時間使用具有編譯時間類型 `dynamic`之*argument_list*引數的執行時間類型來套用。 不過，建立物件時，會進行有限的編譯時間檢查，如動態多載[解析的編譯階段檢查](expressions.md#compile-time-checking-of-dynamic-overload-resolution)中所述。

表單 `new T(A)`*object_creation_expression*的系結時間處理，其中 `T` 是*class_type*或*value_type* ，而 `A` 是選擇性的*argument_list*，其中包含下列步驟：

*   如果 `T` 是*value_type* ，而且 `A` 不存在：
    * *Object_creation_expression*是預設的函式呼叫。 *Object_creation_expression*的結果是 `T`類型的值，也就是在[system.object 類型](types.md#the-systemvaluetype-type)中定義的 `T` 預設值。
*   否則，如果 `T` 是*type_parameter* ，而且 `A` 不存在：
    * 如果未針對 `T`指定實數值型別條件約束或函式條件約束（[類型參數條件約束](classes.md#type-parameter-constraints)），則會發生系結時錯誤。
    * *Object_creation_expression*的結果是型別參數已系結的執行時間型別值，也就是叫用該型別的預設函式的結果。 執行時間類型可以是參考型別或實數值型別。
*   否則，如果 `T` 是*class_type*或*struct_type*：
    * 如果 `T` 是 `abstract` *class_type*，就會發生編譯時期錯誤。
    * 要叫用的實例函式是使用多載[解析](expressions.md#overload-resolution)的多載解析規則來決定。 候選實例的集合是由 `T` 中宣告的所有可存取的實例函式所組成，這些函式都適用于 `A` （適用的函式[成員](expressions.md#applicable-function-member)）。 如果候選實例的集合是空的，或者無法識別單一最佳實例的函式，則會發生系結時錯誤。
    * *Object_creation_expression*的結果是 `T`類型的值，也就是叫用上述步驟中所決定之實例的函式所產生的值。
*  否則， *object_creation_expression*無效，而且發生系結時錯誤。

即使*object_creation_expression*是動態系結的，編譯時間類型仍然會 `T`。

表單 `new T(A)`*object_creation_expression*的執行時間處理，其中 `T` 是*class_type*或*struct_type*而 `A` 是選擇性的*argument_list*，其中包含下列步驟：

*   如果 `T` 是*class_type*：
    * 已配置類別 `T` 的新實例。 如果沒有足夠的記憶體可配置新的實例，則會擲回 `System.OutOfMemoryException`，且不會執行任何進一步的步驟。
    * 新實例的所有欄位都會初始化為其預設值（[預設值](variables.md#default-values)）。
    * 根據函式成員調用的規則叫用實例的函式（[動態多載解析的編譯時間檢查](expressions.md#compile-time-checking-of-dynamic-overload-resolution)）。 新配置之實例的參考會自動傳遞至實例的函式，而且可以從該函式內以 `this`的方式存取實例。
*   如果 `T` 是*struct_type*：
    * `T` 類型的實例是藉由配置暫存區域變數來建立的。 因為*struct_type*的具現化程式必須明確地將值指派給所建立之實例的每個欄位，所以不需要初始化暫存變數。
    * 根據函式成員調用的規則叫用實例的函式（[動態多載解析的編譯時間檢查](expressions.md#compile-time-checking-of-dynamic-overload-resolution)）。 新配置之實例的參考會自動傳遞至實例的函式，而且可以從該函式內以 `this`的方式存取實例。

#### <a name="object-initializers"></a>物件初始設定式

***物件初始化運算式***會指定物件的零個或多個欄位、屬性或索引元素的值。

```antlr
object_initializer
    : '{' member_initializer_list? '}'
    | '{' member_initializer_list ',' '}'
    ;

member_initializer_list
    : member_initializer (',' member_initializer)*
    ;

member_initializer
    : initializer_target '=' initializer_value
    ;

initializer_target
    : identifier
    | '[' argument_list ']'
    ;

initializer_value
    : expression
    | object_or_collection_initializer
    ;
```

物件初始化運算式是由成員初始化運算式的序列所組成，並以 `{` 和 `}` token 括住，並以逗號分隔。 每個*member_initializer*都會指定初始化的目標。 *識別碼*必須命名要初始化之物件的可存取欄位或屬性，而括在方括弧中的*argument_list*必須在要初始化的物件上指定可存取索引子的引數。 針對相同的欄位或屬性，物件初始化運算式包含一個以上的成員初始化運算式是錯誤的。

每個*initializer_target*後面會加上等號，以及運算式、物件初始化運算式或集合初始化運算式。 物件初始化運算式中的運算式不可能參考新建立的物件。

成員初始化運算式，可在處理等號之後，使用與目標指派（[簡單指派](expressions.md#simple-assignment)）相同的方式來指定運算式。

成員初始化運算式，指定等號之後的物件初始化運算式是一個***嵌套物件初始化運算式***，也就是初始化内嵌物件。 並不是將新值指派給欄位或屬性，而是將嵌套物件初始化運算式中的指派視為欄位或屬性成員的指派。 無法將嵌套物件初始化運算式套用至具有實數值型別的屬性，或套用至具有實數值型別的唯讀欄位。

在等號之後指定集合初始化運算式的成員初始化運算式是內嵌集合的初始化。 不需要將新的集合指派給目標欄位、屬性或索引子，在初始化運算式中提供的專案會加入至目標所參考的集合中。 目標必須是符合[集合初始化運算式](expressions.md#collection-initializers)中所指定之需求的集合類型。

索引初始化運算式的引數一律只會評估一次。 因此，即使引數最終不會使用（例如，因為是空的嵌套初始化運算式），也會評估它們的副作用。

下列類別代表具有兩個座標的點：
```csharp
public class Point
{
    int x, y;

    public int X { get { return x; } set { x = value; } }
    public int Y { get { return y; } set { y = value; } }
}
```

`Point` 的實例可以建立和初始化，如下所示：
```csharp
Point a = new Point { X = 0, Y = 1 };
```
其作用與
```csharp
Point __a = new Point();
__a.X = 0;
__a.Y = 1; 
Point a = __a;
```
其中 `__a` 是另一個不可見且無法存取的暫存變數。 下列類別代表從兩個點建立的矩形：
```csharp
public class Rectangle
{
    Point p1, p2;

    public Point P1 { get { return p1; } set { p1 = value; } }
    public Point P2 { get { return p2; } set { p2 = value; } }
}
```

`Rectangle` 的實例可以建立和初始化，如下所示：
```csharp
Rectangle r = new Rectangle {
    P1 = new Point { X = 0, Y = 1 },
    P2 = new Point { X = 2, Y = 3 }
};
```
其作用與
```csharp
Rectangle __r = new Rectangle();
Point __p1 = new Point();
__p1.X = 0;
__p1.Y = 1;
__r.P1 = __p1;
Point __p2 = new Point();
__p2.X = 2;
__p2.Y = 3;
__r.P2 = __p2; 
Rectangle r = __r;
```
其中 `__r`、`__p1` 和 `__p2` 是暫時的變數，在其他情況下不可見且無法存取。

如果 `Rectangle`的函式會配置兩個內嵌的 `Point` 實例
```csharp
public class Rectangle
{
    Point p1 = new Point();
    Point p2 = new Point();

    public Point P1 { get { return p1; } }
    public Point P2 { get { return p2; } }
}
```
下列結構可以用來初始化內嵌 `Point` 實例，而不是指派新的實例：
```csharp
Rectangle r = new Rectangle {
    P1 = { X = 0, Y = 1 },
    P2 = { X = 2, Y = 3 }
};
```
其作用與
```csharp
Rectangle __r = new Rectangle();
__r.P1.X = 0;
__r.P1.Y = 1;
__r.P2.X = 2;
__r.P2.Y = 3;
Rectangle r = __r;
```

假設有適當的 C 定義，則下列範例：
```csharp
var c = new C {
    x = true,
    y = { a = "Hello" },
    z = { 1, 2, 3 },
    ["x"] = 5,
    [0,0] = { "a", "b" },
    [1,2] = {}
};
```
相當於這一系列的指派：
```csharp
C __c = new C();
__c.x = true;
__c.y.a = "Hello";
__c.z.Add(1); 
__c.z.Add(2);
__c.z.Add(3);
string __i1 = "x";
__c[__i1] = 5;
int __i2 = 0, __i3 = 0;
__c[__i2,__i3].Add("a");
__c[__i2,__i3].Add("b");
int __i4 = 1, __i5 = 2;
var c = __c;
```
其中 `__c`等會產生不可見且無法存取原始程式碼的變數。 請注意，`[0,0]` 的引數只會評估一次，而 `[1,2]` 的引數會評估一次，即使從未用過它們也一樣。

#### <a name="collection-initializers"></a>集合初始設定式

集合初始化運算式會指定集合的元素。

```antlr
collection_initializer
    : '{' element_initializer_list '}'
    | '{' element_initializer_list ',' '}'
    ;

element_initializer_list
    : element_initializer (',' element_initializer)*
    ;

element_initializer
    : non_assignment_expression
    | '{' expression_list '}'
    ;

expression_list
    : expression (',' expression)*
    ;
```

集合初始化運算式是由一系列的元素初始化運算式所組成，並以 `{` 和 `}` token 括住，並以逗號分隔。 每個專案初始化運算式都會指定要加入至要初始化之集合物件的專案，並包含以 `{` 和 `}` token 括住，並以逗號分隔的運算式清單。  您可以不使用大括弧來撰寫單一運算式專案初始化運算式，但不能是指派運算式，以避免與成員初始化運算式不明確。 *Non_assignment_expression*的生產環境是在[expression](expressions.md#expression)中定義。

以下是包含集合初始化運算式的物件建立運算式範例：
```csharp
List<int> digits = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
```

集合初始化運算式所套用的集合物件，必須是執行 `System.Collections.IEnumerable` 的類型，否則會發生編譯時期錯誤。 對於順序中的每個指定專案，集合初始化運算式會在目標物件上叫用 `Add` 方法，其中包含專案初始化運算式的運算式清單做為引數清單，並針對每個調用套用一般成員查閱和多載解析。 因此，集合物件必須有適用的實例或擴充方法，且每個專案初始化運算式的名稱 `Add`。

下列類別代表連絡人，其中包含名稱和電話號碼清單：
```csharp
public class Contact
{
    string name;
    List<string> phoneNumbers = new List<string>();

    public string Name { get { return name; } set { name = value; } }

    public List<string> PhoneNumbers { get { return phoneNumbers; } }
}
```

`List<Contact>` 可以建立和初始化，如下所示：
```csharp
var contacts = new List<Contact> {
    new Contact {
        Name = "Chris Smith",
        PhoneNumbers = { "206-555-0101", "425-882-8080" }
    },
    new Contact {
        Name = "Bob Harris",
        PhoneNumbers = { "650-555-0199" }
    }
};
```
其作用與
```csharp
var __clist = new List<Contact>();
Contact __c1 = new Contact();
__c1.Name = "Chris Smith";
__c1.PhoneNumbers.Add("206-555-0101");
__c1.PhoneNumbers.Add("425-882-8080");
__clist.Add(__c1);
Contact __c2 = new Contact();
__c2.Name = "Bob Harris";
__c2.PhoneNumbers.Add("650-555-0199");
__clist.Add(__c2);
var contacts = __clist;
```
其中 `__clist`、`__c1` 和 `__c2` 是暫時的變數，在其他情況下不可見且無法存取。

#### <a name="array-creation-expressions"></a>陣列建立運算式

*Array_creation_expression*可用來建立*array_type*的新實例。

```antlr
array_creation_expression
    : 'new' non_array_type '[' expression_list ']' rank_specifier* array_initializer?
    | 'new' array_type array_initializer
    | 'new' rank_specifier array_initializer
    ;
```

第一個表單的陣列建立運算式會配置從運算式清單中刪除每個個別運算式所產生之類型的陣列實例。 例如，陣列建立運算式 `new int[10,20]` 會產生 `int[,]`類型的陣列實例，而陣列建立運算式 `new int[10][,]` 會產生 `int[][,]`類型的陣列。 運算式清單中的每個運算式都必須是 `int`、`uint`、`long`或 `ulong`類型，或可隱含轉換成這些類型的一或多個。 每個運算式的值會決定新配置之陣列實例中對應維度的長度。 因為陣列維度的長度必須是非負值，所以在運算式清單中有一個*constant_expression*具有負值的編譯時期錯誤。

除非在不安全的內容（[unsafe](unsafe-code.md#unsafe-contexts)內容）中，否則不會指定陣列的版面配置。

如果第一個表單的陣列建立運算式包含陣列初始化運算式，則運算式清單中的每個運算式都必須是常數，而且運算式清單所指定的次序和維度長度必須符合陣列初始化運算式的順序。

在第二個或第三個表單的陣列建立運算式中，指定陣列類型或次序規範的順位必須符合陣列初始化運算式的次序。 個別的維度長度是從陣列初始化運算式的每個對應嵌套層級中的專案數推斷而來。 因此，運算式
```csharp
new int[,] {{0, 1}, {2, 3}, {4, 5}}
```
完全對應至
```csharp
new int[3, 2] {{0, 1}, {2, 3}, {4, 5}}
```

第三個表單的陣列建立運算式稱為***隱含類型陣列建立運算式***。 它類似于第二個表單，不同之處在于陣列的元素類型並未明確指定，而是判斷為數組初始化運算式中一組運算式的最佳一般類型（[尋找一組運算式的最佳一般類型](expressions.md#finding-the-best-common-type-of-a-set-of-expressions)）。 若是多維陣列（也就是，其中*rank_specifier*至少包含一個逗號），則此集合包含在嵌套*array_initializer*s 中找到的所有*運算式*。

陣列初始化運算式中的進一步[說明。](arrays.md#array-initializers)

評估陣列建立運算式的結果會分類為值，也就是新配置陣列實例的參考。 陣列建立運算式的執行時間處理是由下列步驟所組成：

*  *Expression_list*的維度長度運算式會依序從左至右評估。 評估每個運算式之後，會對下列其中一種類型執行隱含轉換（[隱含](conversions.md#implicit-conversions)轉換）： `int`、`uint`、`long`、`ulong`。 選擇此清單中的第一個類型，其隱含轉換存在。 如果運算式的評估或後續的隱含轉換造成例外狀況，則不會評估進一步的運算式，也不會執行任何進一步的步驟。
*  維度長度的計算值會依照下列方式進行驗證。 如果一或多個值小於零，則會擲回 `System.OverflowException`，且不會執行任何進一步的步驟。
*  系統會配置具有給定維度長度的陣列實例。 如果沒有足夠的記憶體可配置新的實例，則會擲回 `System.OutOfMemoryException`，且不會執行任何進一步的步驟。
*  新陣列實例的所有元素都會初始化為其預設值（[預設值](variables.md#default-values)）。
*  如果陣列建立運算式包含陣列初始化運算式，則會評估陣列初始化運算式中的每個運算式，並將其指派給其對應的陣列元素。 評估和指派會依照運算式在陣列初始化運算式中撰寫的順序來執行，換言之，專案會以遞增的索引順序初始化，而最右邊的維度會先遞增。 如果給定運算式的評估或後續的對應陣列元素指派導致例外狀況，則不會初始化進一步的元素（因此其餘的專案將會有其預設值）。

陣列建立運算式允許以陣列類型的元素具現化陣列，但這類陣列的元素必須手動初始化。 舉例而言，下列陳述式
```csharp
int[][] a = new int[100][];
```
建立具有100元素類型 `int[]`的一維陣列。 每個元素的初始值都是 `null`。 相同的陣列建立運算式不可能同時具現化子陣列和語句
```csharp
int[][] a = new int[100][5];        // Error
```
會導致編譯時期錯誤。 子陣列的具現化必須改為手動執行，如下所示：
```csharp
int[][] a = new int[100][];
for (int i = 0; i < 100; i++) a[i] = new int[5];
```

當陣列的陣列具有「矩形」圖形時，也就是當子陣列的長度都相同時，使用多維度陣列會更有效率。 在上述範例中，陣列陣列的具現化會建立101物件，一個是外部陣列和100個子陣列。 相反地，
```csharp
int[,] = new int[100, 5];
```
只建立單一物件（二維陣列），並在單一語句中完成配置。

以下是隱含類型陣列建立運算式的範例：
```csharp
var a = new[] { 1, 10, 100, 1000 };                       // int[]

var b = new[] { 1, 1.5, 2, 2.5 };                         // double[]

var c = new[,] { { "hello", null }, { "world", "!" } };   // string[,]

var d = new[] { 1, "one", 2, "two" };                     // Error
```

最後一個運算式會造成編譯時期錯誤，因為 `int` 或 `string` 無法隱含地轉換成另一個，所以沒有最佳的一般類型。 在此情況下，必須使用明確類型的陣列建立運算式，例如，指定要 `object[]`的類型。 或者，其中一個元素可以轉換成一般基底類型，然後再成為推斷的元素類型。

隱含類型陣列建立運算式可以與匿名物件初始化運算式（[匿名物件建立運算式](expressions.md#anonymous-object-creation-expressions)）結合，以建立匿名型別的資料結構。 例如：
```csharp
var contacts = new[] {
    new {
        Name = "Chris Smith",
        PhoneNumbers = new[] { "206-555-0101", "425-882-8080" }
    },
    new {
        Name = "Bob Harris",
        PhoneNumbers = new[] { "650-555-0199" }
    }
};
```

#### <a name="delegate-creation-expressions"></a>委派建立運算式

*Delegate_creation_expression*可用來建立*delegate_type*的新實例。

```antlr
delegate_creation_expression
    : 'new' delegate_type '(' expression ')'
    ;
```

委派建立運算式的引數必須是方法群組、匿名函數或編譯時間類型的值 `dynamic` 或*delegate_type*。 如果引數是方法群組，它會識別要建立委派之物件的方法，以及實例方法的。 如果引數是匿名函式，它會直接定義委派目標的參數和方法主體。 如果引數是值，它會識別要建立複本的委派實例。

如果*運算式*的編譯時間類型 `dynamic`，則*delegate_creation_expression*會動態系結（[動態](expressions.md#dynamic-binding)系結），而下列規則則會使用*運算式*的執行時間類型，在執行時間套用。 否則，規則會在編譯時期套用。

表單 `new D(E)`*delegate_creation_expression*的系結時間處理，其中 `D` 是*delegate_type* ，而 `E` 是*運算式*，由下列步驟組成：

*  如果 `E` 是方法群組，則委派建立運算式的處理方式與從 `E` 到 `D`的方法群組轉換（[方法群組](conversions.md#method-group-conversions)轉換）相同。
*  如果 `E` 是匿名函式，則會以從 `E` 至 `D`的匿名函式轉換（[匿名函數轉換](conversions.md#anonymous-function-conversions)）相同的方式來處理委派建立運算式。
*  如果 `E` 是值，`E` 必須與 `D`相容（[委派](delegates.md#delegate-declarations)宣告），而結果會參考與 `E`相同的調用清單之類型 `D` 新建立的委派。 如果 `E` 與 `D`不相容，就會發生編譯時期錯誤。

表單 `new D(E)`*delegate_creation_expression*的執行時間處理，其中 `D` 是*delegate_type* ，而 `E` 是*運算式*，由下列步驟組成：

*   如果 `E` 是方法群組，則委派建立運算式會評估為從 `E` 到 `D`的方法群組轉換（[方法群組](conversions.md#method-group-conversions)轉換）。
*   如果 `E` 是匿名函式，則會將委派建立評估為從 `E` 至 `D` 的匿名函式轉換（匿名函式[轉換](conversions.md#anonymous-function-conversions)）。
*   如果 `E` 是*delegate_type*的值：
    * 評估 `E`。 如果此評估導致例外狀況，則不會執行任何進一步的步驟。
    * 如果 `E` 的值為 `null`，則會擲回 `System.NullReferenceException`，而且不會執行任何進一步的步驟。
    * 已配置 `D` 委派類型的新實例。 如果沒有足夠的記憶體可配置新的實例，則會擲回 `System.OutOfMemoryException`，且不會執行任何進一步的步驟。
    * 新的委派實例會使用與 `E`所指定的委派實例相同的調用清單進行初始化。

委派的調用清單是在委派具現化時決定，然後在委派的整個存留期間保持不變。 換句話說，一旦建立委派之後，就不能變更它的目標可呼叫實體。 合併兩個委派時，或從另一個（[委派](delegates.md#delegate-declarations)宣告）中移除一個委派時，會產生新的委派結果;沒有任何現有的委派內容已變更。

您不能建立參考屬性、索引子、使用者定義的運算子、實例的程式，或靜態函式的委派。

如上所述，從方法群組建立委派時，委派的正式參數清單和傳回型別會決定要選取的多載方法。 在範例中
```csharp
delegate double DoubleFunc(double x);

class A
{
    DoubleFunc f = new DoubleFunc(Square);

    static float Square(float x) {
        return x * x;
    }

    static double Square(double x) {
        return x * x;
    }
}
```
`A.f` 欄位會使用參考第二個 `Square` 方法的委派進行初始化，因為該方法完全符合 `DoubleFunc`的型式參數清單和傳回類型。 如果第二個 `Square` 方法不存在，就會發生編譯時期錯誤。

#### <a name="anonymous-object-creation-expressions"></a>匿名物件建立運算式

*Anonymous_object_creation_expression*是用來建立匿名型別的物件。

```antlr
anonymous_object_creation_expression
    : 'new' anonymous_object_initializer
    ;

anonymous_object_initializer
    : '{' member_declarator_list? '}'
    | '{' member_declarator_list ',' '}'
    ;

member_declarator_list
    : member_declarator (',' member_declarator)*
    ;

member_declarator
    : simple_name
    | member_access
    | base_access
    | null_conditional_member_access
    | identifier '=' expression
    ;
```

匿名物件初始化運算式會宣告匿名型別，並傳回該型別的實例。 匿名型別是直接繼承自 `object`的無類型類別型別。 匿名型別的成員是從用來建立型別實例的匿名物件初始化運算式推斷的一系列唯讀屬性。 具體而言，就是表單的匿名物件初始化運算式
```csharp
new { p1 = e1, p2 = e2, ..., pn = en }
```
宣告表單的匿名型別
```csharp
class __Anonymous1
{
    private readonly T1 f1;
    private readonly T2 f2;
    ...
    private readonly Tn fn;

    public __Anonymous1(T1 a1, T2 a2, ..., Tn an) {
        f1 = a1;
        f2 = a2;
        ...
        fn = an;
    }

    public T1 p1 { get { return f1; } }
    public T2 p2 { get { return f2; } }
    ...
    public Tn pn { get { return fn; } }

    public override bool Equals(object __o) { ... }
    public override int GetHashCode() { ... }
}
```
其中，每個 `Tx` 都是對應運算式 `ex`的類型。 *Member_declarator*中使用的運算式必須具有類型。 因此， *member_declarator*中的運算式為 null 或匿名函式時，就會發生編譯時期錯誤。 此外，也會發生編譯時期錯誤，讓運算式具有不安全的型別。

匿名型別的名稱和參數的 `Equals` 方法是由編譯器自動產生的，而且無法在程式文字中參考。

在相同的程式中，兩個匿名物件初始化運算式會以相同的順序指定相同名稱和編譯時間類型的一系列屬性，將會產生相同匿名型別的實例。

在範例中
```csharp
var p1 = new { Name = "Lawnmower", Price = 495.00 };
var p2 = new { Name = "Shovel", Price = 26.95 };
p1 = p2;
```
允許在最後一行上指派，因為 `p1` 和 `p2` 都是相同的匿名型別。

匿名型別上的 `Equals` 和 `GetHashcode` 方法會覆寫繼承自 `object`的方法，並根據屬性的 `Equals` 和 `GetHashcode` 來定義，因此，只有在其所有屬性都相等時，相同匿名型別的兩個實例才會相等。

成員宣告子可以縮寫為簡單名稱（[類型推斷](expressions.md#type-inference)）、成員存取（動態多載[解析的編譯時間檢查](expressions.md#compile-time-checking-of-dynamic-overload-resolution)）、基底存取（[基底存取](expressions.md#base-access)）或 Null 條件式成員存取（[null 條件運算式做為投影初始化運算式](expressions.md#null-conditional-expressions-as-projection-initializers)）。 這稱為「***投射初始化運算式***」，而且是宣告的縮寫，而且會指派給具有相同名稱的屬性。 具體而言，表單的成員宣告子
```csharp
identifier
expr.identifier
```
會分別精確地等同于下列各項：
```csharp
identifier = identifier
identifier = expr.identifier
```

因此，在投射初始化運算式中，此*識別碼*會同時選取值和要指派值的欄位或屬性。 簡單來說，投射初始化運算式專案不只是值，也是值的名稱。

### <a name="the-typeof-operator"></a>Typeof 運算子

`typeof` 運算子是用來取得類型的 `System.Type` 物件。

```antlr
typeof_expression
    : 'typeof' '(' type ')'
    | 'typeof' '(' unbound_type_name ')'
    | 'typeof' '(' 'void' ')'
    ;

unbound_type_name
    : identifier generic_dimension_specifier?
    | identifier '::' identifier generic_dimension_specifier?
    | unbound_type_name '.' identifier generic_dimension_specifier?
    ;

generic_dimension_specifier
    : '<' comma* '>'
    ;

comma
    : ','
    ;
```

*Typeof_expression*的第一種形式是由 `typeof` 關鍵字後面接著加上括弧的*型*別所組成。 此表單的運算式結果為所指定類型的 `System.Type` 物件。 針對任何指定的類型，只有一個 `System.Type` 物件。 這表示對於類型 `T`，`typeof(T) == typeof(T)` 一律為 true。 無法 `dynamic`*類型*。

第二種形式的*typeof_expression*是由 `typeof` 關鍵字後面接著加上括弧的*unbound_type_name*所組成。 *Unbound_type_name*與*type_name* （[命名空間和型別名稱](basic-concepts.md#namespace-and-type-names)）非常類似，不同之處在于*unbound_type_name*包含 type_name 包含 type_argument_list *s*的 *generic_dimension_specifier*。 當*typeof_expression*的運算元是一系列的 token，符合*unbound_type_name*和*type_name*的文法時，亦即，當它不包含*generic_dimension_specifier*或*type_argument_list*時，會將標記序列視為*type_name*。 *Unbound_type_name*的意義是依照下列方式決定：

*  將每個*generic_dimension_specifier*換成*type_name* ，方法是以具有相同數目之逗號和關鍵字 `object` 的*type_argument_list*取代每個*type_argument*。
*  評估產生的*type_name*，同時忽略所有類型參數條件約束。
*  *Unbound_type_name*會解析為與產生的結構化類型（系結[和未](types.md#bound-and-unbound-types)系結類型）相關聯的未系結泛型型別。

*Typeof_expression*的結果是產生的未系結泛型型別的 `System.Type` 物件。

第三種形式的*typeof_expression*是由 `typeof` 關鍵字後面接著加上括弧的 `void` 關鍵字所組成。 這個表單的運算式結果是代表缺少類型的 `System.Type` 物件。 `typeof(void)` 傳回的類型物件與針對任何類型傳回的類型物件不同。 這個特殊類型物件在類別庫中很有用，可讓您以語言反映到方法，而這些方法希望能夠以 `System.Type`的實例來表示任何方法的傳回型別（包括 void 方法）。

`typeof` 運算子可用於類型參數。 結果是系結至型別參數之執行時間類型的 `System.Type` 物件。 `typeof` 運算子也可以用於結構化類型或未系結的泛型型別（系結[和未](types.md#bound-and-unbound-types)系結的類型）。 未系結泛型型別的 `System.Type` 物件與實例類型的 `System.Type` 物件不同。 實例型別在執行時間一律是封閉的結構化型別，因此它的 `System.Type` 物件取決於使用中的執行時間型別引數，而未系結的泛型型別沒有型別引數。

範例
```csharp
using System;

class X<T>
{
    public static void PrintTypes() {
        Type[] t = {
            typeof(int),
            typeof(System.Int32),
            typeof(string),
            typeof(double[]),
            typeof(void),
            typeof(T),
            typeof(X<T>),
            typeof(X<X<T>>),
            typeof(X<>)
        };
        for (int i = 0; i < t.Length; i++) {
            Console.WriteLine(t[i]);
        }
    }
}

class Test
{
    static void Main() {
        X<int>.PrintTypes();
    }
}
```
會產生下列輸出：
```console
System.Int32
System.Int32
System.String
System.Double[]
System.Void
System.Int32
X`1[System.Int32]
X`1[X`1[System.Int32]]
X`1[T]
```

請注意，`int` 和 `System.Int32` 是相同的類型。

另請注意，`typeof(X<>)` 的結果不會相依于類型引數，但 `typeof(X<T>)` 的結果。

### <a name="the-checked-and-unchecked-operators"></a>checked 和 unchecked 運算子

`checked` 和 `unchecked` 運算子可用來控制整數類型算數運算和轉換的***溢位檢查內容***。

```antlr
checked_expression
    : 'checked' '(' expression ')'
    ;

unchecked_expression
    : 'unchecked' '(' expression ')'
    ;
```

`checked` 運算子會在檢查的內容中評估包含的運算式，而 `unchecked` 運算子會在未檢查的內容中評估包含的運算式。 *Checked_expression*或*unchecked_expression*會完全對應至*parenthesized_expression* （加上[括弧的運算式](expressions.md#parenthesized-expressions)），不同之處在于包含的運算式會在給定的溢位檢查內容中進行評估。

溢位檢查內容也可以透過 `checked` 和 `unchecked` 語句（[checked 和 unchecked 語句](statements.md#the-checked-and-unchecked-statements)）來控制。

下列作業會受到 `checked` 和 `unchecked` 運算子和語句所建立的溢位檢查內容所影響：

*  當運算元為整數類資料類型時，預先定義的 `++` 和 `--` 一元運算子（後置[遞增和遞減運算子](expressions.md#postfix-increment-and-decrement-operators)和[前置遞增和遞減運算子](expressions.md#prefix-increment-and-decrement-operators)）。
*  當運算元為整數類資料類型時，預先定義的 `-` 一元運算子（[一元減號運算子](expressions.md#unary-minus-operator)）。
*  當兩個運算元都是整數類資料類型時，預先定義的 `+`、`-`、`*`和 `/` 二元運算子（[算術運算子](expressions.md#arithmetic-operators)）。
*  明確數值轉換（[明確數值轉換](conversions.md#explicit-numeric-conversions)），從一個整數類型到另一個整數類型，或從 `float` 或 `double` 到整數類資料類型。

當上述其中一個作業產生的結果太大，而無法在目的地類型中表示時，執行作業的內容會控制產生的行為：

*  在 `checked` 內容中，如果作業是常數運算式（[常數運算式](expressions.md#constant-expressions)），就會發生編譯時期錯誤。 否則，當作業在執行時間執行時，就會擲回 `System.OverflowException`。
*  在 `unchecked` 內容中，會捨棄不符合目的地類型的任何高序位位，以截斷結果。

針對不是由任何 `checked` 或 `unchecked` 運算子或語句括住的非常數運算式（在執行時間評估的運算式），除非 `checked` 評估的外部因素（例如編譯器參數和執行環境設定）呼叫，否則會 `unchecked` 預設溢位檢查內容。

對於常數運算式（可在編譯時期完整評估的運算式），預設的溢位檢查內容一律會 `checked`。 除非常數運算式明確地放在 `unchecked` 內容中，否則在編譯時期評估運算式期間發生的溢位，一律會導致編譯時期錯誤。

匿名函式的主體不會受到匿名函數發生所在 `checked` 或 `unchecked` 內容的影響。

在範例中
```csharp
class Test
{
    static readonly int x = 1000000;
    static readonly int y = 1000000;

    static int F() {
        return checked(x * y);      // Throws OverflowException
    }

    static int G() {
        return unchecked(x * y);    // Returns -727379968
    }

    static int H() {
        return x * y;               // Depends on default
    }
}
```
因為沒有任何運算式可以在編譯時期評估，所以不會報告任何編譯時期錯誤。 在執行時間，`F` 方法會擲回 `System.OverflowException`，而 `G` 方法會傳回-727379968 （超出範圍結果的32位）。 `H` 方法的行為取決於編譯的預設溢位檢查內容，但它與 `F` 相同或與 `G`相同。

在範例中
```csharp
class Test
{
    const int x = 1000000;
    const int y = 1000000;

    static int F() {
        return checked(x * y);      // Compile error, overflow
    }

    static int G() {
        return unchecked(x * y);    // Returns -727379968
    }

    static int H() {
        return x * y;               // Compile error, overflow
    }
}
```
評估 `F` 中的常數運算式時所發生的溢位，`H` 導致報告編譯時期錯誤，因為運算式是在 `checked` 內容中進行評估。 在 `G`中評估常數運算式時也會發生溢位，但由於評估是在 `unchecked` 內容中進行，因此不會報告溢位。

`checked` 和 `unchecked` 運算子只會影響以程式形式包含在「`(`」和「`)`」標記內之作業的溢位檢查內容。 運算子在評估包含的運算式時，不會對叫用的函式成員造成影響。 在範例中
```csharp
class Test
{
    static int Multiply(int x, int y) {
        return x * y;
    }

    static int F() {
        return checked(Multiply(1000000, 1000000));
    }
}
```
在 `F` 中使用 `checked` 不會影響 `Multiply`中的 `x * y` 評估，因此會在預設溢位檢查內容中評估 `x * y`。

當以十六進位標記法撰寫帶正負號整數類型的常數時，`unchecked` 運算子會很方便。 例如：
```csharp
class Test
{
    public const int AllBits = unchecked((int)0xFFFFFFFF);

    public const int HighBit = unchecked((int)0x80000000);
}
```

上述兩個十六進位常數都屬於 `uint`類型。 因為常數不在 `int` 範圍內，而沒有 `unchecked` 運算子，所以轉換成 `int` 會產生編譯時期錯誤。

`checked` 和 `unchecked` 運算子和語句可讓程式設計人員控制某些數值計算的某些層面。 不過，某些數值運算子的行為取決於其運算元的資料類型。 例如，兩個小數位數一律會導致溢位例外狀況，即使在明確 `unchecked` 的結構內也是如此。 同樣地，即使在明確 `checked` 的結構中，將兩個浮點數相乘也不會造成溢位例外狀況。 此外，其他運算子絕不會受到檢查模式的影響，不論是預設或明確。

### <a name="default-value-expressions"></a>預設值運算式

預設值運算式用來取得類型的預設值（[預設](variables.md#default-values)值）。 通常會使用預設值運算式做為型別參數，因為如果型別參數是實值型別或參考型別，它可能不是已知的。 （除非已知型別參數是引用型別，否則不會從 `null` 常值轉換為型別參數）。

```antlr
default_value_expression
    : 'default' '(' type ')'
    ;
```

如果*default_value_expression*中的*型*別在執行時間評估為引用型別，則結果會 `null` 轉換為該型別。 如果*default_value_expression*中的*型*別在執行時間評估為實值型別，則結果會是*Value_type*的預設值（[預設](types.md#default-constructors)的「函數」）。

如果類型是參考型別或已知為參考型別的類型參數（[類型參數條件約束](classes.md#type-parameter-constraints)），則*default_value_expression*是常數運算式（[常數運算式](expressions.md#constant-expressions)）。 此外，如果類型為下列其中一個實數值型別，則*default_value_expression*是常數運算式： `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`char`、`float`、`double`、`decimal`、`bool`或任何列舉類型。


### <a name="nameof-expressions"></a>Nameof 運算式

*Nameof_expression*是用來取得程式實體的名稱，做為常數位串。

```antlr
nameof_expression
    : 'nameof' '(' named_entity ')'
    ;

named_entity
    : simple_name
    | named_entity_target '.' identifier type_argument_list?
    ;

named_entity_target
    : 'this'
    | 'base'
    | named_entity 
    | predefined_type 
    | qualified_alias_member
    ;
```

文法說， *named_entity*的運算元一律是運算式。 因為 `nameof` 不是保留的關鍵字，所以 nameof 運算式在語法上與簡單名稱 `nameof`的叫用都是不明確的。 基於相容性考慮，如果名稱的名稱查閱（[簡單名稱](expressions.md#simple-names)） `nameof` 成功，則會將運算式視為*invocation_expression* --不論調用是否合法。 否則，就是*nameof_expression*。

*Nameof_expression*的*named_entity*意義就是運算式的意義;也就是*simple_name*、 *base_access*或*member_access*。 不過，在[簡單名稱](expressions.md#simple-names)和[成員存取](expressions.md#member-access)中所述的查閱會導致錯誤，因為在靜態內容中找到實例成員， *nameof_expression*不會產生這類錯誤。

*Named_entity*指定方法群組具有*type_argument_list*時，就會發生編譯時期錯誤。 *Named_entity_target*具有類型 `dynamic`時，就會發生編譯時期錯誤。

*Nameof_expression*是 `string`類型的常數運算式，而且在執行時間沒有任何作用。 具體而言，它的*named_entity*不會進行評估，而且會因明確指派分析（[簡單運算式的一般規則](variables.md#general-rules-for-simple-expressions)）而被忽略。 其值是選擇性的最後*type_argument_list*之前*named_entity*的最後一個識別碼，以下列方式轉換：

* 已移除前置詞 "`@`" （如果使用的話）。
* 每個*unicode_escape_sequence*都會轉換成其對應的 unicode 字元。
* 任何*formatting_characters*都會移除。

這些是在測試識別碼之間是否相等時，在[識別碼](lexical-structure.md#identifiers)中套用的相同轉換。

TODO：範例

### <a name="anonymous-method-expressions"></a>匿名方法運算式

*Anonymous_method_expression*是定義匿名函式的兩個方法之一。 這些會在[匿名函數運算式](expressions.md#anonymous-function-expressions)中進一步說明。

## <a name="unary-operators"></a>一元運算子

`?`、`+`、`-`、`!`、`~`、`++`、`--`、cast 和 `await` 運算子稱為一元運算子。

```antlr
unary_expression
    : primary_expression
    | null_conditional_expression
    | '+' unary_expression
    | '-' unary_expression
    | '!' unary_expression
    | '~' unary_expression
    | pre_increment_expression
    | pre_decrement_expression
    | cast_expression
    | await_expression
    | unary_expression_unsafe
    ;
```

如果*unary_expression*的運算元具有 `dynamic`的編譯時間類型，它會動態繫結（[動態](expressions.md#dynamic-binding)系結）。 在此情況下，會 `dynamic`*unary_expression*的編譯時期型別，而且會在執行時間使用運算元的執行時間型別來進行下面所述的解決方法。

### <a name="null-conditional-operator"></a>Null-條件運算子

Null 條件運算子只有在該運算元不是 null 時，才會將作業清單套用至其運算元。 否則，套用運算子的結果會是 `null`。

```antlr
null_conditional_expression
    : primary_expression null_conditional_operations
    ;

null_conditional_operations
    : null_conditional_operations? '?' '.' identifier type_argument_list?
    | null_conditional_operations? '?' '[' argument_list ']'
    | null_conditional_operations '.' identifier type_argument_list?
    | null_conditional_operations '[' argument_list ']'
    | null_conditional_operations '(' argument_list? ')'
    ;
```

作業的清單可以包含成員存取和專案存取作業（本身可能是 null 條件），以及調用。

例如，運算式 `a.b?[0]?.c()` 是具有*primary_expression* `a.b` 和*null_conditional_operations* `?[0]` （null 條件式元素存取）、`?.c` （null 條件式成員存取）和 `()` （調用）的*null_conditional_expression* 。

針對具有*primary_expression* `P`的*null_conditional_expression* `E`，讓 `E0` 是以一種方式從每個具有一個的 `?` *null_conditional_operations*中移除前置 `E` 而取得的運算式。 就概念而言，`E0` 是在 `?`s 所代表的 null 檢查找不到 `null`時，將會評估的運算式。

此外，讓 `E1` 是以單字方式從 `E`中的第一個*null_conditional_operations*中移除前置 `?` 的運算式。 這可能會導致*主要運算式*（如果只有一個 `?`）或另一個*null_conditional_expression*。

例如，如果 `E` 是運算式 `a.b?[0]?.c()`，則 `E0` 是運算式 `a.b[0].c()` 而 `E1` 是運算式 `a.b[0]?.c()`。

如果 `E0` 分類為 [無]，則 `E` 分類為 [無]。 否則，會將 E 分類為值。

`E0` 和 `E1` 用來判斷 `E`的意義：

*  如果 `E` 發生*statement_expression* `E` 的意義與語句相同

   ```csharp
   if ((object)P != null) E1;
   ```

   但只會評估 P 一次。

*  否則，如果 `E0` 分類為不會發生編譯時期錯誤。

*  否則，讓 `T0` 是 `E0`的類型。

   *  如果 `T0` 是不知道是參考型別或不可為 null 的實數值型別的類型參數，則會發生編譯時期錯誤。

   *  如果 `T0` 是不可為 null 的實數值型別，則會 `T0?``E` 的類型，而 `E` 的意義會與

      ```csharp
      ((object)P == null) ? (T0?)null : E1
      ```

      但只會評估 `P` 一次。

   *  否則，E 的類型為 T0，而 E 的意義則與

      ```csharp
      ((object)P == null) ? null : E1
      ```

      但只會評估 `P` 一次。

如果 `E1` 本身為*null_conditional_expression*，則會再次套用這些規則，將 `null` 的測試嵌套，直到沒有進一步的 `?`，而且運算式已縮減到主要運算式 `E0`為止。

例如，如果運算式 `a.b?[0]?.c()` 會當做語句運算式發生，如同語句中的一樣：
```csharp
a.b?[0]?.c();
```
其意義相當於：
```csharp
if (a.b != null) a.b[0]?.c();
```
這同樣相當於：
```csharp
if (a.b != null) if (a.b[0] != null) a.b[0].c();
```
除了 `a.b` 和 `a.b[0]` 只會評估一次。

如果它發生在使用其值的內容中，如下所示：
```csharp
var x = a.b?[0]?.c();
```
而且假設最後一個調用的型別不是不可為 null 的實值型別，其意義就相當於：
```csharp
var x = (a.b == null) ? null : (a.b[0] == null) ? null : a.b[0].c();
```
除了 `a.b` 和 `a.b[0]` 只會評估一次。

#### <a name="null-conditional-expressions-as-projection-initializers"></a>Null-條件運算式做為投影初始化運算式

Null 條件運算式只能做為*anonymous_object_creation_expression* （[匿名物件建立運算式](expressions.md#anonymous-object-creation-expressions)）中的*member_declarator* （如果其結尾為（選擇性的 null 條件式）成員存取）。 文法而言，這項需求可以表示為：

```antlr
null_conditional_member_access
    : primary_expression null_conditional_operations? '?' '.' identifier type_argument_list?
    | primary_expression null_conditional_operations '.' identifier type_argument_list?
    ;
```

這是上述*null_conditional_expression*文法的特殊案例。 *Member_declarator*在[匿名物件建立運算式](expressions.md#anonymous-object-creation-expressions)中的生產環境，只會包含*null_conditional_member_access*。

#### <a name="null-conditional-expressions-as-statement-expressions"></a>Null-條件運算式做為語句運算式

Null 條件運算式只有在以調用結尾時，才允許做為*statement_expression* （[運算式語句](statements.md#expression-statements)）。 文法而言，這項需求可以表示為：

```antlr
null_conditional_invocation_expression
    : primary_expression null_conditional_operations '(' argument_list? ')'
    ;
```

這是上述*null_conditional_expression*文法的特殊案例。 *Statement_expression*在[運算式語句](statements.md#expression-statements)中的生產環境只會包含*null_conditional_invocation_expression*。


### <a name="unary-plus-operator"></a>一元加號運算子

若為 `+x`表單的作業，則會套用一元運算子多載解析（[一元運算子](expressions.md#unary-operator-overload-resolution)多載解析）來選取特定的運算子實作為運算。 運算元會轉換為所選運算子的參數類型，而結果的類型會是運算子的傳回類型。 預先定義的一元加號運算子如下：

```csharp
int operator +(int x);
uint operator +(uint x);
long operator +(long x);
ulong operator +(ulong x);
float operator +(float x);
double operator +(double x);
decimal operator +(decimal x);
```

針對每個運算子，結果只是運算元的值。

### <a name="unary-minus-operator"></a>一元減號運算子

若為 `-x`表單的作業，則會套用一元運算子多載解析（[一元運算子](expressions.md#unary-operator-overload-resolution)多載解析）來選取特定的運算子實作為運算。 運算元會轉換為所選運算子的參數類型，而結果的類型會是運算子的傳回類型。 預先定義的負運算子如下：

*  整數否定：

   ```csharp
   int operator -(int x);
   long operator -(long x);
   ```

   藉由從零減去 `x` 來計算結果。 如果 `x` 的值是運算元類型的最小可顯示值（`int` 為-2 ^ 31，而 `long`則為-2 ^ 63），則不會在運算元類型內顯示 `x` 的數學否定。 如果這發生在 `checked` 內容中，則會擲回 `System.OverflowException`;如果它發生在 `unchecked` 內容中，則結果會是運算元的值，而且不會報告溢位。

   如果負運算子的運算元屬於類型 `uint`，它會轉換成類型 `long`，而結果的類型會是 `long`。 例外狀況是允許將 `int` 值-2147483648 （-2 ^ 31）寫入為十進位整數常值（[整數常](lexical-structure.md#integer-literals)值）的規則。

   如果負運算子的運算元屬於 `ulong`類型，就會發生編譯時期錯誤。 例外狀況是允許 `long` 值-9223372036854775808 （-2 ^ 63）寫入為十進位整數常值（[整數常](lexical-structure.md#integer-literals)值）的規則。

*  浮點否定：

   ```csharp
   float operator -(float x);
   double operator -(double x);
   ```

   結果是 `x` 的值及其正負號反轉。 如果 `x` 是 NaN，則結果也是 NaN。

*  十進位數否定：

   ```csharp
   decimal operator -(decimal x);
   ```

   藉由從零減去 `x` 來計算結果。 小數否定相當於使用 `System.Decimal`類型的一元減號運算子。

### <a name="logical-negation-operator"></a>邏輯否定運算子

若為 `!x`表單的作業，則會套用一元運算子多載解析（[一元運算子](expressions.md#unary-operator-overload-resolution)多載解析）來選取特定的運算子實作為運算。 運算元會轉換為所選運算子的參數類型，而結果的類型會是運算子的傳回類型。 只有一個預先定義的邏輯否定運算子存在：
```csharp
bool operator !(bool x);
```

這個運算子會計算運算元的邏輯否定：如果運算元是 `true`，則會 `false`結果。 如果 `false`運算元，則會 `true`結果。

### <a name="bitwise-complement-operator"></a>位補數運算子

若為 `~x`表單的作業，則會套用一元運算子多載解析（[一元運算子](expressions.md#unary-operator-overload-resolution)多載解析）來選取特定的運算子實作為運算。 運算元會轉換為所選運算子的參數類型，而結果的類型會是運算子的傳回類型。 預先定義的位補數運算子如下：
```csharp
int operator ~(int x);
uint operator ~(uint x);
long operator ~(long x);
ulong operator ~(ulong x);
```

針對每個運算子，運算的結果為 `x`的位補數。

每個列舉類型 `E` 隱含提供下列位補數運算子：

```csharp
E operator ~(E x);
```

評估 `~x`的結果，其中 `x` 是具有基礎類型 `U``E` 的列舉類型運算式，與評估 `(E)(~(U)x)`完全相同，不同之處在于 `E` 的轉換一律會如同在 `unchecked` 內容（[checked 和 unchecked 運算子](expressions.md#the-checked-and-unchecked-operators)）中執行。

### <a name="prefix-increment-and-decrement-operators"></a>前置遞增和遞減運算子

```antlr
pre_increment_expression
    : '++' unary_expression
    ;

pre_decrement_expression
    : '--' unary_expression
    ;
```

前置遞增或遞減運算的運算元必須是分類為變數、屬性存取或索引子存取的運算式。 運算的結果是與運算元相同類型的值。

如果前置詞遞增或遞減運算的運算元是屬性或索引子存取，則屬性或索引子必須同時具有 `get` 和 `set` 存取子。 如果不是這種情況，就會發生系結時錯誤。

一元運算子多載解析（[一元運算子](expressions.md#unary-operator-overload-resolution)多載解析）適用于選取特定的運算子執行。 預先定義的 `++` 和 `--` 運算子存在於下列類型： `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`char`、`float`、`double`、`decimal`和任何列舉類型。 預先定義的 `++` 運算子會傳回將1加入運算元所產生的值，而預先定義的 `--` 運算子則會傳回從運算元減去1所產生的值。 在 `checked` 內容中，如果此加法或減法的結果超出結果型別的範圍，且結果型別為整數型別或列舉型別，則會擲回 `System.OverflowException`。

`++x` 或 `--x` 格式之前置遞增或遞減運算的執行時間處理包含下列步驟：

*   如果 `x` 分類為變數：
    * 評估 `x` 以產生變數。
    * 所選取的運算子會以 `x` 的值做為其引數來叫用。
    * 運算子所傳回的值會儲存在評估 `x`所指定的位置。
    * 運算子傳回的值會變成運算的結果。
*   如果 `x` 分類為屬性或索引子存取：
    * 實例運算式（如果 `x` 不是 `static`），而且會評估與 `x` 相關聯的引數清單（如果 `x` 是索引子存取），而結果會用於後續的 `get` 和 `set` 存取子調用。
    * 會叫用 `x` 的 `get` 存取子。
    * 所選取的運算子會以 `get` 存取子所傳回的值做為其引數來叫用。
    * `x` 的 `set` 存取子會以運算子所傳回的值做為其 `value` 引數來叫用。
    * 運算子傳回的值會變成運算的結果。

`++` 和 `--` 運算子也支援後置標記法（後置[遞增和遞減運算子](expressions.md#postfix-increment-and-decrement-operators)）。 一般來說，`x++` 或 `x--` 的結果是作業之前 `x` 的值，而 `++x` 或 `--x` 的結果是作業之後 `x` 的值。 不論是哪一種情況，在作業之後，`x` 本身都具有相同的值。

您可以使用後置或首碼標記法來叫用 `operator++` 或 `operator--` 的實作為方法。 這兩種標記法不可能有個別的運算子實現。

### <a name="cast-expressions"></a>Cast 運算式

*Cast_expression*是用來將運算式明確轉換成指定的型別。

```antlr
cast_expression
    : '(' type ')' unary_expression
    ;
```

表單 `(T)E`的*cast_expression* ，其中 `T` 是*類型*，而 `E` 是*unary_expression*，會執行 `E` 值的明確轉換（[明確](conversions.md#explicit-conversions)轉換）為類型 `T`。 如果沒有從 `E` 到 `T`的明確轉換存在，就會發生系結時錯誤。 否則，結果會是明確轉換所產生的值。 結果一律會分類為值，即使 `E` 表示變數亦然。

*Cast_expression*的文法會導致某些語法上的多義性。 例如，運算式 `(x)-y` 可以解讀為*cast_expression* （`-y` 轉換為類型 `x`）或*additive_expression*結合 parenthesized_expression （這會計算*值 `x - y)`。*

若要解決*cast_expression*不明確的問題，有下列規則存在：只有在下列其中一項條件成立時，才會將括在括弧中的一或多個*Token*s （[空白字元](lexical-structure.md#white-space)）序列視為*cast_expression*的開頭：

*  Token 的順序是*型*別的正確文法，而不是*運算式*。
*  Token 的順序是正確的*類型*文法，而緊接在右括弧後面的標記是「`~`」、「`!`」、「token」、「`(`」、「*識別碼*（[Unicode 字元逸出序列](lexical-structure.md#unicode-character-escape-sequences)）」、「*常*值」（[常](lexical-structure.md#literals)值），或除了 `as` 和 `is`以外的任何*關鍵字*（[關鍵字](lexical-structure.md#keywords)）。

上述「正確的文法」一詞表示標記的順序必須符合特定文法生產。 它特別不會考慮任何組成識別碼的實際意義。 例如，如果 `x` 和 `y` 是識別碼，則 `x.y` 是類型的正確文法，即使 `x.y` 實際上不代表類型也是一樣。

從去除去除的規則中，如果 `x` 和 `y` 是識別碼、`(x)y`、`(x)(y)`和 `(x)(-y)` *cast_expression*s，但 `(x)-y` 不是，即使 `x` 識別類型也是如此。 不過，如果 `x` 是可識別預先定義之類型（例如 `int`）的關鍵字，則所有四種形式都會*cast_expression*s （因為這類關鍵字本身不可能是運算式）。

### <a name="await-expressions"></a>Await 運算式

Await 運算子是用來暫止封閉式非同步函式的評估，直到運算元所代表的非同步作業完成為止。

```antlr
await_expression
    : 'await' unary_expression
    ;
```

只有在非同步函式（[反覆運算](classes.md#iterators)器）的主體中，才允許*await_expression* 。 在最接近的封閉式非同步函式中，下列位置可能不會有*await_expression* ：

*  在嵌套的（非非同步）匿名函式內
*  在*lock_statement*的區塊內
*  在不安全的內容中

請注意， *await_expression*不能發生在*query_expression*內的大部分地方，因為這些是以語法方式轉換為使用非非同步 lambda 運算式。

在非同步函式內部，`await` 不能當做識別碼使用。 因此，await 運算式和涉及識別碼的各種運算式之間不會有任何語法不明確。 在非同步函式的外部，`await` 會做為一般識別碼。

*Await_expression*的運算元稱為「工作」（ ***task***）。 它代表在評估*await_expression*時，可能或不會完成的非同步作業。 Await 運算子的目的是暫停封閉式非同步函式的執行，直到等候的工作完成為止，然後取得其結果。

#### <a name="awaitable-expressions"></a>可等候運算式

Await 運算式的工作必須是***可等候***。 如果下列其中一個保留，則會可等候運算式 `t`：

*  `t` 是編譯時間類型 `dynamic`
*  `t` 具有稱為 `GetAwaiter` 的可存取實例或擴充方法，沒有參數且沒有型別參數，以及下列所有的保留類型 `A`：
   * `A` 會實 `System.Runtime.CompilerServices.INotifyCompletion` 介面（也就是簡單明瞭的 `INotifyCompletion`）
   * `A` 具有類型的可存取、可讀取的實例屬性 `IsCompleted` `bool`
   * `A` 具有可存取的實例方法 `GetResult` 沒有參數，而且沒有型別參數

`GetAwaiter` 方法的目的是要取得工作的***awaiter*** 。 `A` 的類型稱為 await 運算式的***awaiter 類型***。

`IsCompleted` 屬性的目的是要判斷工作是否已完成。 若是如此，就不需要暫停評估。

`INotifyCompletion.OnCompleted` 方法的目的是要註冊工作的「接續」;也就是工作完成後，將會叫用的委派（屬於 `System.Action`類型）。

`GetResult` 方法的目的是要在工作完成之後取得其結果。 這項結果可能是成功完成（可能包含結果值），也可能是由 `GetResult` 方法擲回的例外狀況。

#### <a name="classification-of-await-expressions"></a>Await 運算式的分類

運算式 `await t` 的分類方式與運算式 `(t).GetAwaiter().GetResult()`相同。 因此，如果 `GetResult` 的傳回型別 `void`， *await_expression*就會分類為 [無]。 如果 `T`的非 void 傳回型別， *await_expression*就會分類為 `T`類型的值。

#### <a name="runtime-evaluation-of-await-expressions"></a>Await 運算式的執行時間評估

在執行時間，會評估運算式 `await t`，如下所示：

*  Awaiter `a` 是藉由評估運算式 `(t).GetAwaiter()`來取得。
*  `bool` `b` 是藉由評估運算式 `(a).IsCompleted`來取得。
*  如果 `b` 是 `false` 則評估會取決於 `a` 是否會執行介面 `System.Runtime.CompilerServices.ICriticalNotifyCompletion` （在此為簡潔起見，這稱為 `ICriticalNotifyCompletion`）。 這種檢查會在系結階段完成;也就是在執行時間，如果 `a` 在編譯時間類型 `dynamic`，則為，否則為。 讓 `r` 表示繼續委派（[反覆運算](classes.md#iterators)器）：
    * 如果 `a` 不會執行 `ICriticalNotifyCompletion`，則會評估運算式 `(a as (INotifyCompletion)).OnCompleted(r)`。
    * 如果 `a` 執行 `ICriticalNotifyCompletion`，則會評估運算式 `(a as (ICriticalNotifyCompletion)).UnsafeOnCompleted(r)`。
    * 然後會暫止評估，並將控制權傳回給 async 函數目前的呼叫端。
*  緊接在（如果 `b` 是 `true`），或在稍後叫用繼續委派（如果 `b` 是 `false`）之後，就會評估運算式 `(a).GetResult()`。 如果它傳回值，該值就是*await_expression*的結果。 否則，結果為 [無]。

Awaiter 的介面方法 `INotifyCompletion.OnCompleted` 和 `ICriticalNotifyCompletion.UnsafeOnCompleted` 的執行，應該會導致最多隻能叫用委派 `r` 一次。 否則，封閉式非同步函式的行為會是未定義的。

## <a name="arithmetic-operators"></a>算術運算子

[`*`]、[`/`]、[`%`]、[`+`] 和 [`-`] 運算子稱為算術運算子。

```antlr
multiplicative_expression
    : unary_expression
    | multiplicative_expression '*' unary_expression
    | multiplicative_expression '/' unary_expression
    | multiplicative_expression '%' unary_expression
    ;

additive_expression
    : multiplicative_expression
    | additive_expression '+' multiplicative_expression
    | additive_expression '-' multiplicative_expression
    ;
```

如果算術運算子的運算元 `dynamic`編譯時期類型，則運算式會動態繫結（[動態](expressions.md#dynamic-binding)系結）。 在此情況下，會 `dynamic`運算式的編譯時期型別，而且會在執行時間使用具有編譯時間型別 `dynamic`之運算元的執行時間型別，來進行下面所述的解決方法。

### <a name="multiplication-operator"></a>乘法運算子

若為 `x * y`表單的作業，則會套用二元運算子多載解析（[二元運算子](expressions.md#binary-operator-overload-resolution)多載解析）來選取特定的運算子實作為運算。 運算元會轉換成所選運算子的參數類型，而結果的類型會是運算子的傳回類型。

預先定義的乘法運算子如下所示。 所有運算子都會計算 `x` 和 `y`的乘積。

*  整數乘法：

   ```csharp
   int operator *(int x, int y);
   uint operator *(uint x, uint y);
   long operator *(long x, long y);
   ulong operator *(ulong x, ulong y);
   ```

   在 `checked` 內容中，如果產品超出結果類型的範圍，則會擲回 `System.OverflowException`。 在 `unchecked` 內容中，不會報告溢位，且會捨棄超出結果型別範圍的任何重要高序位位。


*  浮點乘法：

   ```csharp
   float operator *(float x, float y);
   double operator *(double x, double y);
   ```

   產品是根據 IEEE 754 算術的規則來計算。 下表列出非零的有限值、零、無限大和 NaN 的所有可能組合的結果。 在資料表中，`x` 和 `y` 是正的有限值。 `z` 是 `x * y`的結果。 如果結果對目的地類型而言太大，`z` 為無限大。 如果結果太小而無法用於目的地類型，`z` 為零。

   |      |      |      |     |     |      |      |     |
   |:----:|-----:|:----:|:---:|:---:|:----:|:----:|:----|
   |      | +y   | -y   | +0  | 4\.9.0-  | +inf | -inf | NaN | 
   | +x   | \+ z   | -z   | +0  | 4\.9.0-  | +inf | -inf | NaN | 
   | -x   | -z   | \+ z   | 4\.9.0-  | +0  | -inf | +inf | NaN | 
   | +0   | +0   | 4\.9.0-   | +0  | 4\.9.0-  | NaN  | NaN  | NaN | 
   | 4\.9.0-   | 4\.9.0-   | +0   | 4\.9.0-  | +0  | NaN  | NaN  | NaN | 
   | +inf | +inf | -inf | NaN | NaN | +inf | -inf | NaN | 
   | -inf | -inf | +inf | NaN | NaN | -inf | +inf | NaN | 
   | NaN  | NaN  | NaN  | NaN | NaN | NaN  | NaN  | NaN | 

*  Decimal 乘法：

   ```csharp
   decimal operator *(decimal x, decimal y);
   ```

   如果產生的值太大，而無法以 `decimal` 格式表示，則會擲回 `System.OverflowException`。 如果結果值太小而無法以 `decimal` 格式表示，則結果會是零。 在任何進位之前，結果的小數位數是兩個運算元之刻度的總和。

   Decimal 乘法相當於使用 `System.Decimal`類型的乘法運算子。


### <a name="division-operator"></a>除法運算子

若為 `x / y`表單的作業，則會套用二元運算子多載解析（[二元運算子](expressions.md#binary-operator-overload-resolution)多載解析）來選取特定的運算子實作為運算。 運算元會轉換成所選運算子的參數類型，而結果的類型會是運算子的傳回類型。

預先定義的除法運算子如下所示。 運算子全都計算 `x` 和 `y`的商。

*  整數除法：

   ```csharp
   int operator /(int x, int y);
   uint operator /(uint x, uint y);
   long operator /(long x, long y);
   ulong operator /(ulong x, ulong y);
   ```

   如果右運算元的值為零，則會擲回 `System.DivideByZeroException`。

   除法會將結果向零四捨五入。 因此，結果的絕對值是最大的可能整數，小於或等於兩個運算元的商的絕對值。 當兩個運算元具有相同的正負號，而且兩個運算元具有相反正負號時，結果為零或正數。

   如果左運算元是最小的可顯示 `int` 或 `long` 值，而且已 `-1`右運算元，則會發生溢位。 在 `checked` 內容中，這會擲回 `System.ArithmeticException` （或其子類別）。 在 `unchecked` 內容中，它會定義為是否擲回 `System.ArithmeticException` （或其子類別），否則會以左運算元的結果值來未報告溢位。

*  浮點除法：

   ```csharp
   float operator /(float x, float y);
   double operator /(double x, double y);
   ```

   這些商是根據 IEEE 754 算術的規則來計算。 下表列出非零的有限值、零、無限大和 NaN 的所有可能組合的結果。 在資料表中，`x` 和 `y` 是正的有限值。 `z` 是 `x / y`的結果。 如果結果對目的地類型而言太大，`z` 為無限大。 如果結果太小而無法用於目的地類型，`z` 為零。

   |      |      |      |      |      |      |      |      |
   |:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
   |      | +y   | -y   | +0   | 4\.9.0-   | +inf | -inf | NaN  | 
   | +x   | \+ z   | -z   | +inf | -inf | +0   | 4\.9.0-   | NaN  | 
   | -x   | -z   | \+ z   | -inf | +inf | 4\.9.0-   | +0   | NaN  | 
   | +0   | +0   | 4\.9.0-   | NaN  | NaN  | +0   | 4\.9.0-   | NaN  | 
   | 4\.9.0-   | 4\.9.0-   | +0   | NaN  | NaN  | 4\.9.0-   | +0   | NaN  | 
   | +inf | +inf | -inf | +inf | -inf | NaN  | NaN  | NaN  | 
   | -inf | -inf | +inf | -inf | +inf | NaN  | NaN  | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 

*  小數除法：

   ```csharp
   decimal operator /(decimal x, decimal y);
   ```

   如果右運算元的值為零，則會擲回 `System.DivideByZeroException`。 如果產生的值太大，而無法以 `decimal` 格式表示，則會擲回 `System.OverflowException`。 如果結果值太小而無法以 `decimal` 格式表示，則結果會是零。 結果的規模是最小的尺規，會將結果與最接近的可顯示十進位值保持為實際的數學結果。

   小數除法相當於使用 `System.Decimal`類型的除法運算子。


### <a name="remainder-operator"></a>餘數運算子

若為 `x % y`表單的作業，則會套用二元運算子多載解析（[二元運算子](expressions.md#binary-operator-overload-resolution)多載解析）來選取特定的運算子實作為運算。 運算元會轉換成所選運算子的參數類型，而結果的類型會是運算子的傳回類型。

預先定義的餘數運算子如下所示。 運算子會計算 `x` 和 `y`之間相除的餘數。

*  整數餘數：

   ```csharp
   int operator %(int x, int y);
   uint operator %(uint x, uint y);
   long operator %(long x, long y);
   ulong operator %(ulong x, ulong y);
   ```

   `x % y` 的結果是由 `x - (x / y) * y`所產生的值。 如果 `y` 為零，則會擲回 `System.DivideByZeroException`。

   如果左運算元是最小的 `int` 或 `long` 值，而右運算元是 `-1`，則會擲回 `System.OverflowException`。 在任何情況下，`x % y` 都會擲回例外狀況，其中 `x / y` 不會擲回例外狀況。

*  浮點餘數：

   ```csharp
   float operator %(float x, float y);
   double operator %(double x, double y);
   ```

   下表列出非零的有限值、零、無限大和 NaN 的所有可能組合的結果。 在資料表中，`x` 和 `y` 是正的有限值。 `z` 是 `x % y` 的結果，而且會計算為 `x - n * y`，其中 `n` 是小於或等於 `x / y`的最大可能整數。 這種計算餘數的方法類似于用於整數運算元的，但與 IEEE 754 定義不同（其中 `n` 是最接近 `x / y`的整數）。

   |      |      |      |      |      |      |      |      |
   |:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
   |      | +y   | -y   | +0   | 4\.9.0-   | +inf | -inf | NaN  | 
   | +x   | \+ z   | \+ z   | NaN  | NaN  | x    | x    | NaN  | 
   | -x   | -z   | -z   | NaN  | NaN  | -x   | -x   | NaN  | 
   | +0   | +0   | +0   | NaN  | NaN  | +0   | +0   | NaN  | 
   | 4\.9.0-   | 4\.9.0-   | 4\.9.0-   | NaN  | NaN  | 4\.9.0-   | 4\.9.0-   | NaN  | 
   | +inf | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 
   | -inf | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 

*  小數餘數：

   ```csharp
   decimal operator %(decimal x, decimal y);
   ```

   如果右運算元的值為零，則會擲回 `System.DivideByZeroException`。 在任何進位之前，結果的小數值會大於兩個運算元的刻度，而結果的正負號（如果不是零）則與 `x`相同。

   小數餘數相當於使用 `System.Decimal`類型的餘數運算子。


### <a name="addition-operator"></a>加法運算子

若為 `x + y`表單的作業，則會套用二元運算子多載解析（[二元運算子](expressions.md#binary-operator-overload-resolution)多載解析）來選取特定的運算子實作為運算。 運算元會轉換成所選運算子的參數類型，而結果的類型會是運算子的傳回類型。

預先定義的加法運算子如下所示。 針對數值和列舉類型，預先定義的加法運算子會計算兩個運算元的總和。 當其中一個或兩個運算元的類型為 string 時，預先定義的加法運算子會串連運算元的字串標記法。

*  整數加法：

   ```csharp
   int operator +(int x, int y);
   uint operator +(uint x, uint y);
   long operator +(long x, long y);
   ulong operator +(ulong x, ulong y);
   ```

   在 `checked` 內容中，如果總和超出結果類型的範圍，則會擲回 `System.OverflowException`。 在 `unchecked` 內容中，不會報告溢位，且會捨棄超出結果型別範圍的任何重要高序位位。

*  浮點加法：

   ```csharp
   float operator +(float x, float y);
   double operator +(double x, double y);
   ```

   總和是根據 IEEE 754 算術的規則來計算。 下表列出非零的有限值、零、無限大和 NaN 的所有可能組合的結果。 在資料表中，`x` 和 `y` 是非零的有限值，而 `z` 是 `x + y`的結果。 如果 `x` 和 `y` 具有相同的大小，但正負號相反，則 `z` 為正零。 如果 `x + y` 太大而無法在目的地類型中表示，`z` 就是具有與 `x + y`相同正負號的無限大。

   |      |      |      |      |      |      |      |
   |:----:|:----:|:----:|:----:|:----:|:----:|:----:|
   |      | Y    | +0   | 4\.9.0-   | +inf | -inf | NaN  | 
   | x    | z    | x    | x    | +inf | -inf | NaN  | 
   | +0   | Y    | +0   | +0   | +inf | -inf | NaN  | 
   | 4\.9.0-   | Y    | +0   | 4\.9.0-   | +inf | -inf | NaN  | 
   | +inf | +inf | +inf | +inf | +inf | NaN  | NaN  | 
   | -inf | -inf | -inf | -inf | NaN  | -inf | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 

*  十進位加法：

   ```csharp
   decimal operator +(decimal x, decimal y);
   ```

   如果產生的值太大，而無法以 `decimal` 格式表示，則會擲回 `System.OverflowException`。 在任何進位之前，結果的小數值會大於兩個運算元的刻度。

   Decimal 加法相當於使用 `System.Decimal`類型的加法運算子。

*  列舉加法。 每個列舉型別都會隱含提供下列預先定義的運算子，其中 `E` 是列舉型別，而 `U` 是 `E`的基礎型別：

   ```csharp
   E operator +(E x, U y);
   E operator +(U x, E y);
   ```

   在執行時間，這些運算子會完全依照 `(E)((U)x + (U)y)`進行評估。

*  字串串連：

   ```csharp
   string operator +(string x, string y);
   string operator +(string x, object y);
   string operator +(object x, string y);
   ```

   Binary `+` 運算子的這些多載會執行字串串連。 如果 `null`字串串連的運算元，則會替代空字串。 否則，會叫用繼承自類型 `object`的虛擬 `ToString` 方法，將任何非字串引數轉換成其字串表示。 如果 `ToString` 傳回 `null`，則會替代空字串。

   ```csharp
   using System;
   
   class Test
   {
       static void Main() {
           string s = null;
           Console.WriteLine("s = >" + s + "<");        // displays s = ><
           int i = 1;
           Console.WriteLine("i = " + i);               // displays i = 1
           float f = 1.2300E+15F;
           Console.WriteLine("f = " + f);               // displays f = 1.23E+15
           decimal d = 2.900m;
           Console.WriteLine("d = " + d);               // displays d = 2.900
       }
   }
   ```

   字串串連運算子的結果是由左運算元的字元，後面接著右運算元的字元所組成的字串。 字串串連運算子永遠不會傳回 `null` 值。 如果沒有足夠的記憶體可用來配置產生的字串，則可能會擲回 `System.OutOfMemoryException`。

*  委派組合。 每個委派類型都會隱含提供下列預先定義的運算子，其中 `D` 是委派類型：

   ```csharp
   D operator +(D x, D y);
   ```

   當兩個運算元都屬於 `D`的某些委派類型時，二元 `+` 運算子會執行委派組合。 （如果運算元有不同的委派類型，就會發生系結時錯誤）。如果 `null`第一個運算元，則作業的結果會是第二個運算元的值（即使也 `null`）。 否則，如果第二個運算元 `null`，運算的結果就是第一個運算元的值。 否則，作業的結果會是新的委派實例，當叫用時，會叫用第一個運算元，然後叫用第二個運算元。 如需委派組合的範例，請參閱[減法運算子](expressions.md#subtraction-operator)和[委派調用](delegates.md#delegate-invocation)。 因為 `System.Delegate` 不是委派類型，所以不會為其定義 `operator` `+`。

### <a name="subtraction-operator"></a>減法運算子

若為 `x - y`表單的作業，則會套用二元運算子多載解析（[二元運算子](expressions.md#binary-operator-overload-resolution)多載解析）來選取特定的運算子實作為運算。 運算元會轉換成所選運算子的參數類型，而結果的類型會是運算子的傳回類型。

預先定義的減法運算子如下所示。 運算子全都會從 `x`減去 `y`。

*  整數減法：

   ```csharp
   int operator -(int x, int y);
   uint operator -(uint x, uint y);
   long operator -(long x, long y);
   ulong operator -(ulong x, ulong y);
   ```

   在 `checked` 內容中，如果差異超出結果類型的範圍，則會擲回 `System.OverflowException`。 在 `unchecked` 內容中，不會報告溢位，且會捨棄超出結果型別範圍的任何重要高序位位。

*  浮點減法：

   ```csharp
   float operator -(float x, float y);
   double operator -(double x, double y);
   ```

   差異是根據 IEEE 754 算術的規則來計算。 下表列出非零的有限值、零、無限大和 Nan 的所有可能組合的結果。 在資料表中，`x` 和 `y` 是非零的有限值，而 `z` 是 `x - y`的結果。 如果 `x` 和 `y` 相等，`z` 為正零。 如果 `x - y` 太大而無法在目的地類型中表示，`z` 就是具有與 `x - y`相同正負號的無限大。

   |      |      |      |      |      |      |     |
   |:----:|:----:|:----:|:----:|:----:|:----:|:---:|
   |      | Y    | +0   | 4\.9.0-   | +inf | -inf | NaN | 
   | x    | z    | x    | x    | -inf | +inf | NaN | 
   | +0   | -y   | +0   | +0   | -inf | +inf | NaN | 
   | 4\.9.0-   | -y   | 4\.9.0-   | +0   | -inf | +inf | NaN | 
   | +inf | +inf | +inf | +inf | NaN  | +inf | NaN | 
   | -inf | -inf | -inf | -inf | -inf | NaN  | NaN | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN | 

*  十進位減法：

   ```csharp
   decimal operator -(decimal x, decimal y);
   ```

   如果產生的值太大，而無法以 `decimal` 格式表示，則會擲回 `System.OverflowException`。 在任何進位之前，結果的小數值會大於兩個運算元的刻度。

   十進位減法相當於使用 `System.Decimal`類型的減法運算子。

*  列舉減法。 每個列舉型別都會隱含提供下列預先定義的運算子，其中 `E` 是列舉型別，而 `U` 是 `E`的基礎型別：

   ```csharp
   U operator -(E x, E y);
   ```

   這個運算子的評估方式會與 `(U)((U)x - (U)y)`完全相同。 換句話說，運算子會計算 `x` 和 `y`的序數值之間的差異，而結果的類型則是列舉的基礎類型。

   ```csharp
   E operator -(E x, U y);
   ```

   這個運算子的評估方式會與 `(E)((U)x - y)`完全相同。 換句話說，運算子會從列舉的基礎類型減去值，產生列舉的值。

*  委派移除。 每個委派類型都會隱含提供下列預先定義的運算子，其中 `D` 是委派類型：

   ```csharp
   D operator -(D x, D y);
   ```

   當兩個運算元都屬於 `D`的某些委派類型時，二元 `-` 運算子會執行委派移除。 如果運算元有不同的委派類型，就會發生系結時錯誤。 如果第一個運算元是 `null`，則作業的結果是 `null`。 否則，如果第二個運算元 `null`，運算的結果就是第一個運算元的值。 否則，這兩個運算元代表具有一或多個專案的調用清單（[委派](delegates.md#delegate-declarations)宣告），而結果是由第一個運算元的清單所組成的新調用清單，其中第二個運算元的專案已從它移除，但前提是第二個運算元的清單是第一個的適當連續子清單。     （若要判斷子清單是否相等，對應的專案會針對委派等號比較運算子（[委派相等運算子](expressions.md#delegate-equality-operators)）進行比對。）否則，結果會是左運算元的值。 進程中的兩個運算元清單都不會變更。 如果第二個運算元的清單符合第一個運算元清單中連續專案的多個 sublists，則會移除連續專案的最右邊相符子清單。 如果移除導致空白清單，則結果是 `null`。 例如：

   ```csharp
   delegate void D(int x);
   
   class C
   {
       public static void M1(int i) { /* ... */ }
       public static void M2(int i) { /* ... */ }
   }

   class Test
   {
       static void Main() { 
           D cd1 = new D(C.M1);
           D cd2 = new D(C.M2);
           D cd3 = cd1 + cd2 + cd2 + cd1;   // M1 + M2 + M2 + M1
           cd3 -= cd1;                      // => M1 + M2 + M2
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd1 + cd2;                // => M2 + M1
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd2 + cd2;                // => M1 + M1
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd2 + cd1;                // => M1 + M2
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd1 + cd1;                // => M1 + M2 + M2 + M1
       }
   }
   ```

## <a name="shift-operators"></a>移位運算子

`<<` 和 `>>` 運算子可用來執行位移位作業。

```antlr
shift_expression
    : additive_expression
    | shift_expression '<<' additive_expression
    | shift_expression right_shift additive_expression
    ;
```

如果*shift_expression*的運算元 `dynamic`編譯時間類型，則運算式會動態繫結（[動態](expressions.md#dynamic-binding)系結）。 在此情況下，會 `dynamic`運算式的編譯時期型別，而且會在執行時間使用具有編譯時間型別 `dynamic`之運算元的執行時間型別，來進行下面所述的解決方法。

若為 `x << count` 或 `x >> count`格式的作業，則會套用二元運算子多載解析（[二元運算子](expressions.md#binary-operator-overload-resolution)多載解析）來選取特定的運算子執行。 運算元會轉換成所選運算子的參數類型，而結果的類型會是運算子的傳回類型。

當宣告多載移位運算子時，第一個運算元的類型必須一律是包含運算子宣告的類別或結構，而第二個運算元的類型必須一律 `int`。

預先定義的移位運算子如下所示。

*  左移：

   ```csharp
   int operator <<(int x, int count);
   uint operator <<(uint x, int count);
   long operator <<(long x, int count);
   ulong operator <<(ulong x, int count);
   ```

   `<<` 運算子會將 `x` 向左移位一些計算的位數，如下所述。

   系統會捨棄 `x` 結果類型範圍以外的高序位位，其餘的位會向左移動，而低序位的空白位位置會設定為零。

*  右移：

   ```csharp
   int operator >>(int x, int count);
   uint operator >>(uint x, int count);
   long operator >>(long x, int count);
   ulong operator >>(ulong x, int count);
   ```

   `>>` 運算子會將 `x` 右移一些計算的位數，如下所述。

   當 `x` 的類型為 `int` 或 `long`時，會捨棄 `x` 的低序位位，其餘的位會向右移，而如果 `x` 為負數，則高序位空白位位置會設定為零。

   當 `x` 的類型 `uint` 或 `ulong`時，會捨棄 `x` 的低序位位，其餘的位則會向右移動，而高序位空白位位置會設定為零。

針對預先定義的運算子，會計算要移位的位數，如下所示：

*  當 `x` 的類型 `int` 或 `uint`時，移位元數目是由 `count`的低序位五位所提供。 換句話說，位移計數是從 `count & 0x1F`計算而來。
*  當 `x` 類型 `long` 或 `ulong`時，位移計數是由 `count`的低序位六位所提供。 換句話說，位移計數是從 `count & 0x3F`計算而來。

如果產生的移位元數目為零，移位運算子只會傳回 `x`的值。

移位作業永遠不會造成溢位，並在 `checked` 和 `unchecked` 內容中產生相同的結果。

當 `>>` 運算子的左運算元是帶正負號的整數類資料類型時，運算子會執行算術移位，其中運算元的最高有效位（正負號位）值會傳播至高序位空白位位置。 當 `>>` 運算子的左運算元是不帶正負號的整數類資料類型時，運算子會執行邏輯移位，其中高順序的空白位位置一律會設定為零。 若要執行從運算元類型推斷而來的相反運算，可以使用明確轉換。 例如，如果 `x` 是 `int`類型的變數，則作業 `unchecked((int)((uint)x >> y))` 會執行 `x`的邏輯移位許可權。

## <a name="relational-and-type-testing-operators"></a>關係和類型測試運算子

`==`、`!=`、`<`、`>`、`<=`、`>=`、`is` 和 `as` 運算子稱為「關聯式」和「型別測試」運算子。

```antlr
relational_expression
    : shift_expression
    | relational_expression '<' shift_expression
    | relational_expression '>' shift_expression
    | relational_expression '<=' shift_expression
    | relational_expression '>=' shift_expression
    | relational_expression 'is' type
    | relational_expression 'as' type
    ;

equality_expression
    : relational_expression
    | equality_expression '==' relational_expression
    | equality_expression '!=' relational_expression
    ;
```

[Is 運算子](expressions.md#the-is-operator)中描述了 `is` 運算子，而 `as` 運算子則會在[as 運算子](expressions.md#the-as-operator)中描述。

`==`、`!=`、`<`、`>`、`<=` 和 `>=` 運算子都是***比較運算子***。

如果比較運算子的運算元 `dynamic`編譯時期類型，則運算式會動態繫結（[動態](expressions.md#dynamic-binding)系結）。 在此情況下，會 `dynamic`運算式的編譯時期型別，而且會在執行時間使用具有編譯時間型別 `dynamic`之運算元的執行時間型別，來進行下面所述的解決方法。

若為 `x` *op* `y`格式的作業，其中*op*是比較運算子，則會套用多載解析（[二元運算子](expressions.md#binary-operator-overload-resolution)多載解析）來選取特定的運算子實。 運算元會轉換成所選運算子的參數類型，而結果的類型會是運算子的傳回類型。

下列各節將說明預先定義的比較運算子。 所有預先定義的比較運算子都會傳回類型 `bool`的結果，如下表所述。


| __作業__ | __結果__                                                       |
|---------------|------------------------------------------------------------------|
| `x == y`      | `true`，如果 `x` 等於 `y`，則為，否則為 `false`                 | 
| `x != y`      | `true` 如果 `x` 不等於 `y`，則為，否則為 `false`             | 
| `x < y`       | `true` 如果 `x` 小於 `y`，則為，否則為 `false`                | 
| `x > y`       | `true` 如果 `x` 大於 `y`，則為，否則為 `false`             | 
| `x <= y`      | `true`，如果 `x` 小於或等於 `y`，則為，否則為 `false`    | 
| `x >= y`      | `true` 如果 `x` 大於或等於 `y`，則為，否則為 `false` | 

### <a name="integer-comparison-operators"></a>整數比較運算子

預先定義的整數比較運算子如下：
```csharp
bool operator ==(int x, int y);
bool operator ==(uint x, uint y);
bool operator ==(long x, long y);
bool operator ==(ulong x, ulong y);

bool operator !=(int x, int y);
bool operator !=(uint x, uint y);
bool operator !=(long x, long y);
bool operator !=(ulong x, ulong y);

bool operator <(int x, int y);
bool operator <(uint x, uint y);
bool operator <(long x, long y);
bool operator <(ulong x, ulong y);

bool operator >(int x, int y);
bool operator >(uint x, uint y);
bool operator >(long x, long y);
bool operator >(ulong x, ulong y);

bool operator <=(int x, int y);
bool operator <=(uint x, uint y);
bool operator <=(long x, long y);
bool operator <=(ulong x, ulong y);

bool operator >=(int x, int y);
bool operator >=(uint x, uint y);
bool operator >=(long x, long y);
bool operator >=(ulong x, ulong y);
```

這些運算子會比較兩個整數運算元的數值，並傳回 `bool` 值，指出特定關聯是 `true` 還是 `false`。

### <a name="floating-point-comparison-operators"></a>浮點比較運算子

預先定義的浮點比較運算子如下：
```csharp
bool operator ==(float x, float y);
bool operator ==(double x, double y);

bool operator !=(float x, float y);
bool operator !=(double x, double y);

bool operator <(float x, float y);
bool operator <(double x, double y);

bool operator >(float x, float y);
bool operator >(double x, double y);

bool operator <=(float x, float y);
bool operator <=(double x, double y);

bool operator >=(float x, float y);
bool operator >=(double x, double y);
```

運算子會根據 IEEE 754 標準的規則來比較運算元：

*  如果任一個運算元是 NaN，則會針對 `true`結果的所有運算子（`!=`除外） `false` 結果。 對於任何兩個運算元，`x != y` 一律會產生與 `!(x == y)`相同的結果。 不過，當其中一個或兩個運算元都是 NaN 時，`<`、`>`、`<=`和 `>=` 運算子並不會產生與相反運算子的邏輯否定相同的結果。 例如，如果 `x` 和 `y` 都是 NaN，則 `x < y` 會 `false`，但 `!(x >= y)` 會 `true`。
*  當運算元都不是 NaN 時，運算子會比較兩個浮點運算元的值與排序有關

   ```csharp
   -inf < -max < ... < -min < -0.0 == +0.0 < +min < ... < +max < +inf
   ```

   其中 `min` 和 `max` 是可以用指定的浮點格式表示的最小和最大的正有限值。 此順序的值得注意的效果如下：
   * 負和正零會視為相等。
   * 負無限大會被視為小於所有其他值，但等於另一個負無限大。
   * 正無限大會視為大於所有其他值，但等於另一個正無限大。

### <a name="decimal-comparison-operators"></a>小數比較運算子

預先定義的十進位比較運算子如下：
```csharp
bool operator ==(decimal x, decimal y);
bool operator !=(decimal x, decimal y);
bool operator <(decimal x, decimal y);
bool operator >(decimal x, decimal y);
bool operator <=(decimal x, decimal y);
bool operator >=(decimal x, decimal y);
```

這些運算子會比較兩個十進位運算元的數值，並傳回 `bool` 值，指出特定關聯是 `true` 還是 `false`。 每個小數比較相當於使用 `System.Decimal`類型的對應關聯式或等號比較運算子。

### <a name="boolean-equality-operators"></a>布林等號比較運算子

預先定義的布林等號比較運算子如下：
```csharp
bool operator ==(bool x, bool y);
bool operator !=(bool x, bool y);
```

如果 `x` 和 `y` 都 `true`，或 `x` 和 `y` 都 `false`，`==` 的結果就會 `true`。 否則，結果為 `false`。

如果 `x` 和 `y` 都 `true`，或 `x` 和 `y` 都 `false`，`!=` 的結果就會 `false`。 否則，結果為 `true`。 當運算元的類型是 `bool`時，`!=` 運算子會產生與 `^` 運算子相同的結果。

### <a name="enumeration-comparison-operators"></a>列舉比較運算子

每個列舉型別都會隱含提供下列預先定義的比較運算子：
```csharp
bool operator ==(E x, E y);
bool operator !=(E x, E y);
bool operator <(E x, E y);
bool operator >(E x, E y);
bool operator <=(E x, E y);
bool operator >=(E x, E y);
```

評估 `x op y`的結果，其中 `x` 和 `y` 是以基礎類型 `U``E` 的列舉類型運算式，而 `op` 是其中一個比較運算子，與評估 `((U)x) op ((U)y)`完全相同。 換句話說，列舉型別比較運算子只會比較兩個運算元的基礎整數值。

### <a name="reference-type-equality-operators"></a>參考型別等號比較運算子

預先定義的參考型別等號比較運算子如下：
```csharp
bool operator ==(object x, object y);
bool operator !=(object x, object y);
```

運算子會傳回比較這兩個參考是否相等或不相等的結果。

由於預先定義的參考型別等號比較運算子接受 `object`類型的運算元，因此會套用至所有不會宣告適用 `operator ==` 和 `operator !=` 成員的類型。 相反地，任何適用的使用者定義的等號比較運算子，實際上都會隱藏預先定義的參考型別等號比較運算子。

預先定義的參考型別等號比較運算子需要下列其中一項：

*  這兩個運算元都是已知為*reference_type*或常值 `null`的類型值。 此外，從任一運算元的類型到另一個運算元的類型，都有明確的參考轉換（[明確參考](conversions.md#explicit-reference-conversions)轉換）。
*  一個運算元是類型 `T` 的值，其中 `T` 是*type_parameter* ，而另一個運算元則是常值 `null`。 此外 `T` 不具有實數值型別條件約束。

除非其中一個條件為 true，否則會發生系結時錯誤。 這些規則的值得注意的含意如下：

*  使用預先定義的參考型別等號比較運算子，在系結時，比較已知不同的兩個參考，是一種系結時錯誤。 例如，如果運算元的系結時間類型是 `A` 和 `B`的兩個類別類型，而且如果沒有 `A` 或 `B` 衍生自另一個，則這兩個運算元就無法參考相同的物件。 因此，作業會被視為系結時錯誤。
*  預先定義的參考型別相等運算子不允許比較實數值型別運算元。 因此，除非結構型別宣告它自己的等號比較運算子，否則不可能比較該結構型別的值。
*  預先定義的參考型別等號比較運算子永遠不會對其運算元執行「裝箱」作業。 執行這類的裝箱作業是沒有意義的，因為對新配置的已裝箱實例的參考，一定會與其他所有參考不同。
*  如果類型參數類型的運算元 `T` 比較 `null`，而 `T` 的執行時間類型是實數值型別，則會 `false`比較的結果。

下列範例會檢查不受條件約束之類型參數類型的引數是否 `null`。
```csharp
class C<T>
{
    void F(T x) {
        if (x == null) throw new ArgumentNullException();
        ...
    }
}
```

即使 `T` 可以代表實值型別，也允許 `x == null` 結構，而當 `T` 是實值型別時，只會將結果定義為 `false`。

針對 `x == y` 或 `x != y`格式的作業，如果有任何適用的 `operator ==` 或 `operator !=` 存在，則運算子多載解析（[二元運算子](expressions.md#binary-operator-overload-resolution)多載解析）規則會選取該運算子，而不是預先定義的參考型別等號比較運算子。 不過，一律可以藉由明確地將一個或兩個運算元轉換成 `object`類型，來選取預先定義的參考型別等號比較運算子。 範例
```csharp
using System;

class Test
{
    static void Main() {
        string s = "Test";
        string t = string.Copy(s);
        Console.WriteLine(s == t);
        Console.WriteLine((object)s == t);
        Console.WriteLine(s == (object)t);
        Console.WriteLine((object)s == (object)t);
    }
}
```
產生下列輸出
```console
True
False
False
False
```

`s` 和 `t` 變數指的是兩個不同的 `string` 實例，其中包含相同的字元。 第一個比較會 `True` 輸出，因為兩個運算元都是 `string`類型時，會選取預先定義的字串相等運算子（[字串等號比較運算子](expressions.md#string-equality-operators)）。 其餘的所有輸出 `False`，因為當其中一個或兩個運算元都是 `object`類型時，會選取預先定義的參考型別等號比較運算子。

請注意，上述技術對實值型別沒有意義。 範例
```csharp
class Test
{
    static void Main() {
        int i = 123;
        int j = 123;
        System.Console.WriteLine((object)i == (object)j);
    }
}
```
輸出 `False`，因為轉換會建立兩個不同的已裝箱 `int` 值實例的參考。

### <a name="string-equality-operators"></a>字串等號比較運算子

預先定義的字串等號比較運算子如下：
```csharp
bool operator ==(string x, string y);
bool operator !=(string x, string y);
```

當下列其中一項為真時，會將兩個 `string` 值視為相等：

*  這兩個值都是 `null`。
*  對於在每個字元位置具有相同長度和相同字元的字串實例而言，這兩個值都是非 null 參考。

字串相等運算子會比較字串值，而不是字串參考。 當兩個不同的字串實例包含完全相同的字元序列時，字串的值會相等，但參考則不同。 如[參考型別等號比較運算子](expressions.md#reference-type-equality-operators)中所述，參考型別相等運算子可以用來比較字串參考，而不是字串值。

### <a name="delegate-equality-operators"></a>委派等號比較運算子

每個委派類型都會隱含提供下列預先定義的比較運算子：

```csharp
bool operator ==(System.Delegate x, System.Delegate y);
bool operator !=(System.Delegate x, System.Delegate y);
```

兩個委派實例會視為相同，如下所示：

*  如果其中一個委派實例 `null`，只有在同時 `null`兩者時，才會相等。
*  如果委派有不同的執行時間類型，它們絕對不會相等。
*  如果這兩個委派實例都有調用清單（[委派](delegates.md#delegate-declarations)宣告），只有在其調用清單的長度相同時，這些實例才會相等，而且在另一個調用清單中的每個專案都相等（如下面所定義）至對應的專案（依序）。

下列規則會管理調用清單專案的相等性：

*  如果兩個調用清單專案都參考相同的靜態方法，則專案相等。
*  如果兩個調用清單專案都參考相同目標物件上的相同非靜態方法（如參考等號比較運算子所定義），則專案會相等。
*  在具有相同（可能是空的）集的已捕捉外部變數實例的情況中，會允許（但非必要）為相同的，從評估產生的調用清單專案*anonymous_method_expression*s 或*lambda_expression*s 是相等的。

### <a name="equality-operators-and-null"></a>等號比較運算子和 null

`==` 和 `!=` 運算子允許一個運算元是可為 null 類型的值，另一個運算元則是 `null` 常值，即使作業沒有預先定義或使用者定義的運算子（unlifted 或提升形式）。

適用于其中一種形式的操作
```csharp
x == null
null == x
x != null
null != x
```
其中 `x` 是可為 null 之型別的運算式，如果運算子多載解析（[二元運算子](expressions.md#binary-operator-overload-resolution)多載解析）找不到適用的運算子，則會改為從 `x`的 `HasValue` 屬性計算結果。 具體而言，前兩個表單會轉譯成 `!x.HasValue`，最後兩個表單會轉譯成 `x.HasValue`。

### <a name="the-is-operator"></a>Is 運算子

`is` 運算子可用來動態檢查物件的執行時間類型是否與指定的類型相容。 作業 `E is T`的結果（其中 `E` 是運算式，而 `T` 是類型）是布林值，指出 `E` 是否可以透過參考轉換、裝箱轉換或取消裝箱轉換成功轉換成類型 `T`。 在將類型引數取代為所有類型參數之後，會依照下列方式評估作業：

*  如果 `E` 是匿名函式，則會發生編譯時期錯誤
*  如果 `E` 是方法群組或 `null` 常值，則如果 `E` 的類型是參考型別或可為 null 的類型，且 `E` 的值是 null，則結果為 false。
*  否則，讓 `D` 表示 `E` 的動態類型，如下所示：
   * 如果 `E` 的類型是參考型別，`D` 就是 `E`實例參考的執行時間類型。
   * 如果 `E` 的型別是可為 null 的型別，`D` 就是該可為 null 型別的基礎型別。
   * 如果 `E` 的型別是不可為 null 的實值型別，`D` 就是 `E`的型別。
*  作業的結果取決於 `D` 和 `T`，如下所示：
   * 如果 `T` 是參考型別，如果 `D` 和 `T` 屬於相同類型，則結果為 true，如果 `D` 是參考型別，以及從 `D` 到 `T` 存在的隱含參考轉換，或者 `D` 是實數值型別，且從 `D` 到 `T` 的裝箱轉換存在。
   * 如果 `T` 是可為 null 的型別，則如果 `D` 是 `T`的基礎類型，則結果為 true。
   * 如果 `T` 是不可為 null 的實數值型別，則如果 `D` 和 `T` 的類型相同，則結果為 true。
   * 否則，結果為 false。

請注意，`is` 運算子不會考慮使用者定義的轉換。

### <a name="the-as-operator"></a>As 運算子

`as` 運算子可用來將值明確轉換為指定的參考型別或可為 null 的型別。 不同于 cast 運算式（[cast](expressions.md#cast-expressions)運算式），`as` 運算子絕對不會擲回例外狀況。 相反地，如果不可能指定的轉換，則產生的值會是 `null`。

在 `E as T`表單的作業中，`E` 必須是運算式，而且 `T` 必須是參考型別、已知為參考型別的類型參數，或可為 null 的類型。 此外，下列至少一項必須為 true，否則會發生編譯時期錯誤：

*  身分識別（[身分識別轉換](conversions.md#identity-conversion)）、隱含可為 null 的[轉換](conversions.md#implicit-nullable-conversions)、隱含參考（[隱含參考轉換](conversions.md#implicit-reference-conversions)）、可為 null （「[可為 null」轉換](conversions.md#explicit-nullable-conversions)[）、](conversions.md#boxing-conversions)明確的 nullable （明確[參考轉換](conversions.md#explicit-reference-conversions)），或從 `E` 到 `T`的取消裝箱（[取消程式轉換](conversions.md#unboxing-conversions)）轉換。
*  `E` 或 `T` 的類型是開啟的類型。
*  `E` 是 `null` 的常值。

如果未 `dynamic``E` 的編譯時間類型，則作業 `E as T` 會產生與相同的結果。
```csharp
E is T ? (T)(E) : (T)null
```
但只會評估 `E` 一次。 編譯器可以將 `E as T` 優化，以最多執行一次動態類型檢查，而不是上述擴充所隱含的兩個動態類型檢查。

如果 `E` 的編譯時期類型 `dynamic`，與 cast 運算子不同，`as` 運算子不會動態繫結（[動態](expressions.md#dynamic-binding)系結）。 因此，在此情況下的擴充是：
```csharp
E is T ? (T)(object)(E) : (T)null
```

請注意，某些轉換（例如使用者定義的轉換）不能與 `as` 運算子一起使用，因此應該改用 cast 運算式來執行。

在範例中
```csharp
class X
{

    public string F(object o) {
        return o as string;        // OK, string is a reference type
    }

    public T G<T>(object o) where T: Attribute {
        return o as T;             // Ok, T has a class constraint
    }

    public U H<U>(object o) {
        return o as U;             // Error, U is unconstrained 
    }
}
```
`G` 的型別參數 `T` 已知為引用型別，因為它有類別條件約束。 不過，`H` 的型別參數 `U` 不是;因此，不允許在 `H` 中使用 `as` 運算子。

## <a name="logical-operators"></a>邏輯運算子

`&`、`^`和 `|` 運算子稱為邏輯運算子。

```antlr
and_expression
    : equality_expression
    | and_expression '&' equality_expression
    ;

exclusive_or_expression
    : and_expression
    | exclusive_or_expression '^' and_expression
    ;

inclusive_or_expression
    : exclusive_or_expression
    | inclusive_or_expression '|' exclusive_or_expression
    ;
```

如果邏輯運算子的運算元 `dynamic`編譯時期類型，則運算式會動態繫結（[動態](expressions.md#dynamic-binding)系結）。 在此情況下，會 `dynamic`運算式的編譯時期型別，而且會在執行時間使用具有編譯時間型別 `dynamic`之運算元的執行時間型別，來進行下面所述的解決方法。

若為 `x op y`形式的作業，其中 `op` 是其中一個邏輯運算子，則會套用多載解析（[二元運算子](expressions.md#binary-operator-overload-resolution)多載解析）來選取特定的運算子執行。 運算元會轉換成所選運算子的參數類型，而結果的類型會是運算子的傳回類型。

下列各節將說明預先定義的邏輯運算子。

### <a name="integer-logical-operators"></a>整數邏輯運算子

預先定義的整數邏輯運算子如下：
```csharp
int operator &(int x, int y);
uint operator &(uint x, uint y);
long operator &(long x, long y);
ulong operator &(ulong x, ulong y);

int operator |(int x, int y);
uint operator |(uint x, uint y);
long operator |(long x, long y);
ulong operator |(ulong x, ulong y);

int operator ^(int x, int y);
uint operator ^(uint x, uint y);
long operator ^(long x, long y);
ulong operator ^(ulong x, ulong y);
```

`&` 運算子會計算兩個運算元的位邏輯 `AND`，`|` 運算子會計算兩個運算元的位邏輯 `OR`，而 `^` 運算子會計算兩個運算元的位邏輯獨佔 `OR`。 這些作業不可能發生溢位。

### <a name="enumeration-logical-operators"></a>列舉邏輯運算子

每個列舉類型 `E` 隱含提供下列預先定義的邏輯運算子：

```csharp
E operator &(E x, E y);
E operator |(E x, E y);
E operator ^(E x, E y);
```

評估 `x op y`的結果，其中 `x` 和 `y` 是以基礎類型 `U``E` 的列舉類型運算式，而 `op` 是其中一個邏輯運算子，與評估 `(E)((U)x op (U)y)`完全相同。 換句話說，列舉型別邏輯運算子只會在兩個運算元的基礎型別上執行邏輯運算。

### <a name="boolean-logical-operators"></a>布林值邏輯運算子

預先定義的布林邏輯運算子如下：
```csharp
bool operator &(bool x, bool y);
bool operator |(bool x, bool y);
bool operator ^(bool x, bool y);
```

若 `x` 及 `y` 皆為 `true`，那麼 `x & y` 的結果會是 `true`。 否則，結果為 `false`。

如果 `x` 或 `y` `true`，則會 `true` `x | y` 的結果。 否則，結果為 `false`。

如果 `x` 為 `true` 且 `y` 為 `false`，或 `x` `false` 且 `y` `true`，則會 `true` `x ^ y` 的結果。 否則，結果為 `false`。 當運算元的類型是 `bool`時，`^` 運算子會計算與 `!=` 運算子相同的結果。

### <a name="nullable-boolean-logical-operators"></a>可為 null 的布林值邏輯運算子

可為 null 的布林值類型 `bool?` 可以代表三個值、`true`、`false`和 `null`，而且在概念上類似于 SQL 中用於布林運算式的三個數值型別。 為了確保 `&` 和 `|` 運算子為 `bool?` 運算元所產生的結果與 SQL 的三值邏輯一致，會提供下列預先定義的運算子：

```csharp
bool? operator &(bool? x, bool? y);
bool? operator |(bool? x, bool? y);
```

下表列出這些運算子為 `true`、`false`和 `null`值的所有組合所產生的結果。

| `x`     | `y`     | `x & y` | <code>x &#124; y</code> |
|:-------:|:-------:|:-------:|:-------:|
| `true`  | `true`  | `true`  | `true`  | 
| `true`  | `false` | `false` | `true`  | 
| `true`  | `null`  | `null`  | `true`  | 
| `false` | `true`  | `false` | `true`  | 
| `false` | `false` | `false` | `false` | 
| `false` | `null`  | `false` | `null`  | 
| `null`  | `true`  | `null`  | `true`  | 
| `null`  | `false` | `false` | `null`  | 
| `null`  | `null`  | `null`  | `null`  | 

## <a name="conditional-logical-operators"></a>條件邏輯運算子

`&&` 和 `||` 運算子稱為「條件式邏輯運算子」。 它們也稱為「最小運算」邏輯運算子。

```antlr
conditional_and_expression
    : inclusive_or_expression
    | conditional_and_expression '&&' inclusive_or_expression
    ;

conditional_or_expression
    : conditional_and_expression
    | conditional_or_expression '||' conditional_and_expression
    ;
```

`&&` 和 `||` 運算子是 `&` 和 `|` 運算子的條件式版本：

*  作業 `x && y` 對應至 `x & y`的作業，但只有 `x` 不 `false`時才會評估 `y`。
*  作業 `x || y` 對應至 `x | y`的作業，但只有 `x` 不 `true`時才會評估 `y`。

如果條件式邏輯運算子的運算元具有 `dynamic`的編譯階段類型，則運算式會動態繫結（[動態](expressions.md#dynamic-binding)系結）。 在此情況下，會 `dynamic`運算式的編譯時期型別，而且會在執行時間使用具有編譯時間型別 `dynamic`之運算元的執行時間型別，來進行下面所述的解決方法。

`x && y` 或 `x || y` 格式的作業會藉由套用多載解析（[二元運算子](expressions.md#binary-operator-overload-resolution)多載解析）來處理，如同作業是以 `x & y` 或 `x | y`的方式撰寫。 如此一來，

*  如果多載解析找不到單一最佳運算子，或如果多載解析選取其中一個預先定義的整數邏輯運算子，則會發生系結時錯誤。
*  否則，如果選取的運算子是其中一個預先定義的布林邏輯運算子（[布林邏輯運算子](expressions.md#boolean-logical-operators)）或可為 null 的布林邏輯運算子（[可為 null 的布林邏輯運算子](expressions.md#nullable-boolean-logical-operators)），則會依照[布林條件邏輯運算子](expressions.md#boolean-conditional-logical-operators)中的說明來處理作業。
*  否則，選取的運算子就是使用者定義的運算子，而且會依照[使用者定義的條件式邏輯運算子](expressions.md#user-defined-conditional-logical-operators)中的說明來處理作業。

不可能直接多載條件式邏輯運算子。 不過，因為條件式邏輯運算子是根據一般邏輯運算子來評估，所以一般邏輯運算子的多載是，具有特定限制，也會視為條件式邏輯運算子的多載。 這會在[使用者定義的條件式邏輯運算子](expressions.md#user-defined-conditional-logical-operators)中進一步說明。

### <a name="boolean-conditional-logical-operators"></a>布林條件邏輯運算子

當 `&&` 或 `||` 的運算元屬於 `bool`類型，或如果運算元的類型未定義適用的 `operator &` 或 `operator |`，但確實定義了對 `bool`的隱含轉換，則會以下列方式處理作業：

*  `x && y` 的運算會評估為 `x ? y : false`。 換句話說，`x` 會先進行評估，並轉換成類型 `bool`。 然後，如果 `true``x`，`y` 會進行評估並轉換成類型 `bool`，而這會成為作業的結果。 否則，作業的結果會是 `false`。
*  `x || y` 的運算會評估為 `x ? true : y`。 換句話說，`x` 會先進行評估，並轉換成類型 `bool`。 然後，如果 `true``x`，則會 `true`作業的結果。 否則，`y` 會進行評估並轉換成類型 `bool`，而這會成為作業的結果。

### <a name="user-defined-conditional-logical-operators"></a>使用者定義條件式邏輯運算子

當 `&&` 或 `||` 的運算元屬於宣告適用的使用者定義 `operator &` 或 `operator |`的類型時，下列兩項都必須為 true，其中 `T` 是所選取之運算子的宣告類型：

*  傳回型別和所選運算子之每個參數的型別都必須 `T`。 換句話說，運算子必須計算 `T`類型之兩個運算元的邏輯 `AND` 或邏輯 `OR`，而且必須傳回 `T`類型的結果。
*  `T` 必須包含 `operator true` 和 `operator false`的宣告。

如果未滿足上述任一項需求，就會發生系結時錯誤。 否則，`&&` 或 `||` 作業會藉由結合使用者定義的 `operator true` 或 `operator false` 與所選使用者定義的運算子來進行評估：

*  作業 `x && y` 會評估為 `T.false(x) ? x : T.&(x, y)`，其中 `T.false(x)` 是在 `T`中宣告之 `operator false` 的調用，而 `T.&(x, y)` 是所選 `operator &`的調用。 換句話說，`x` 會先進行評估，並在結果上叫用 `operator false` 以判斷 `x` 是否肯定為 false。 然後，如果 `x` 肯定為 false，則作業的結果會是先前針對 `x`計算的值。 否則，會評估 `y`，並在先前為 `x` 計算的值上叫用選取的 `operator &`，並針對 `y` 計算的值，以產生作業的結果。
*  作業 `x || y` 會評估為 `T.true(x) ? x : T.|(x, y)`，其中 `T.true(x)` 是在 `T`中宣告之 `operator true` 的調用，而 `T.|(x,y)` 是所選 `operator|`的調用。 換句話說，`x` 會先進行評估，並在結果上叫用 `operator true` 以判斷 `x` 是否為絕對符合條件。 然後，如果 `x` 肯定為 true，則作業的結果會是先前針對 `x`計算的值。 否則，會評估 `y`，並在先前為 `x` 計算的值上叫用選取的 `operator |`，並針對 `y` 計算的值，以產生作業的結果。

在上述任一作業中，`x` 所指定的運算式只會評估一次，而 `y` 所指定的運算式則不會進行評估或只評估一次。

如需執行 `operator true` 和 `operator false`之型別的範例，請參閱[資料庫布林值類型](structs.md#database-boolean-type)。

## <a name="the-null-coalescing-operator"></a>Null 聯合運算子

`??` 運算子稱為 null 聯合運算子。

```antlr
null_coalescing_expression
    : conditional_or_expression
    | conditional_or_expression '??' null_coalescing_expression
    ;
```

格式為的 null 聯合運算式 `a ?? b` 需要 `a` 是可為 null 的類型或參考型別。 如果 `a` 為非 null，則 `a ?? b` 的結果會是 `a`;否則，結果會是 `b`。 只有當 `a` 為 null 時，作業才會評估 `b`。

Null 聯合運算子是靠右關聯的，這表示作業會從右至左分組。 例如，表單 `a ?? b ?? c` 的運算式會評估為 `a ?? (b ?? c)`。 一般來說，格式 `E1 ?? E2 ?? ... ?? En` 的運算式會傳回非 null 的第一個運算元，如果所有運算元都是 null，則傳回 null。

運算式 `a ?? b` 的類型取決於運算元上可用的隱含轉換。 依照喜好設定的順序，`a ?? b` 的類型為 `A0`、`A`或 `B`，其中 `A` 是 `a` 的類型（前提是 `a` 具有類型）、`B` 是 `b` 的類型（假設 `b` 具有類型），而 `A0` 是可為 null 的類型時 `A` 的基礎類型，否則為 `A`。 具體而言，`a ?? b` 的處理方式如下：

*  如果 `A` 存在，而且不是可為 null 的型別或參考型別，就會發生編譯時期錯誤。
*  如果 `b` 是動態運算式，則結果類型為 `dynamic`。 在執行時間，會先評估 `a`。 如果 `a` 不是 null，`a` 會轉換為 dynamic，而這會變成結果。 否則，會評估 `b`，而這會變成結果。
*  否則，如果 `A` 存在，而且是可為 null 的型別，且從 `b` 到 `A0`都有隱含轉換，則結果型別會 `A0`。 在執行時間，會先評估 `a`。 如果 `a` 不是 null，`a` 會解除包裝為類型 `A0`，而這會變成結果。 否則，`b` 會進行評估並轉換成類型 `A0`，而這會變成結果。
*  否則，如果 `A` 存在，且從 `b` 到 `A`的隱含轉換存在，則會 `A`結果類型。 在執行時間，會先評估 `a`。 如果 `a` 不是 null，`a` 就會變成結果。 否則，`b` 會進行評估並轉換成類型 `A`，而這會變成結果。
*  否則，如果 `b` 的類型 `B`，而從 `a` 到 `B`的隱含轉換存在，則結果類型會是 `B`。 在執行時間，會先評估 `a`。 如果 `a` 不是 null，`a` 會解除包裝為類型 `A0` （如果 `A` 存在且可為 null）並轉換為類型 `B`，這會變成結果。 否則，會評估 `b` 並成為結果。
*  否則，`a` 和 `b` 不相容，而且會發生編譯時期錯誤。

## <a name="conditional-operator"></a>條件運算子

`?:` 運算子稱為「條件運算子」。 有時候也稱為三元運算子。

```antlr
conditional_expression
    : null_coalescing_expression
    | null_coalescing_expression '?' expression ':' expression
    ;
```

表單 `b ? x : y` 的條件運算式會先評估 `b`的條件。 然後，如果 `true``b`，就會評估 `x`，並成為作業的結果。 否則，會評估 `y`，並成為作業的結果。 條件運算式絕對不會同時評估 `x` 和 `y`。

條件運算子是右向關聯，表示作業會從右至左分組。 例如，表單 `a ? b : c ? d : e` 的運算式會評估為 `a ? b : (c ? d : e)`。

`?:` 運算子的第一個運算元必須是可以隱含地轉換成 `bool`的運算式，或是實作為 `operator true`之型別的運算式。 如果這兩項需求都不符合，就會發生編譯時期錯誤。

`?:` 運算子的第二個和第三個運算元，`x` 和 `y`控制條件運算式的類型。

*  如果 `x` 的類型為 `X`，而 `y` 的類型 `Y` 則為
   * 如果隱含轉換（[隱含](conversions.md#implicit-conversions)轉換）從 `X` 到 `Y`（而不是從 `Y` 到 `X`）存在，則 `Y` 是條件運算式的類型。
   * 如果隱含轉換（[隱含](conversions.md#implicit-conversions)轉換）從 `Y` 到 `X`（而不是從 `X` 到 `Y`）存在，則 `X` 是條件運算式的類型。
   * 否則，就無法判斷運算式類型，且會發生編譯時期錯誤。
*  如果只有其中一個 `x` 和 `y` 具有型別，而且 `x` 和 `y`都可以隱含地轉換成該型別，則這就是條件運算式的型別。
*  否則，就無法判斷運算式類型，且會發生編譯時期錯誤。

`b ? x : y` 格式之條件運算式的執行時間處理包含下列步驟：

*  首先會評估 `b`，並決定 `b` 的 `bool` 值：
   * 如果從 `b` 類型到 `bool` 的隱含轉換存在，則會執行此隱含轉換以產生 `bool` 值。
   * 否則，會叫用 `b` 類型所定義的 `operator true`，以產生 `bool` 值。
*  如果上述步驟所產生的 `bool` 值是 `true`的，則會評估 `x`，並將其轉換成條件運算式的類型，這會成為條件運算式的結果。
*  否則，會評估 `y`，並將其轉換成條件運算式的類型，這會成為條件運算式的結果。

## <a name="anonymous-function-expressions"></a>匿名函數運算式

***匿名函數***是表示「內嵌」方法定義的運算式。 匿名函數本身並沒有值或類型，但是可以轉換成相容的委派或運算式樹狀架構類型。 匿名函數轉換的評估取決於轉換的目標型別：如果它是委派類型，轉換會評估為參考匿名函式所定義之方法的委派值。 如果是運算式樹狀架構型別，則轉換會評估為運算式樹狀架構，其代表方法的結構做為物件結構。

基於歷史原因，匿名函式有兩個語法類別，也就是*lambda_expression*s 和*anonymous_method_expression*s。 對於幾乎所有的用途而言， *lambda_expression*的比*anonymous_method_expression*更精簡且易懂，而這種語言仍會提供回溯相容性。

```antlr
lambda_expression
    : anonymous_function_signature '=>' anonymous_function_body
    ;

anonymous_method_expression
    : 'delegate' explicit_anonymous_function_signature? block
    ;

anonymous_function_signature
    : explicit_anonymous_function_signature
    | implicit_anonymous_function_signature
    ;

explicit_anonymous_function_signature
    : '(' explicit_anonymous_function_parameter_list? ')'
    ;

explicit_anonymous_function_parameter_list
    : explicit_anonymous_function_parameter (',' explicit_anonymous_function_parameter)*
    ;

explicit_anonymous_function_parameter
    : anonymous_function_parameter_modifier? type identifier
    ;

anonymous_function_parameter_modifier
    : 'ref'
    | 'out'
    ;

implicit_anonymous_function_signature
    : '(' implicit_anonymous_function_parameter_list? ')'
    | implicit_anonymous_function_parameter
    ;

implicit_anonymous_function_parameter_list
    : implicit_anonymous_function_parameter (',' implicit_anonymous_function_parameter)*
    ;

implicit_anonymous_function_parameter
    : identifier
    ;

anonymous_function_body
    : expression
    | block
    ;
```

`=>` 運算子與指派（`=`）具有相同的優先順序，而且為右向關聯。

具有 `async` 修飾詞的匿名函數是非同步函式，並遵循[反覆運算](classes.md#iterators)器中所述的規則。

以*lambda_expression*形式的匿名函式的參數可以明確或隱含類型。 在明確類型的參數清單中，會明確陳述每個參數的類型。 在隱含型別參數清單中，參數的型別是從匿名函式發生的內容推斷而來，特別是當匿名函式轉換成相容的委派型別或運算式樹狀架構型別時，該型別會提供參數類型（[匿名函數轉換](conversions.md#anonymous-function-conversions)）。

在具有單一隱含型別參數的匿名函式中，括弧可能會從參數清單中省略。 換句話說，此表單的匿名函式
```csharp
( param ) => expr
```
可以縮寫為
```csharp
param => expr
```

匿名函式的參數清單（以*anonymous_method_expression*的形式）是選擇性的。 如果有指定，則必須明確地輸入參數。 如果不是，則匿名函式可以轉換成具有任何參數清單不包含 `out` 參數的委派。

匿名函式的*區塊*主體可以連接（[結束點和](statements.md#end-points-and-reachability)可連線性），除非匿名函式發生在無法連接的語句內。

下列是匿名函式的一些範例：

```csharp
x => x + 1                              // Implicitly typed, expression body
x => { return x + 1; }                  // Implicitly typed, statement body
(int x) => x + 1                        // Explicitly typed, expression body
(int x) => { return x + 1; }            // Explicitly typed, statement body
(x, y) => x * y                         // Multiple parameters
() => Console.WriteLine()               // No parameters
async (t1,t2) => await t1 + await t2    // Async
delegate (int x) { return x + 1; }      // Anonymous method expression
delegate { return 1 + 1; }              // Parameter list omitted
```

除了下列幾點以外， *lambda_expression*s 和*anonymous_method_expression*的行為都相同：

*  *anonymous_method_expression*允許完全省略參數清單，產生可轉換性以委派任何值參數清單的類型。
*  *lambda_expression*允許省略和推斷參數類型，而*anonymous_method_expression*s 需要明確陳述參數類型。
*  *Lambda_expression*的主體可以是運算式或語句區塊，而*anonymous_method_expression*的主體必須是語句區塊。
*  只有*lambda_expression*的會轉換成相容的運算式樹狀架構類型（[運算式樹狀架構類型](types.md#expression-tree-types)）。

### <a name="anonymous-function-signatures"></a>匿名函式簽章

匿名函式的選擇性*anonymous_function_signature*會定義匿名函數的名稱，以及選擇性的型式參數類型。 匿名函數的參數範圍是*anonymous_function_body*。 （[範圍](basic-concepts.md#scopes)）連同參數清單（如果有指定），匿名方法主體會構成宣告空間（[宣告）。](basic-concepts.md#declarations) 因此，匿名函式的參數名稱會發生編譯時期錯誤，以符合其範圍包含*anonymous_method_expression*或*lambda_expression*的本機變數、本機常數或參數的名稱。

如果匿名函式具有*explicit_anonymous_function_signature*，則相容委派類型和運算式樹狀結構類型的集合會限制為具有相同順序的相同參數類型和修飾詞的集合。 相較于方法群組轉換（[方法群組轉換](conversions.md#method-group-conversions)），不支援匿名函式參數類型的逆變變異。 如果匿名函式沒有*anonymous_function_signature*，則相容委派類型和運算式樹狀結構類型的集合會限制為沒有任何 `out` 參數的型別。

請注意， *anonymous_function_signature*不能包含屬性或參數陣列。 儘管如此， *anonymous_function_signature*可能會與參數清單包含參數陣列的委派型別相容。

另請注意，即使相容，轉換成運算式樹狀架構類型仍然可能會在編譯時期（[運算式樹狀架構類型](types.md#expression-tree-types)）失敗。

### <a name="anonymous-function-bodies"></a>匿名函數主體

匿名函式的主體（*運算式*或*區塊*）受限於下列規則：

*  如果匿名函式包含簽章，則簽章中指定的參數可在本文中取得。 如果匿名函式沒有簽章，它可以轉換成具有參數（匿名函式[轉換](conversions.md#anonymous-function-conversions)）的委派類型或運算式類型，但無法在主體中存取參數。
*  除了在最接近的封閉式匿名函式的簽章中指定的 `ref` 或 `out` 參數（如果有的話），這是主體存取 `ref` 或 `out` 參數的編譯時期錯誤。
*  當 `this` 的型別是結構型別時，本文就會發生編譯時期錯誤，`this`。 無論存取是明確的（如 `this.x`）還是隱含的（如 `x`，其中 `x` 是結構的實例成員）都是如此。 此規則只會禁止這類存取，而且不會影響成員查閱結果是否在結構的成員中。
*  主體可以存取匿名函數的外部變數（[外部變數](expressions.md#outer-variables)）。 外部變數的存取將會參考在評估*lambda_expression*或*anonymous_method_expression*時（[匿名函數運算式的評估](expressions.md#evaluation-of-anonymous-function-expressions)）所使用的變數實例。
*  本文所包含的 `goto` 語句、`break` 語句或 `continue` 語句，其目標是在主體之外，或包含在內含匿名函式的主體內，這是一個編譯時期錯誤。
*  主體中的 `return` 語句會從最接近的封閉式匿名函式（而不是從封入函式成員）的調用中傳回控制權。 在 `return` 語句中指定的運算式必須隱含地轉換為最接近的封入*lambda_expression*或*anonymous_method_expression*轉換的委派類型或運算式樹狀架構類型的傳回類型（[匿名函數轉換](conversions.md#anonymous-function-conversions)）。

無論是否有任何方法可執行匿名函式的區塊，而不是透過評估和叫用*lambda_expression*或*anonymous_method_expression*，都可以明確指定。 特別是，編譯器可以藉由合成一或多個已命名的方法或類型，來選擇實作用中的匿名函式。 任何這類合成元素的名稱都必須是保留給編譯器使用的格式。

### <a name="overload-resolution-and-anonymous-functions"></a>多載解析和匿名函式

引數清單中的匿名函數會參與型別推斷和多載解析。 如需確切的規則，請參閱[型別推斷](expressions.md#type-inference)和多載[解析](expressions.md#overload-resolution)。

下列範例說明匿名函數在多載解析上的效果。

```csharp
class ItemList<T>: List<T>
{
    public int Sum(Func<T,int> selector) {
        int sum = 0;
        foreach (T item in this) sum += selector(item);
        return sum;
    }

    public double Sum(Func<T,double> selector) {
        double sum = 0;
        foreach (T item in this) sum += selector(item);
        return sum;
    }
}
```

`ItemList<T>` 類別有兩個 `Sum` 方法。 每個都會接受一個 `selector` 引數，這會將值從清單專案中解壓縮到總和。 已解壓縮的值可以是 `int` 或 `double`，而產生的總和同樣也是 `int` 或 `double`。

例如，您可以使用 `Sum` 方法，從訂單中的詳細資料行清單計算總和。

```csharp
class Detail
{
    public int UnitCount;
    public double UnitPrice;
    ...
}

void ComputeSums() {
    ItemList<Detail> orderDetails = GetOrderDetails(...);
    int totalUnits = orderDetails.Sum(d => d.UnitCount);
    double orderTotal = orderDetails.Sum(d => d.UnitPrice * d.UnitCount);
    ...
}
```

在 `orderDetails.Sum`的第一個調用中，這兩個 `Sum` 方法都適用，因為匿名函數 `d => d. UnitCount` 與 `Func<Detail,int>` 和 `Func<Detail,double>`相容。 不過，多載解析會挑選第一個 `Sum` 方法，因為轉換成 `Func<Detail,int>` 比轉換成 `Func<Detail,double>`的效果更好。

在 `orderDetails.Sum`的第二個調用中，只有第二個 `Sum` 方法是適用的，因為匿名函數 `d => d.UnitPrice * d.UnitCount` 會產生 `double`類型的值。 因此，多載解析會挑選該調用的第二個 `Sum` 方法。

### <a name="anonymous-functions-and-dynamic-binding"></a>匿名函數和動態繫結

匿名函式不可以是動態繫結作業的接收者、引數或運算元。

### <a name="outer-variables"></a>外部變數

其範圍包含*lambda_expression*或*anonymous_method_expression*的任何本機變數、值參數或參數陣列，都稱為匿名函式的***外部變數***。 在類別的實例函式成員中，`this` 值會視為值參數，而且是包含在函式成員內之任何匿名函數的外部變數。

#### <a name="captured-outer-variables"></a>已捕捉的外部變數

當匿名函式參考外部變數時，會將外部變數視為匿名函數所***捕捉***的。 通常，本機變數的存留期僅限於執行與它相關聯的區塊或語句（[區域變數](variables.md#local-variables)）。 不過，已捕捉外部變數的存留期至少會延伸到從匿名函式建立的委派或運算式樹狀結構，才符合垃圾收集的資格。

在範例中
```csharp
using System;

delegate int D();

class Test
{
    static D F() {
        int x = 0;
        D result = () => ++x;
        return result;
    }

    static void Main() {
        D d = F();
        Console.WriteLine(d());
        Console.WriteLine(d());
        Console.WriteLine(d());
    }
}
```
本機變數 `x` 是由匿名函式所捕捉，而 `x` 的存留期至少會擴充，直到從 `F` 傳回的委派符合垃圾收集的資格（這不會發生到程式的最結尾為止）。 由於每個匿名函式的叫用都是在相同的 `x`實例上運作，因此範例的輸出為：
```console
1
2
3
```

當匿名函式捕捉到本機變數或值參數時，區域變數或參數不會再被視為固定變數（[固定和可移動變數](unsafe-code.md#fixed-and-moveable-variables)），而是會被視為可移動變數。 因此，任何採用已捕捉外部變數位址的 `unsafe` 程式碼，都必須先使用 `fixed` 語句來修正變數。

請注意，與 uncaptured 變數不同的是，已捕捉的區域變數可以同時公開給多個執行執行緒。

#### <a name="instantiation-of-local-variables"></a>區域變數的具現化

當執行進入變數的範圍時，會將本機變數視為具現***化***。 例如，叫用下列方法時，區域變數 `x` 會具現化並初始化三次，每次反覆運算迴圈。

```csharp
static void F() {
    for (int i = 0; i < 3; i++) {
        int x = i * 2 + 1;
        ...
    }
}
```

不過，將 `x` 的宣告移至迴圈外，會產生 `x`的單一具現化：
```csharp
static void F() {
    int x;
    for (int i = 0; i < 3; i++) {
        x = i * 2 + 1;
        ...
    }
}
```

未捕捉到時，無法確切觀察本機變數的具現化方式，因為具現化的存留期不相鄰，所以每個具現化都可能只使用相同的儲存位置。 不過，當匿名函式捕捉到本機變數時，具現化的效果會變得很明顯。

範例
```csharp
using System;

delegate void D();

class Test
{
    static D[] F() {
        D[] result = new D[3];
        for (int i = 0; i < 3; i++) {
            int x = i * 2 + 1;
            result[i] = () => { Console.WriteLine(x); };
        }
        return result;
    }

    static void Main() {
        foreach (D d in F()) d();
    }
}
```
產生下列輸出：
```console
1
3
5
```

不過，當 `x` 的宣告移至迴圈外時：
```csharp
static D[] F() {
    D[] result = new D[3];
    int x;
    for (int i = 0; i < 3; i++) {
        x = i * 2 + 1;
        result[i] = () => { Console.WriteLine(x); };
    }
    return result;
}
```
輸出為：
```console
5
5
5
```

如果 for 迴圈宣告反復專案變數，該變數本身會被視為在迴圈外部宣告。 因此，如果此範例已變更為捕捉反覆運算變數本身：

```csharp
static D[] F() {
    D[] result = new D[3];
    for (int i = 0; i < 3; i++) {
        result[i] = () => { Console.WriteLine(i); };
    }
    return result;
}
```
只會捕捉反覆運算變數的一個實例，這會產生輸出：
```console
3
3
3
```

匿名函式委派可以共用一些已捕捉的變數，但卻有其他的實例。 例如，如果 `F` 變更為
```csharp
static D[] F() {
    D[] result = new D[3];
    int x = 0;
    for (int i = 0; i < 3; i++) {
        int y = 0;
        result[i] = () => { Console.WriteLine("{0} {1}", ++x, ++y); };
    }
    return result;
}
```
這三個委派會捕捉相同的 `x` 實例，但 `y`的個別實例，輸出如下：
```console
1 1
2 1
3 1
```

個別的匿名函式可以抓取外部變數的相同實例。 在下列範例中：
```csharp
using System;

delegate void Setter(int value);

delegate int Getter();

class Test
{
    static void Main() {
        int x = 0;
        Setter s = (int value) => { x = value; };
        Getter g = () => { return x; };
        s(5);
        Console.WriteLine(g());
        s(10);
        Console.WriteLine(g());
    }
}
```
這兩個匿名函式會 `x`來捕捉相同的本機變數實例，因此可以透過該變數「通訊」。 範例的輸出為：
```console
5
10
```

### <a name="evaluation-of-anonymous-function-expressions"></a>評估匿名函數運算式

匿名函數 `F` 必須一律轉換成委派類型 `D` 或運算式樹狀結構類型 `E`，不論是直接或透過執行委派建立運算式 `new D(F)`。 此轉換會判斷匿名函式的結果，如[匿名函數轉換](conversions.md#anonymous-function-conversions)中所述。

## <a name="query-expressions"></a>查詢運算式

***查詢運算式***針對類似關聯式和階層式查詢語言（例如 SQL 和 XQuery）的查詢提供了語言整合的語法。

```antlr
query_expression
    : from_clause query_body
    ;

from_clause
    : 'from' type? identifier 'in' expression
    ;

query_body
    : query_body_clauses? select_or_group_clause query_continuation?
    ;

query_body_clauses
    : query_body_clause
    | query_body_clauses query_body_clause
    ;

query_body_clause
    : from_clause
    | let_clause
    | where_clause
    | join_clause
    | join_into_clause
    | orderby_clause
    ;

let_clause
    : 'let' identifier '=' expression
    ;

where_clause
    : 'where' boolean_expression
    ;

join_clause
    : 'join' type? identifier 'in' expression 'on' expression 'equals' expression
    ;

join_into_clause
    : 'join' type? identifier 'in' expression 'on' expression 'equals' expression 'into' identifier
    ;

orderby_clause
    : 'orderby' orderings
    ;

orderings
    : ordering (',' ordering)*
    ;

ordering
    : expression ordering_direction?
    ;

ordering_direction
    : 'ascending'
    | 'descending'
    ;

select_or_group_clause
    : select_clause
    | group_clause
    ;

select_clause
    : 'select' expression
    ;

group_clause
    : 'group' expression 'by' expression
    ;

query_continuation
    : 'into' identifier query_body
    ;
```

查詢運算式是以 `from` 子句開頭，並以 `select` 或 `group` 子句做為結尾。 初始 `from` 子句後面可以接著零個或多個 `from`、`let`、`where`、`join` 或 `orderby` 子句。 每個 `from` 子句都是一個產生器的產生器，其範圍***變數***會超出***序列***的元素範圍。 每個 `let` 子句都會引進一個範圍變數，代表以先前範圍變數計算的值。 每個 `where` 子句都是一個篩選準則，會從結果中排除專案。 每個 `join` 子句會比較來源序列的指定索引鍵與另一個序列的索引鍵，並產生相符的配對。 每個 `orderby` 子句都會根據指定的準則重新排序專案。最後的 `select` 或 `group` 子句會根據範圍變數來指定結果的形狀。 最後，`into` 子句可以在後續查詢中將一個查詢的結果視為產生器，藉以「拼接」查詢。

### <a name="ambiguities-in-query-expressions"></a>查詢運算式中的多義性

查詢運算式包含多個「內容關鍵字」，也就是在指定內容中有特殊意義的識別碼。 具體而言，這些是 `from`、`where`、`join`、`on`、`equals`、`into`、`let`、`orderby`、`ascending`、`descending`、`select`、`group` 和 `by`。 為了避免因混合使用這些識別碼做為關鍵字或簡單名稱而造成的查詢運算式不明確，這些識別碼會在查詢運算式中的任何位置發生時被視為關鍵字。

基於此目的，查詢運算式是以 "`from identifier`" 開頭，後面接著任何 token （"`;`"、"`=`" 或 "`,`" 除外）的運算式。

為了在查詢運算式中使用這些單字做為識別碼，它們前面可以加上 "`@`" （[識別碼](lexical-structure.md#identifiers)）。

### <a name="query-expression-translation"></a>查詢運算式轉譯

此C#語言不會指定查詢運算式的執行語法。 相反地，查詢運算式會轉譯成符合*查詢運算式模式*之方法的調用（[查詢運算式模式](expressions.md#the-query-expression-pattern)）。 具體而言，查詢運算式會轉譯為名為 `Where`、`Select`、`SelectMany`、`Join`、`GroupJoin`、`OrderBy`、`OrderByDescending`、`ThenBy`、`ThenByDescending`、`GroupBy`和 `Cast`的方法調用。這些方法預期會有特定的簽章和結果類型，如[查詢運算式模式](expressions.md#the-query-expression-pattern)中所述。 這些方法可以是所查詢物件的實例方法，或是物件外部的擴充方法，並會執行查詢的實際執行。

從查詢運算式到方法調用的轉譯，是在執行任何類型系結或多載解析之前發生的語法對應。 翻譯保證的語法正確，但不保證會產生語義正確C#的程式碼。 在查詢運算式的轉譯之後，所產生的方法調用會當做一般的方法叫用來處理，而這可能會發現錯誤，例如，如果方法不存在、引數的類型錯誤，或方法為泛型，則為。型別推斷失敗。

查詢運算式的處理方式是重複套用下列翻譯，直到無法進一步縮減為止。 翻譯會依照應用程式的順序列出：每一節都假設先前章節中的翻譯已徹底執行，一旦用盡後，就不會在處理相同的查詢運算式時再次使用區段。

查詢運算式中不允許指派至範圍變數。 C#不過，允許不一定會強制執行這種限制，因為這有時候可能無法使用此處所提供的語法轉譯配置。

某些翻譯會插入範圍變數，並以 `*`表示的透明識別碼。 透明識別碼的特殊屬性會在[透明識別碼](expressions.md#transparent-identifiers)中進一步討論。

#### <a name="select-and-groupby-clauses-with-continuations"></a>具有接續的 Select 和 groupby 子句

具有接續的查詢運算式
```csharp
from ... into x ...
```
會轉譯為
```csharp
from x in ( from ... ) ...
```

下列各節中的翻譯假設查詢沒有 `into` 接續。

範例
```csharp
from c in customers
group c by c.Country into g
select new { Country = g.Key, CustCount = g.Count() }
```
會轉譯為
```csharp
from g in
    from c in customers
    group c by c.Country
select new { Country = g.Key, CustCount = g.Count() }
```
最終的轉譯是
```csharp
customers.
GroupBy(c => c.Country).
Select(g => new { Country = g.Key, CustCount = g.Count() })
```

#### <a name="explicit-range-variable-types"></a>明確範圍變數類型

明確指定範圍變數類型的 `from` 子句
```csharp
from T x in e
```
會轉譯為
```csharp
from x in ( e ) . Cast < T > ( )
```

明確指定範圍變數類型的 `join` 子句
```csharp
join T x in e on k1 equals k2
```
會轉譯為
```csharp
join x in ( e ) . Cast < T > ( ) on k1 equals k2
```

下列各節中的翻譯假設查詢沒有明確的範圍變數類型。

範例
```csharp
from Customer c in customers
where c.City == "London"
select c
```
會轉譯為
```csharp
from c in customers.Cast<Customer>()
where c.City == "London"
select c
```
最終的轉譯是
```csharp
customers.
Cast<Customer>().
Where(c => c.City == "London")
```

明確範圍變數類型適用于查詢實作為非泛型 `IEnumerable` 介面的集合，而不是泛型 `IEnumerable<T>` 介面。 在上述範例中，如果 `customers` 的類型 `ArrayList`，就會發生這種情況。

#### <a name="degenerate-query-expressions"></a>退化查詢運算式

表單的查詢運算式
```csharp
from x in e select x
```
會轉譯為
```csharp
( e ) . Select ( x => x )
```

範例
```csharp
from c in customers
select c
```
會轉譯為
```csharp
customers.Select(c => c)
```

「退化查詢運算式」（完整）會選取來源的元素。 翻譯的較新階段會移除其他轉譯步驟引進的退化查詢，方法是將它們取代為其來源。 不過，請務必確保查詢運算式的結果永遠不是來源物件本身，因為這會向查詢的用戶端顯示來源的類型和識別。 因此，此步驟會藉由明確地在來源上呼叫 `Select`，來保護直接寫入原始程式碼的退化查詢。 然後，由 `Select` 和其他查詢運算子的實作者負責，以確保這些方法永遠不會傳回來源物件本身。

#### <a name="from-let-where-join-and-orderby-clauses"></a>From、let、where、join 和 orderby 子句

含有第二個 `from` 子句且後面接著 `select` 子句的查詢運算式
```csharp
from x1 in e1
from x2 in e2
select v
```
會轉譯為
```csharp
( e1 ) . SelectMany( x1 => e2 , ( x1 , x2 ) => v )
```

含有第二個 `from` 子句的查詢運算式，後面接著 `select` 子句以外的專案：

```csharp
from x1 in e1
from x2 in e2
...
```
會轉譯為
```csharp
from * in ( e1 ) . SelectMany( x1 => e2 , ( x1 , x2 ) => new { x1 , x2 } )
...
```

具有 `let` 子句的查詢運算式
```csharp
from x in e
let y = f
...
```
會轉譯為
```csharp
from * in ( e ) . Select ( x => new { x , y = f } )
...
```

具有 `where` 子句的查詢運算式
```csharp
from x in e
where f
...
```
會轉譯為
```csharp
from x in ( e ) . Where ( x => f )
...
```

具有 `join` 子句的查詢運算式，而不含 `into` 後面接著 `select` 子句
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2
select v
```
會轉譯為
```csharp
( e1 ) . Join( e2 , x1 => k1 , x2 => k2 , ( x1 , x2 ) => v )
```

具有 `join` 子句的查詢運算式，但後面沒有 `select` 子句以外的 `into`
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2
...
```
會轉譯為
```csharp
from * in ( e1 ) . Join( e2 , x1 => k1 , x2 => k2 , ( x1 , x2 ) => new { x1 , x2 })
...
```

具有 `join` 子句的查詢運算式，其中 `into` 後面接著 `select` 子句
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2 into g
select v
```
會轉譯為
```csharp
( e1 ) . GroupJoin( e2 , x1 => k1 , x2 => k2 , ( x1 , g ) => v )
```

具有 `join` 子句的查詢運算式，`into` 後面接著 `select` 子句以外的專案
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2 into g
...
```
會轉譯為
```csharp
from * in ( e1 ) . GroupJoin( e2 , x1 => k1 , x2 => k2 , ( x1 , g ) => new { x1 , g })
...
```

具有 `orderby` 子句的查詢運算式
```csharp
from x in e
orderby k1 , k2 , ..., kn
...
```
會轉譯為
```csharp
from x in ( e ) . 
OrderBy ( x => k1 ) . 
ThenBy ( x => k2 ) .
... .
ThenBy ( x => kn )
...
```

如果排序子句指定 `descending` 方向指標，則會改為產生 `OrderByDescending` 或 `ThenByDescending` 的調用。

下列翻譯假設沒有任何 `let`、`where`、`join` 或 `orderby` 子句，而且每個查詢運算式中不會超過一個初始 `from` 子句。

範例
```csharp
from c in customers
from o in c.Orders
select new { c.Name, o.OrderID, o.Total }
```
會轉譯為
```csharp
customers.
SelectMany(c => c.Orders,
     (c,o) => new { c.Name, o.OrderID, o.Total }
)
```

範例
```csharp
from c in customers
from o in c.Orders
orderby o.Total descending
select new { c.Name, o.OrderID, o.Total }
```
會轉譯為
```csharp
from * in customers.
    SelectMany(c => c.Orders, (c,o) => new { c, o })
orderby o.Total descending
select new { c.Name, o.OrderID, o.Total }
```
最終的轉譯是
```csharp
customers.
SelectMany(c => c.Orders, (c,o) => new { c, o }).
OrderByDescending(x => x.o.Total).
Select(x => new { x.c.Name, x.o.OrderID, x.o.Total })
```
其中 `x` 是編譯器產生的識別碼，在其他情況下不可見且無法存取。

範例
```csharp
from o in orders
let t = o.Details.Sum(d => d.UnitPrice * d.Quantity)
where t >= 1000
select new { o.OrderID, Total = t }
```
會轉譯為
```csharp
from * in orders.
    Select(o => new { o, t = o.Details.Sum(d => d.UnitPrice * d.Quantity) })
where t >= 1000 
select new { o.OrderID, Total = t }
```
最終的轉譯是
```csharp
orders.
Select(o => new { o, t = o.Details.Sum(d => d.UnitPrice * d.Quantity) }).
Where(x => x.t >= 1000).
Select(x => new { x.o.OrderID, Total = x.t })
```
其中 `x` 是編譯器產生的識別碼，在其他情況下不可見且無法存取。

範例
```csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID
select new { c.Name, o.OrderDate, o.Total }
```
會轉譯為
```csharp
customers.Join(orders, c => c.CustomerID, o => o.CustomerID,
    (c, o) => new { c.Name, o.OrderDate, o.Total })
```

範例
```csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID into co
let n = co.Count()
where n >= 10
select new { c.Name, OrderCount = n }
```
會轉譯為
```csharp
from * in customers.
    GroupJoin(orders, c => c.CustomerID, o => o.CustomerID,
        (c, co) => new { c, co })
let n = co.Count()
where n >= 10 
select new { c.Name, OrderCount = n }
```
最終的轉譯是
```csharp
customers.
GroupJoin(orders, c => c.CustomerID, o => o.CustomerID,
    (c, co) => new { c, co }).
Select(x => new { x, n = x.co.Count() }).
Where(y => y.n >= 10).
Select(y => new { y.x.c.Name, OrderCount = y.n)
```
其中 `x` 和 `y` 是編譯器產生的識別碼，在其他情況下不可見且無法存取。

範例
```csharp
from o in orders
orderby o.Customer.Name, o.Total descending
select o
```
具有最終翻譯
```csharp
orders.
OrderBy(o => o.Customer.Name).
ThenByDescending(o => o.Total)
```

#### <a name="select-clauses"></a>選取子句

表單的查詢運算式
```csharp
from x in e select v
```
會轉譯為
```csharp
( e ) . Select ( x => v )
```
除了 v 是識別碼 x 以外，翻譯只是
```csharp
( e )
```

例如
```csharp
from c in customers.Where(c => c.City == "London")
select c
```
只會轉譯成
```csharp
customers.Where(c => c.City == "London")
```

#### <a name="groupby-clauses"></a>Groupby 子句

表單的查詢運算式
```csharp
from x in e group v by k
```
會轉譯為
```csharp
( e ) . GroupBy ( x => k , x => v )
```
除了 v 為識別碼 x 以外，轉譯為
```csharp
( e ) . GroupBy ( x => k )
```

範例
```csharp
from c in customers
group c.Name by c.Country
```
會轉譯為
```csharp
customers.
GroupBy(c => c.Country, c => c.Name)
```

#### <a name="transparent-identifiers"></a>透明識別碼

某些翻譯會插入範圍變數，並以 `*`表示的***透明識別碼***。 透明識別碼不是適當的語言功能;它們只存在於查詢運算式轉譯程式中的中繼步驟。

當查詢轉譯插入透明識別碼時，進一步的轉譯步驟會將透明識別碼傳播至匿名函式和匿名物件初始化運算式。 在這些內容中，透明識別碼具有下列行為：

*  當透明識別碼當做匿名函式中的參數出現時，相關聯匿名型別的成員會自動在匿名函式主體的範圍內。
*  當具有透明識別碼的成員在範圍內時，該成員的成員也會在範圍中。
*  當透明識別碼當做匿名物件初始化運算式中的成員宣告子出現時，它會引進具有透明識別碼的成員。
*  在上述的轉譯步驟中，透明識別碼一律會與匿名型別一起導入，並將多個範圍變數當做單一物件的成員來捕捉。 的執行C#允許使用與匿名型別不同的機制，將多個範圍變數群組在一起。 下列轉譯範例假設使用匿名型別，並顯示如何將透明識別碼轉譯出來。

範例
```csharp
from c in customers
from o in c.Orders
orderby o.Total descending
select new { c.Name, o.Total }
```
會轉譯為
```csharp
from * in customers.
    SelectMany(c => c.Orders, (c,o) => new { c, o })
orderby o.Total descending
select new { c.Name, o.Total }
```

這會進一步轉譯成
```csharp
customers.
SelectMany(c => c.Orders, (c,o) => new { c, o }).
OrderByDescending(* => o.Total).
Select(* => new { c.Name, o.Total })
```
在清除透明識別碼時，相當於
```csharp
customers.
SelectMany(c => c.Orders, (c,o) => new { c, o }).
OrderByDescending(x => x.o.Total).
Select(x => new { x.c.Name, x.o.Total })
```
其中 `x` 是編譯器產生的識別碼，在其他情況下不可見且無法存取。

範例
```csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID
join d in details on o.OrderID equals d.OrderID
join p in products on d.ProductID equals p.ProductID
select new { c.Name, o.OrderDate, p.ProductName }
```
會轉譯為
```csharp
from * in customers.
    Join(orders, c => c.CustomerID, o => o.CustomerID, 
        (c, o) => new { c, o })
join d in details on o.OrderID equals d.OrderID
join p in products on d.ProductID equals p.ProductID
select new { c.Name, o.OrderDate, p.ProductName }
```
進一步縮減為
```csharp
customers.
Join(orders, c => c.CustomerID, o => o.CustomerID, (c, o) => new { c, o }).
Join(details, * => o.OrderID, d => d.OrderID, (*, d) => new { *, d }).
Join(products, * => d.ProductID, p => p.ProductID, (*, p) => new { *, p }).
Select(* => new { c.Name, o.OrderDate, p.ProductName })
```
最終的轉譯是
```csharp
customers.
Join(orders, c => c.CustomerID, o => o.CustomerID,
    (c, o) => new { c, o }).
Join(details, x => x.o.OrderID, d => d.OrderID,
    (x, d) => new { x, d }).
Join(products, y => y.d.ProductID, p => p.ProductID,
    (y, p) => new { y, p }).
Select(z => new { z.y.x.c.Name, z.y.x.o.OrderDate, z.p.ProductName })
```
其中 `x`、`y`和 `z` 是編譯器產生的識別碼，在其他情況下不可見且無法存取。

### <a name="the-query-expression-pattern"></a>查詢運算式模式

***查詢運算式模式***會建立一種方法模式，讓型別可以實作為支援查詢運算式。 由於查詢運算式會透過語法對應轉譯為方法調用，因此，型別在實作為查詢運算式模式的方式上具有相當大的彈性。 例如，模式的方法可以實作為實例方法或擴充方法，因為兩者具有相同的調用語法，而且方法可以要求委派或運算式樹狀架構，因為匿名函式可轉換成兩者。

支援查詢運算式模式的泛型型別 `C<T>` 建議的圖形如下所示。 泛型型別是用來說明參數和結果類型之間的適當關聯性，但也可以為非泛型型別執行模式。

```csharp
delegate R Func<T1,R>(T1 arg1);

delegate R Func<T1,T2,R>(T1 arg1, T2 arg2);

class C
{
    public C<T> Cast<T>();
}

class C<T> : C
{
    public C<T> Where(Func<T,bool> predicate);

    public C<U> Select<U>(Func<T,U> selector);

    public C<V> SelectMany<U,V>(Func<T,C<U>> selector,
        Func<T,U,V> resultSelector);

    public C<V> Join<U,K,V>(C<U> inner, Func<T,K> outerKeySelector,
        Func<U,K> innerKeySelector, Func<T,U,V> resultSelector);

    public C<V> GroupJoin<U,K,V>(C<U> inner, Func<T,K> outerKeySelector,
        Func<U,K> innerKeySelector, Func<T,C<U>,V> resultSelector);

    public O<T> OrderBy<K>(Func<T,K> keySelector);

    public O<T> OrderByDescending<K>(Func<T,K> keySelector);

    public C<G<K,T>> GroupBy<K>(Func<T,K> keySelector);

    public C<G<K,E>> GroupBy<K,E>(Func<T,K> keySelector,
        Func<T,E> elementSelector);
}

class O<T> : C<T>
{
    public O<T> ThenBy<K>(Func<T,K> keySelector);

    public O<T> ThenByDescending<K>(Func<T,K> keySelector);
}

class G<K,T> : C<T>
{
    public K Key { get; }
}
```

上述方法會使用泛型委派類型 `Func<T1,R>` 和 `Func<T1,T2,R>`，但它們也可以使用其他委派或運算式樹狀架構類型，並在參數和結果類型中具有相同的關聯性。

請注意 `C<T>` 和 `O<T>` 之間的建議關聯性，這可確保 `ThenBy` 和 `ThenByDescending` 方法僅適用于 `OrderBy` 或 `OrderByDescending`的結果。 另請注意 `GroupBy` 結果的建議圖形--一連串序列，其中每個內部序列都有額外的 `Key` 屬性。

`System.Linq` 命名空間會針對任何實作為 `System.Collections.Generic.IEnumerable<T>` 介面的型別，提供查詢運算子模式的執行。

## <a name="assignment-operators"></a>指派運算子

指派運算子會將新值指派給變數、屬性、事件或索引子元素。

```antlr
assignment
    : unary_expression assignment_operator expression
    ;

assignment_operator
    : '='
    | '+='
    | '-='
    | '*='
    | '/='
    | '%='
    | '&='
    | '|='
    | '^='
    | '<<='
    | right_shift_assignment
    ;
```

指派的左運算元必須是分類為變數、屬性存取、索引子存取或事件存取的運算式。

`=` 運算子稱為「***簡單指派運算子***」。 它會將右運算元的值指派給左運算元所指定的變數、屬性或索引子元素。 簡單指派運算子的左運算元可能不是事件存取權（除非如[類似欄位的事件](classes.md#field-like-events)中所述）。 簡單指派運算子會在[簡單指派](expressions.md#simple-assignment)中說明。

`=` 運算子以外的指派運算子稱為***複合指派運算子***。 這些運算子會對兩個運算元執行指示的作業，然後將產生的值指派給左運算元所指定的變數、屬性或索引子元素。 複合指派中會描述複合指派[運算子。](expressions.md#compound-assignment)

以事件存取運算式做為左運算元的 `+=` 和 `-=` 運算子，稱為「*事件指派運算子*」。 沒有其他指派運算子有效，並以事件存取做為左運算元。 事件指派運算子會在[事件指派](expressions.md#event-assignment)中說明。

指派運算子是靠右關聯的，這表示作業會從右至左分組。 例如，表單 `a = b = c` 的運算式會評估為 `a = (b = c)`。

### <a name="simple-assignment"></a>單一指派

`=` 運算子稱為「簡單指派運算子」。

如果簡單指派的左運算元的格式為 `E.P` 或 `E[Ei]`，其中 `E` 的編譯時期類型 `dynamic`，則指派會動態繫結（[動態](expressions.md#dynamic-binding)系結）。 在此情況下，會 `dynamic`指派運算式的編譯時期類型，並根據執行時間類型的 `E`，在執行時間進行下面所述的解析。

在簡單的指派中，右運算元必須是可隱含轉換為左運算元類型的運算式。 作業會將右運算元的值指派給左運算元所指定的變數、屬性或索引子元素。

簡單指派運算式的結果就是指派給左運算元的值。 結果的類型與左運算元相同，而且一律會分類為值。

如果左運算元是屬性或索引子存取，則屬性或索引子必須具有 `set` 存取子。 如果不是這種情況，就會發生系結時錯誤。

`x = y` 表單的簡單指派的執行時間處理是由下列步驟所組成：

*  如果 `x` 分類為變數：
   * 評估 `x` 以產生變數。
   * 系統會評估 `y`，並在必要時，透過隱含轉換（[隱含](conversions.md#implicit-conversions)轉換）轉換成 `x` 的類型。
   * 如果 `x` 所指定的變數是*reference_type*的陣列元素，則會執行執行時間檢查，以確保為 `y` 計算的值與 `x` 為元素的陣列實例相容。 如果 `y` 是 `null`，或是隱含的參考轉換（[隱含的參考](conversions.md#implicit-reference-conversions)轉換）是從所 `y` 參考之實例的實際型別（包含 `x`的陣列實例的實際元素型別）存在，則檢查成功。 否則會擲回 `System.ArrayTypeMismatchException`。
   * 評估和轉換 `y` 所產生的值會儲存在評估 `x`所指定的位置。
*  如果 `x` 分類為屬性或索引子存取：
   * 實例運算式（如果 `x` 不是 `static`），而且會評估與 `x` 相關聯的引數清單（如果 `x` 是索引子存取），而結果會用於後續的 `set` 存取子調用中。
   * 系統會評估 `y`，並在必要時，透過隱含轉換（[隱含](conversions.md#implicit-conversions)轉換）轉換成 `x` 的類型。
   * `x` 的 `set` 存取子會使用針對 `y` 計算的值做為其 `value` 引數來叫用。

陣列的共同變異數規則（[陣列共變數](arrays.md#array-covariance)）允許陣列類型的值 `A[]` 為數組 `B[]`類型之實例的參考，但前提是從 `B` 到 `A`會有隱含的參考轉換。 由於這些規則的緣故，指派給*reference_type*的陣列元素需要執行時間檢查，以確保所指派的值與陣列實例相容。 在範例中
```csharp
string[] sa = new string[10];
object[] oa = sa;

oa[0] = null;               // Ok
oa[1] = "Hello";            // Ok
oa[2] = new ArrayList();    // ArrayTypeMismatchException
```
最後一次指派會導致 `System.ArrayTypeMismatchException` 擲回，因為 `ArrayList` 的實例不能儲存在 `string[]`的元素中。

當*struct_type*中宣告的屬性或索引子是指派的目標時，與屬性或索引子存取相關聯的實例運算式必須分類為變數。 如果實例運算式分類為值，則會發生系結時錯誤。 因為有[成員存取權](expressions.md#member-access)，所以相同的規則也適用于欄位。

假設宣告如下：
```csharp
struct Point
{
    int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int X {
        get { return x; }
        set { x = value; }
    }

    public int Y {
        get { return y; }
        set { y = value; }
    }
}

struct Rectangle
{
    Point a, b;

    public Rectangle(Point a, Point b) {
        this.a = a;
        this.b = b;
    }

    public Point A {
        get { return a; }
        set { a = value; }
    }

    public Point B {
        get { return b; }
        set { b = value; }
    }
}
```
在範例中
```csharp
Point p = new Point();
p.X = 100;
p.Y = 100;
Rectangle r = new Rectangle();
r.A = new Point(10, 10);
r.B = p;
```
允許 `p.X`、`p.Y`、`r.A`和 `r.B` 的指派，因為 `p` 和 `r` 是變數。 不過，在此範例中
```csharp
Rectangle r = new Rectangle();
r.A.X = 10;
r.A.Y = 10;
r.B.X = 100;
r.B.Y = 100;
```
指派全都無效，因為 `r.A` 且 `r.B` 不是變數。

### <a name="compound-assignment"></a>複合指派

如果複合指派的左運算元的格式為 `E.P` 或 `E[Ei]`，其中 `E` 的編譯時期類型 `dynamic`，則指派會動態繫結（[動態](expressions.md#dynamic-binding)系結）。 在此情況下，會 `dynamic`指派運算式的編譯時期類型，並根據執行時間類型的 `E`，在執行時間進行下面所述的解析。

`x op= y` 格式的作業會藉由套用二元運算子多載解析（[二元運算子](expressions.md#binary-operator-overload-resolution)多載解析）來處理，就如同 `x op y`寫入作業一樣。 如此一來，

*  如果選取之運算子的傳回型別可以隱含地轉換成 `x`的型別，則會將作業評估為 `x = x op y`，但只會評估 `x` 一次。
*  否則，如果選取的運算子是預先定義的運算子，而且選取之運算子的傳回類型明確地轉換成 `x`的類型，而且如果 `y` 可以隱含地轉換成 `x` 的類型，或運算子是移位運算子，則會將運算評估為 `x = (T)(x op y)`，其中 `T` 只會評估一次。
*  否則，複合指派會無效，而且會發生系結時錯誤。

「僅評估一次」一詞表示在評估 `x op y`時，`x` 的任何組成運算式的結果都會暫時儲存，然後在執行指派給 `x`時重複使用。 例如，在指派 `A()[B()] += C()`中，其中 `A` 是傳回 `int[]`的方法，而 `B` 和 `C` 是傳回 `int`的方法，則只會叫用一次方法，順序 `A`，`B`，`C`。

當複合指派的左運算元是屬性存取或索引子存取時，屬性或索引子必須同時具有 `get` 存取子和 `set` 存取子。 如果不是這種情況，就會發生系結時錯誤。

上述第二個規則允許 `x op= y` 在特定內容中評估為 `x = (T)(x op y)`。 當左運算元的類型是 `sbyte`、`byte`、`short`、`ushort`或 `char`時，此規則會存在，讓預先定義的運算子可以當做複合運算子使用。 即使這兩個引數都屬於其中一種類型，預先定義的運算子還是會產生類型 `int`的結果，如[二進位數值升級](expressions.md#binary-numeric-promotions)中所述。 因此，在沒有轉換的情況下，不可能將結果指派給左運算元。

針對預先定義的運算子，規則的直覺效果是，如果同時允許 `x op y` 和 `x = y`，就會允許 `x op= y`。 在範例中
```csharp
byte b = 0;
char ch = '\0';
int i = 0;

b += 1;             // Ok
b += 1000;          // Error, b = 1000 not permitted
b += i;             // Error, b = i not permitted
b += (byte)i;       // Ok

ch += 1;            // Error, ch = 1 not permitted
ch += (char)1;      // Ok
```
每個錯誤的直覺原因是對應的簡單指派也會發生錯誤。

這也表示複合指派作業支援提升作業。 在範例中
```csharp
int? i = 0;
i += 1;             // Ok
```
使用的提升運算子 `+(int?,int?)`。

### <a name="event-assignment"></a>事件指派

如果 `+=` 或 `-=` 運算子的左運算元分類為事件存取，則會評估運算式，如下所示：

*  會評估事件存取的實例運算式（如果有的話）。
*  系統會評估 `+=` 或 `-=` 運算子的右運算元，並在必要時，透過隱含轉換（[隱含](conversions.md#implicit-conversions)轉換）轉換為左運算元的類型。
*  系統會叫用事件的事件存取子，其中包含由右運算元組成的引數清單、在評估之後，以及必要的轉換。 如果 `+=`運算子，則會叫用 `add` 存取子;如果 `-=`運算子，則會叫用 `remove` 存取子。

事件指派運算式不會產生值。 因此，事件指派運算式只在*statement_expression* （[expression 語句](statements.md#expression-statements)）的內容中有效。

## <a name="expression"></a>運算式

*運算式*可以是*non_assignment_expression*或*指派*。

```antlr
expression
    : non_assignment_expression
    | assignment
    ;

non_assignment_expression
    : conditional_expression
    | lambda_expression
    | query_expression
    ;
```

## <a name="constant-expressions"></a>常數運算式

*Constant_expression*是可以在編譯時期完整評估的運算式。

```antlr
constant_expression
    : expression
    ;
```

常數運算式必須是 `null` 常值，或具有下列其中一種類型的值： `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`char`、`float`、`double`、`decimal`、`bool`、`object`、`string`或任何列舉類型。 常數運算式中只允許下列結構：

*  常值（包括 `null` 常值）。
*  類別和結構類型 `const` 成員的參考。
*  列舉類型之成員的參考。
*  `const` 參數或區域變數的參考
*  以括弧括住的子運算式，本身就是常數運算式。
*  Cast 運算式，前提是目標型別是上列其中一種類型。
*  `checked` 和 `unchecked` 運算式
*  預設值運算式
*  Nameof 運算式
*  預先定義的 `+`、`-`、`!`和 `~` 一元運算子。
*  預先定義的 `+`、`-`、`*`、`/`、`%`、`<<`、`>>`、`&`、`|`、`^`、`&&`、`||`、`==`、`!=`、`<`、`>`、`<=`和 `>=` 二元運算子，前提是每個運算元都是上列的類型。
*  `?:` 條件運算子。

常數運算式中允許下列轉換：

*  身分識別轉換
*  數值轉換
*  列舉轉換
*  常數運算式轉換
*  隱含和明確的參考轉換，前提是轉換的來源是會評估為 null 值的常數運算式。

常數運算式中不允許其他轉換，包括非 null 值的裝箱、取消裝箱和隱含參考轉換。 例如：
```csharp
class C {
    const object i = 5;         // error: boxing conversion not permitted
    const object str = "hello"; // error: implicit reference conversion
}
```
i 的初始化是錯誤的，因為需要進行裝箱轉換。 Str 的初始化是錯誤，因為需要非 null 值的隱含參考轉換。

每當運算式滿足上述需求時，就會在編譯時期評估運算式。 即使運算式是包含非常數結構之較大運算式的子運算式，也是如此。

常數運算式的編譯時間評估會使用與非常數運算式的執行時間評估相同的規則，但在執行時間評估會擲回例外狀況的情況下，編譯時間評估會導致發生編譯時期錯誤。

除非常數運算式明確地放在 `unchecked` 內容中，否則在運算式的編譯時間評估期間，整數類型算術作業和轉換期間發生的溢位，一律會導致編譯時期錯誤（[常數運算式](expressions.md#constant-expressions)）。

常數運算式會出現在下面所列的內容中。 在這些內容中，如果無法在編譯時期完整評估運算式，就會發生編譯時期錯誤。

*  常數宣告（[常數](classes.md#constants)）。
*  列舉成員宣告（[列舉成員](enums.md#enum-members)）。
*  正式參數清單的預設引數（[方法參數](classes.md#method-parameters)）
*  `switch` 語句的 `case` 標籤（[switch 語句](statements.md#the-switch-statement)）。
*  `goto case` 語句（[goto 語句](statements.md#the-goto-statement)）。
*  陣列建立運算式中的維度長度（[陣列建立運算式](expressions.md#array-creation-expressions)），其中包含初始化運算式。
*  屬性（[屬性](attributes.md)）。

隱含的常數運算式轉換（[隱含常數運算式轉換](conversions.md#implicit-constant-expression-conversions)）允許將類型 `int` 的常數運算式轉換成 `sbyte`、`byte`、`short`、`ushort`、`uint`或 `ulong`，前提是常數運算式的值在目的地類型的範圍內。

## <a name="boolean-expressions"></a>布林運算式

*Boolean_expression*是產生類型 `bool`結果的運算式;直接或透過應用程式的 `operator true`，如下所指定的特定內容。

```antlr
boolean_expression
    : expression
    ;
```

*If_statement* （[if 語句](statements.md#the-if-statement)）、 *while_statement* （[while 語句](statements.md#the-while-statement)）、 *do_statement* （[do 語句](statements.md#the-do-statement)）或*for_statement* （[for 語句](statements.md#the-for-statement)）的控制條件運算式是*boolean_expression*。 `?:` 運算子（[條件運算子](expressions.md#conditional-operator)）的控制條件運算式會遵循與*boolean_expression*相同的規則，但會將運算子優先順序的原因分類為*conditional_or_expression*。

需要*boolean_expression* `E`，才能產生類型 `bool`的值，如下所示：

*  如果 `E` 可以隱含地轉換成 `bool` 則在執行時間會套用隱含轉換。
*  否則，會使用一元運算子多載解析（[一元運算子](expressions.md#unary-operator-overload-resolution)多載解析）來尋找 `E`上運算子 `true` 的唯一最佳執行，而該實作為在執行時間套用。
*  如果找不到這類運算子，則會發生系結時錯誤。

[資料庫布林](structs.md#database-boolean-type)型別中的 `DBBool` 結構型別提供了實 `operator true` 和 `operator false`的型別範例。
