# <a name="expressions"></a>運算式

運算式是運算子和運算元的序列。 這一章中定義的語法，順序評估運算元和運算子和運算式的意義。

## <a name="expression-classifications"></a>運算式分類

運算式分類為下列其中一項：

*  一個值。 每個值都有關聯型別。
*  變數中。 每個變數都有關聯的型別，也就是變數的宣告型別。
*  命名空間。 此分類的運算式只能出現的左手邊*member_access* ([成員存取](expressions.md#member-access))。 在任何其他內容中，運算式分類為命名空間會造成編譯時期錯誤。
*  類型。 此分類的運算式只能出現的左手邊*member_access* ([成員存取](expressions.md#member-access))，或做為運算元`as`運算子 ([As 運算子](expressions.md#the-as-operator))，則`is`運算子 ([是運算子](expressions.md#the-is-operator))，或有`typeof`運算子 ([typeof 運算子](expressions.md#the-typeof-operator))。 在任何其他內容中，歸類為類型的運算式會導致編譯時期錯誤。
*  方法群組，也就是一組多載的方法所產生的成員查閱 ([成員查閱](expressions.md#member-lookup))。 方法群組可能會有一個相關聯的執行個體運算式和相關聯的類型引數清單。 叫用執行個體方法時，該執行個體運算式的評估結果會成為所代表的執行個體`this`([這項存取](expressions.md#this-access))。 方法會允許群組中*invocation_expression* ([引動過程運算式](expressions.md#invocation-expressions))，則*delegate_creation_expression* ([委派建立運算式](expressions.md#delegate-creation-expressions)) 以及左手邊的運算子，且可以隱含地轉換成相容的委派類型 ([方法群組轉換](conversions.md#method-group-conversions))。 在任何其他內容中，分類為方法群組運算式會導致編譯時期錯誤。
*  Null 常值。 此分類的運算式可以隱含地轉換為參考型別或可為 null 的型別。
*  匿名函式。 此分類的運算式可以隱含地轉換為相容的委派型別或運算式樹狀架構型別。
*  屬性存取。 每個屬性存取具有相關聯的類型，也就是屬性的型別。 此外，屬性存取可能會有相關聯的執行個體上的運算式。 當存取子 (`get`或`set`區塊) 的執行個體叫用屬性存取、 執行個體運算式的評估結果會成為所代表的執行個體`this`([此存取權](expressions.md#this-access))。
*  事件的存取。 每個事件存取具有相關聯的類型，也就是事件的型別。 此外，事件存取可能會有一個相關聯的執行個體運算式。 事件存取可能會顯示為左運算元`+=`並`-=`運算子 ([事件指派](expressions.md#event-assignment))。 在任何其他內容中，歸類為事件存取的運算式會導致編譯時期錯誤。
*  索引子存取。 每個索引子存取具有相關聯的類型，也就是索引子的元素型別。 此外，索引子存取有相關聯的執行個體運算式和相關聯的引數清單。 當存取子 (`get`或`set`區塊) 的索引子叫用的存取，該執行個體運算式的評估結果會成為所代表的執行個體`this`([此存取權](expressions.md#this-access))，和結果評估引數清單，就會變成引動過程的參數清單。
*  沒有項目。 此運算式就會發生叫用方法的傳回類型為`void`。 將分類為不只是有效的內容中的運算式*statement_expression* ([運算式陳述式](statements.md#expression-statements))。

運算式的最終結果不命名空間、 類型、 方法群組或事件存取。 相反地，如先前所述，這些類別的運算式都是只允許在特定內容的中繼建構。

屬性存取或索引子存取一律分類為值所執行的引動過程*get 存取子*或*set 存取子*。 特定的存取子取決於屬性或索引子存取的內容：如果存取指派，目標*set 存取子*會叫用來指派新值 ([簡單指派](expressions.md#simple-assignment))。 否則，請*get 存取子*會叫用來取得目前的值 ([運算式的值](expressions.md#values-of-expressions))。

### <a name="values-of-expressions"></a>運算式的值

大部分的包含運算式的結構，最後都會要求運算式表示***值***。 在此情況下，如果實際的運算式表示命名空間、 類型、 方法群組，或執行任何動作，就會發生編譯時期錯誤。 不過，如果運算式表示屬性存取、 索引子存取或變數，就會隱含取代屬性、 索引子或變數的值：

*  變數的值是只將目前儲存變數所識別之儲存體位置中的值。 變數必須被視為已明確指派 ([明確指派](variables.md#definite-assignment)) 才可以取得其值，或否則會發生編譯時期錯誤。
*  屬性存取運算式的值藉由叫用*get 存取子*的屬性。 如果屬性不含任何*get 存取子*，就會發生編譯時期錯誤。 否則，函式成員引動過程 ([編譯時期檢查動態的多載解析](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) 執行時，和引動過程的結果會成為屬性存取運算式的值。
*  索引子存取運算式的值藉由叫用*get 存取子*的索引子。 如果索引子不含任何*get 存取子*，就會發生編譯時期錯誤。 否則函式成員引動過程 ([編譯時期檢查動態的多載解析](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) 會使用引數來執行清單與運算式相關聯索引子的存取，並叫用的結果會成為值索引子存取運算式中。

## <a name="static-and-dynamic-binding"></a>靜態和動態繫結

判斷作業的類型或值的引數、 運算元 （接收者） 組成的運算式為基礎的意義的程序通常稱為***繫結***。 執行個體方法呼叫的意義取決於接收者和引數的型別。 運算子的意義取決於其運算元的類型。

在 C# 中作業的意義通常用來決定在編譯時期，根據其構成的運算式的編譯時間類型。 同樣地，如果運算式包含錯誤，錯誤會偵測到並由編譯器所回報。 這種方法就所謂***靜態繫結***。

不過，如果運算式是動態運算式 (也就是具有類型`dynamic`) 這表示它所參與的任何繫結應該根據其執行階段類型 （也就是在執行階段所代表的是物件的實際類型），而不是在型別編譯時間。 這類作業的繫結會因此延遲，直到程式執行期間要執行此作業的時間。 這指***動態繫結***。

動態繫結作業，幾乎沒有任何檢查是由編譯器執行。 改為執行階段繫結時，為在執行階段的例外狀況會回報錯誤。

繫結受限於 C# 中的下列作業：

*  成員存取： `e.M`
*  方法引動過程： `e.M(e1, ..., eN)`
*  委派引動過程：`e(e1, ..., eN)`
*  項目存取權： `e[e1, ..., eN]`
*  建立物件： `new C(e1, ..., eN)`
*  多載一元運算子： `+`， `-`， `!`， `~`， `++`， `--`， `true`， `false`
*  多載二元運算子： `+`， `-`， `*`， `/`， `%`， `&`， `&&`， `|`， `||`， `??`， `^`， `<<`, `>>`, `==`,`!=`, `>`, `<`, `>=`, `<=`
*  指派運算子： `=`， `+=`， `-=`， `*=`， `/=`， `%=`， `&=`， `|=`， `^=`， `<<=`， `>>=`
*  隱含和明確轉換

當涉及動態運算式時，C# 預設為靜態繫結，這表示構成的運算式的編譯時期型別會在選取程序。 不過，構成的運算式在上面所列的作業中的其中一個是動態運算式時，作業會改為動態繫結。

### <a name="binding-time"></a>繫結時間

靜態繫結會放置在編譯時期，而動態繫結會在執行階段的位置。 在下列章節中，詞彙***繫結時間***指的是編譯時期或執行階段，根據繫結何時會發生。

下列範例說明靜態和動態繫結和繫結時間的概念：
```csharp
object  o = 5;
dynamic d = 5;

Console.WriteLine(5);  // static  binding to Console.WriteLine(int)
Console.WriteLine(o);  // static  binding to Console.WriteLine(object)
Console.WriteLine(d);  // dynamic binding to Console.WriteLine(int)
```

前兩個呼叫會以靜態方式繫結： 多載`Console.WriteLine`會挑出根據其引數的編譯時間類型。 因此，繫結時間是編譯時期。

第三個呼叫動態繫結： 多載`Console.WriteLine`會選擇根據執行階段型別，其引數。 這是因為引數是動態的運算式--其編譯時期型別是`dynamic`。 因此，第三個呼叫繫結時間是執行階段。

### <a name="dynamic-binding"></a>動態繫結

動態繫結的目的是以允許 C# 程式互動***動態物件***，也就是不遵循 C# 的一般規則的物件型別系統。 動態物件可能會從其他程式設計語言，與不同類型系統的物件，或者可能是以程式設計的方式安裝程式，以實作自己的繫結語意不同作業的物件。

供動態物件會實作本身語意的機制是實作所定義。 指定的介面--重新定義的實作，被實作的動態物件來表示 C# 執行階段，它們會有特殊的語意。 因此，動態繫結的動態物件上的作業，只要他們自己的繫結語意，而不是 C# 中本文件中，所指定的接管。

動態繫結的目的是允許使用動態物件互通性，而 C# 可讓動態繫結上的所有物件，無論或不是動態。 這可讓順暢整合的動態物件，在其上作業的結果可能本身不是動態物件，但仍是程式設計師在編譯時期未知的類型。 也可協助動態繫結，消除出錯反映架構的程式碼，即使在沒有所牽涉的物件是動態的物件。

完全動態繫結套用時，什麼編譯時間檢查，如果套用任何-，以及編譯時間結果與運算式分類為下列各節說明在語言中的每個建構。

### <a name="types-of-constituent-expressions"></a>構成運算式的型別

當作業以靜態方式繫結時，構成的運算式 （例如接收者和引數、 索引或運算元） 的型別一律會視為是編譯時期型別，該運算式。

當動態繫結作業時，構成運算式的類型決定以不同的方式，取決於構成運算式的編譯時間類型：

*  編譯時期型別構成運算式`dynamic`被視為具有在執行階段運算式評估為實際值的型別
*  其編譯時期型別為型別參數的構成運算式被視為具有型別參數在繫結至執行階段的型別
*  否則構成的運算式被視為具有其編譯時期型別。

## <a name="operators"></a>運算子

運算式由組成***運算元***並***運算子***。 運算式的運算子會指出要將哪些運算套用到運算元。 運算子範例包括 `+`、`-`、`*`、`/` 及 `new`。 運算元範例包括常值、欄位、區域變數及運算式。

有三種類型的運算子：

*  一元運算子。 一元運算子一個運算元，並使用其中一個前置標記法 (例如`--x`) 或後置標記法 (例如`x++`)。
*  二元運算子。 二元運算子需要兩個運算元和所有使用中置標記法 (例如`x + y`)。
*  三元運算子。 只能有一個三元運算子`?:`，存在，它會採用三個運算元，並使用中置標記法 (`c ? x : y`)。

取決於運算式中運算子的評估順序***優先順序***並***關聯性***一個運算子 ([運算子優先順序和關聯性](expressions.md#operator-precedence-and-associativity)).

在運算式中的運算元是從左到右評估。 例如，在`F(i) + G(i++) * H(i)`，方法`F`使用的舊值來呼叫`i`，然後方法`G`呼叫的舊值`i`，和，最後，方法`H`新值呼叫`i`. 這是分開並不相關的運算子優先順序。

可以是特定運算子***多載***。 運算子多載允許使用者定義運算子實作，其指定作業的一或兩個運算元屬於使用者定義的類別或結構類型 ([運算子多載](expressions.md#operator-overloading))。

### <a name="operator-precedence-and-associativity"></a>運算子優先順序和關聯性

當運算式包含多個運算子時，運算子的「優先順序」會控制評估個別運算子的順序。 例如，運算式`x + y * z`評估為`x + (y * z)`因為`*`運算子的優先順序高於二進位檔`+`運算子。 運算子的優先順序是由其相關聯的文法生產環境的定義建立的。 例如， *additive_expression*組成的序列*multiplicative_expression*s 分隔`+`或`-`運算子，因此讓`+`和`-`運算子較低的優先順序高於`*`， `/`，和`%`運算子。

下表摘要說明所有運算子的優先順序從最高到低排列順序：

| __區段__                                                                                   | __分類__                | __運算子__ | 
|-----------------------------------------------------------------------------------------------|-----------------------------|---------------|
| [主要運算式](expressions.md#primary-expressions)                                     | 主要                     | `x.y`  `f(x)`  `a[x]`  `x++`  `x--`  `new`  `typeof`  `default`  `checked`  `unchecked`  `delegate` | 
| [一元運算子](expressions.md#unary-operators)                                             | 一元                       | `+`  `-`  `!`  `~`  `++x`  `--x`  `(T)x` | 
| [算術運算子](expressions.md#arithmetic-operators)                                   | 乘法類 (Multiplicative)              | `*`  `/`  `%` | 
| [算術運算子](expressions.md#arithmetic-operators)                                   | 加法類 (Additive)                    | `+`  `-`      | 
| [移位運算子](expressions.md#shift-operators)                                             | Shift                       | `<<`  `>>`    | 
| [關係和類型測試運算子](expressions.md#relational-and-type-testing-operators) | 關係和型別測試 | `<`  `>`  `<=`  `>=`  `is`  `as` | 
| [關係和類型測試運算子](expressions.md#relational-and-type-testing-operators) | 相等                    | `==`  `!=`    | 
| [邏輯運算子](expressions.md#logical-operators)                                         | 邏輯 AND                 | `&`           | 
| [邏輯運算子](expressions.md#logical-operators)                                         | 邏輯 XOR                 | `^`           | 
| [邏輯運算子](expressions.md#logical-operators)                                         | 邏輯 OR                  | <code>&#124;</code>           |
| [條件邏輯運算子](expressions.md#conditional-logical-operators)                 | 條件式 AND             | `&&`          | 
| [條件邏輯運算子](expressions.md#conditional-logical-operators)                 | 條件式 OR              | <code>&#124;&#124;</code>          | 
| [Null 聯合運算子](expressions.md#the-null-coalescing-operator)                   | Null 聯合             | `??`          | 
| [條件運算子](expressions.md#conditional-operator)                                   | 條件式                 | `?:`          | 
| [指派運算子](expressions.md#assignment-operators)，[匿名函式運算式](expressions.md#anonymous-function-expressions)  | 指派和 lambda 運算式 | `=`  `*=`  `/=`  `%=`  `+=`  `-=`  `<<=`  `>>=`  `&=`  `^=`  <code>&#124;=</code>  `=>` | 

介於兩個具有相同優先順序的運算子的運算元時，運算子的順序關聯性會控制所執行之作業的順序：

*  除了指派運算子和 null 聯合運算子，所有二元運算子都***左向***，也就是說，作業將會從左到右。 例如，`x + y + z` 會判斷值為 `(x + y) + z`。
*  指派運算子、 null 聯合運算子和條件運算子 (`?:`) 是***右向關聯***，亦即在由右至左執行運算。 例如，`x = y = z` 會判斷值為 `x = (y = z)`。

您可以使用括弧來控制優先順序和關聯性。 例如，`x + y * z` 會先將 `y` 乘以 `z`，然後再將結果加到 `x`，而 `(x + y) * z` 則會先將 `x` 與 `y` 相加，然後再將結果乘以 `z`。

### <a name="operator-overloading"></a>運算子多載

所有的一元和二元運算子有預先定義的實作，會自動出現在任何運算式。 除了預先定義的實作中，使用者定義的實作可以引進加`operator`類別和結構中的宣告 ([運算子](classes.md#operators))。 使用者定義運算子實作，一律優先於預先定義的運算子實作：只有當沒有適用的使用者定義運算子實作預先定義的運算子會考慮實作，如中所述[一元運算子多載解析](expressions.md#unary-operator-overload-resolution)和[二元運算子多載解析](expressions.md#binary-operator-overload-resolution)。

***多載的一元運算子***是：
```csharp
+   -   !   ~   ++   --   true   false
```

雖然`true`和`false`不會在運算式中明確使用 (並因此不包含在中，針對優先順序表格[運算子優先順序和關聯性](expressions.md#operator-precedence-and-associativity))，它們被視為運算子，因為它們是在數個運算式內容中叫用： 布林運算式 ([布林運算式](expressions.md#boolean-expressions)) 和包含條件式運算式 ([條件運算子](expressions.md#conditional-operator))，和條件式邏輯運算子 ([條件式邏輯運算子](expressions.md#conditional-logical-operators))。

***多載的二元運算子***是：
```csharp
+   -   *   /   %   &   |   ^   <<   >>   ==   !=   >   <   >=   <=
```

只有將上述的運算子可以多載。 特別是，不可能多載成員存取，方法引動過程，或是`=`， `&&`， `||`， `??`， `?:`， `=>`， `checked`， `unchecked`， `new`， `typeof`， `default`， `as`，和`is`運算子。

二元運算子多載時，對應的指派運算子 (若有) 也會隱含地多載。 比方說，運算子多載`*`也是運算子多載`*=`。 這是更進一步的說明[複合指派](expressions.md#compound-assignment)。 請注意，指派運算子本身 (`=`) 無法多載。 一律指派執行簡單的位元值副本放入變數中。

轉換作業，例如`(T)x`，藉由提供使用者定義轉換都多載 ([使用者定義轉換](conversions.md#user-defined-conversions))。

項目的存取，例如`a[x]`，不是可多載的運算子。 相反地，使用者定義編製索引支援透過索引子 ([索引子](classes.md#indexers))。

在運算式中，運算子會參考使用運算子表示法，而且在宣告中，運算子會使用參考函式標記法。 下表顯示運算子的一元和二元運算子的功能標記法之間的關聯性。 在第一個項目時， *op*代表任何多載的一元前置運算子。 在第二個項目時， *op*代表一元後置`++`和`--`運算子。 在第三個項目時， *op*代表任何多載的二元運算子。


| __運算子標記法__ | __函式標記法__ |
|-----------------------|-------------------------|
| `op x`                | `operator op(x)`        | 
| `x op`                | `operator op(x)`        | 
| `x op y`              | `operator op(x,y)`      | 

使用者定義運算子的宣告一律需要至少一個包含運算子宣告類別或結構類型的參數。 因此，不可能的使用者定義的運算子具有相同的簽章，做為預先定義的運算子。

語法、 優先順序或運算子的順序關聯性，無法修改使用者定義運算子的宣告。 例如，`/`運算子一律是二元運算子，一律具有的優先順序層級中指定[運算子優先順序和關聯性](expressions.md#operator-precedence-and-associativity)，而且永遠都是左關聯性。

雖然您可以執行任何計算為所欲為的使用者定義運算子，實作會產生不是預期的結果是強烈建議您不要。 比方說，實作`operator ==`應該會比較兩個運算元是否相等，並傳回適當`bool`結果。

中的個別運算子的說明[主要運算式](expressions.md#primary-expressions)透過[條件式邏輯運算子](expressions.md#conditional-logical-operators)指定預先定義的運算子和套用的任何其他規則實作每個運算子。 描述能夠使用的詞彙***一元運算子多載解析***，***二元運算子多載解析***，並***數值升級***，這是定義在下列各節中找到。

### <a name="unary-operator-overload-resolution"></a>一元運算子多載解析

表單的作業`op x`或`x op`，其中`op`是可多載的一元運算子，以及`x`這類型的運算式`X`，處理，如下所示：

*  一組所提供的候選使用者定義運算子`X`作業`operator op(x)`使用的規則決定[候選使用者定義運算子](expressions.md#candidate-user-defined-operators)。
*  如果一組候選使用者定義運算子不是空的則這會變成一組作業的候選項目運算子。 否則，預先定義的一元`operator op`實作，包括其提昇的形式，將會成為一組作業的候選項目運算子。 運算子的說明中指定的給定操作員的預先定義的實作 ([主要運算式](expressions.md#primary-expressions)並[一元運算子](expressions.md#unary-operators))。
*  多載解析規則[多載解析](expressions.md#overload-resolution)套用至一組選取最佳的運算子，根據引數清單的候選項目運算子`(x)`，而這個運算子多載的結果解析程序。 如果選取單一最佳的運算子無法多載解析，繫結階段會發生錯誤。

### <a name="binary-operator-overload-resolution"></a>二元運算子多載解析

表單的作業`x op y`，其中`op`是一個多載的二元運算子`x`是類型的運算式`X`，和`y`是類型的運算式`Y`，處理時，如下所示：

*  一組所提供的候選使用者定義運算子`X`並`Y`作業`operator op(x,y)`決定。 集合所組成的聯集所提供的候選項目運算子`X`以及所提供的候選項目運算子`Y`，每個使用的規則決定[候選使用者定義運算子](expressions.md#candidate-user-defined-operators)。 如果`X`並`Y`都是相同的類型，或如果`X`和`Y`衍生自一般基底型別，則共用的候選運算子只會發生組合中一次。
*  如果一組候選使用者定義運算子不是空的則這會變成一組作業的候選項目運算子。 否則，預先定義的二進位檔`operator op`實作，包括其提昇的形式，將會成為一組作業的候選項目運算子。 運算子的說明中指定的給定操作員的預先定義的實作 ([算術運算子](expressions.md#arithmetic-operators)透過[條件式邏輯運算子](expressions.md#conditional-logical-operators))。 預先定義的列舉和委派運算子，視為唯一運算子是定義列舉或委派的型別，來為其中一個運算元的繫結階段類型。
*  多載解析規則[多載解析](expressions.md#overload-resolution)套用至一組選取最佳的運算子，根據引數清單的候選項目運算子`(x,y)`，而這個運算子多載的結果解析程序。 如果選取單一最佳的運算子無法多載解析，繫結階段會發生錯誤。

### <a name="candidate-user-defined-operators"></a>候選使用者定義運算子

提供型別的`T`和作業`operator op(A)`，其中`op`是可多載的運算子和`A`是所提供的使用者定義運算子的引數清單中，候選項目組`T`的`operator op(A)`取決於如下所示：

*  判斷型別`T0`。 如果`T`為 null 的型別`T0`是其基礎類型，否則為`T0`等於`T`。
*  針對所有`operator op`中的宣告`T0`和所有提昇形式的這類運算子，如果至少一個運算子時適用 ([適用的函式成員](expressions.md#applicable-function-member)) 引數清單`A`，一組候選運算子包含在所有適用的運算子`T0`。
*  否則，如果`T0`是`object`，一組候選項目運算子是空的。
*  一組候選項目運算子所提供的否則為`T0`是一組直接基底類別所提供的候選項目運算子`T0`，或有效基底類別`T0`如果`T0`是型別參數。

### <a name="numeric-promotions"></a>數字的促銷活動

數字的促銷活動包含自動執行某些隱含轉換的預先定義的一元和二元數值運算子的運算元。 數值升級並不是不同的機制，而是套用預先定義的運算子多載解析的效果。 數值升級特別不會影響評估使用者定義的運算子，雖然可以實作使用者定義的運算子，以呈現類似的效果。

數字的促銷活動的範例，請考慮預先定義的實作，二進位檔的`*`運算子：

```csharp
int operator *(int x, int y);
uint operator *(uint x, uint y);
long operator *(long x, long y);
ulong operator *(ulong x, ulong y);
float operator *(float x, float y);
double operator *(double x, double y);
decimal operator *(decimal x, decimal y);
```

當多載解析規則 ([多載解析](expressions.md#overload-resolution)) 會套用至這個集合的運算子，就可以為選取有隱含轉換運算子的第一個運算元類型。 例如，對於作業`b * s`，其中`b`是`byte`並`s`是`short`，多載解析會選取`operator *(int,int)`做最佳的運算子。 因此，結果會是，`b`並`s`轉換成`int`，且結果類型是`int`。 同樣地，用於操作`i * d`，其中`i`是`int`並`d`是`double`，多載解析會選取`operator *(double,double)`做最佳的運算子。

#### <a name="unary-numeric-promotions"></a>一元數值促銷活動

一元數值升級，就會發生的預先定義的運算元`+`， `-`，和`~`一元運算子。 一元數值升級僅包含轉換類型的運算元`sbyte`， `byte`， `short`， `ushort`，或`char`輸入`int`。 此外，對於一元`-`運算子，一元 （unary） 數值升級會將轉換類型的運算元`uint`輸入`long`。

#### <a name="binary-numeric-promotions"></a>二進位數字的促銷活動

二進位數值升級，就會發生的預先定義的運算元`+`， `-`， `*`， `/`， `%`， `&`， `|`， `^`， `==`， `!=`，`>`， `<`， `>=`，和`<=`二元運算子。 二進位數值升級會將兩個運算元隱含轉換成一般類型會發生的非關聯式運算子，也變得作業的結果類型。 二進位數字的促銷活動包含套用下列規則，會顯示在這裡的順序：

*  如果任一個運算元的類型`decimal`，另一個運算元會轉換成類型`decimal`，或如果另一個運算元的類型，就會發生繫結時間錯誤`float`或`double`。
*  否則，如果任一個運算元是型別的`double`，另一個運算元會轉換成類型`double`。
*  否則，如果任一個運算元是型別的`float`，另一個運算元會轉換成類型`float`。
*  否則，如果任一個運算元是型別的`ulong`，另一個運算元會轉換成類型`ulong`，或如果另一個運算元的類型，就會發生繫結時間錯誤`sbyte`， `short`， `int`，或`long`。
*  否則，如果任一個運算元是型別的`long`，另一個運算元會轉換成類型`long`。
*  否則，如果任一個運算元是型別的`uint`以及另一個運算元為類型`sbyte`， `short`，或`int`，這兩個運算元都轉換成輸入`long`。
*  否則，如果任一個運算元是型別的`uint`，另一個運算元會轉換成類型`uint`。
*  否則，這兩個運算元會轉換成輸入`int`。

第一個規則不允許混用任何作業的附註`decimal`型別與`double`和`float`型別。 此規則的事實之間沒有隱含轉換，會遵循`decimal`型別和`double`和`float`類型。

也請注意，不可以是類型的運算元`ulong`當另一個運算元是帶正負號的整數類資料類型。 原因是任何整數類資料類型是否存在，可以代表各種`ulong`以及帶正負號的整數類資料類型。

在兩個上述所有情況下，轉型運算式可用來明確地將一個運算元轉換成相容於另一個運算元的類型。

在範例
```csharp
decimal AddPercent(decimal x, double percent) {
    return x * (1.0 + percent / 100.0);
}
```
發生繫結時間錯誤的原因`decimal`不能乘以`double`。 明確的轉換的第二個運算元可解決此錯誤`decimal`、，如下所示：

```csharp
decimal AddPercent(decimal x, double percent) {
    return x * (decimal)(1.0 + percent / 100.0);
}
```

### <a name="lifted-operators"></a>提昇的運算子

***運算子會消除***允許對不可為 null 的實值型別也可搭配可為 null 的表單，這些類型的預先定義和使用者定義運算子。 提昇的運算子建構從預先定義和使用者定義的運算子，以符合特定需求，如下列所述：

*   針對一元運算子

    ```csharp
    +  ++  -  --  !  ~
    ```

    運算子的消除的形式存在，如果運算元和結果的型別是這兩個不可為 null 的實值型別。 提昇形式是藉由將單一`?`運算元和結果的類型修飾詞。 如果運算元是 null，提昇的運算子會產生 null 值。 否則為提昇的運算子，運算元會解除包裝成為、 適用於基礎的運算子，並將結果包裝。

*   以二元運算子

    ```csharp
    +  -  *  /  %  &  |  ^  <<  >>
    ```

    運算子的消除的形式存在，如果運算元和結果的類型是所有不可為 null 的實值型別。 提昇形式是藉由將單一`?`每個運算元和結果的類型修飾詞。 提昇的運算子會產生 null 值，如果有一個或兩個運算元都是 null (例外狀況正在`&`並`|`操作員`bool?`類型，如中所述[布林邏輯運算子](expressions.md#boolean-logical-operators))。 否則為提昇的運算子，運算元會解除包裝成為、 適用於基礎的運算子，並將結果包裝。

*   等號比較運算子

    ```csharp
    ==  !=
    ```

    運算子的消除的形式存在，如果運算元類型不可為 null 的實值型別和結果型別是否`bool`。 提昇形式是藉由將單一`?`每個運算元的類型修飾詞。 提昇的運算子會視為兩個 null 值相等，而且 null 值給任何非 null 值不相等。 如果兩個運算元都為非 null，提昇的運算子會解除包裝成為運算元和適用於基礎的運算子，以產生`bool`結果。

*   針對關係運算子

    ```csharp
    <  >  <=  >=
    ```

    運算子的消除的形式存在，如果運算元類型不可為 null 的實值型別和結果型別是否`bool`。 提昇形式是藉由將單一`?`每個運算元的類型修飾詞。 提昇的運算子會產生值`false`如果一個或兩個運算元都是 null。 提昇的運算子，否則會解除包裝成為運算元和適用於基礎的運算子，以產生`bool`結果。

## <a name="member-lookup"></a>成員查詢

成員查詢是名稱的藉此類型的內容中的意義取決於程序。 成員查詢可能會發生評估的一部分*simple_name* ([簡單名稱](expressions.md#simple-names)) 或*member_access* ([成員存取](expressions.md#member-access)) 中運算式。 如果*simple_name*或是*member_access*當做*primary_expression*的*invocation_expression* ([方法引動過程](expressions.md#method-invocations))，該成員就會叫用。

如果成員是方法或事件，或者它是常數、 欄位或屬性的委派型別 ([委派](delegates.md)) 或型別`dynamic`([動態型別](types.md#the-dynamic-type))，則該成員就是*invocable*。

成員查詢會視為不只有名稱的成員，但成員的型別參數和成員是否可存取的數目。 成員查詢而言泛型方法，而巢狀泛型類型有其各自的宣告所示的型別參數的數目，以及所有其他成員都有零個類型參數。

成員名稱的查閱 `N`具有`K` 型別參數的型別中 `T`處理，如下所示：

*  首先，將可存取的成員命名 `N`取決於：
    * 如果`T`是型別參數，則集合是可存取的成員命名集的聯集 `N`中每個類型指定為主要的條件約束或次要的條件約束 ([類型參數條件約束](classes.md#type-parameter-constraints)) 的 `T`，以及可存取的成員命名集 `N`在`object`。
    * 否則集合，包含所有可存取的 ([成員存取](basic-concepts.md#member-access)) 成員命名 `N`中 `T`，包括繼承的成員，以及可存取的成員命名 `N`在`object`。 如果`T`是建構的型別，取得之成員的集合中所述，以替代型別引數[建構的型別成員](classes.md#members-of-constructed-types)。 其成員包括`override`修飾詞會集中排除。
*  接下來，如果`K`為零，所有巢狀中移除其宣告包含型別參數的型別。 如果`K`不是零，具有不同數目的型別參數會移除所有成員。 請注意，當`K`為零，方法有的類型參數不會移除，因為型別推斷程序 ([型別推斷](expressions.md#type-inference)) 或許能夠推斷類型引數。
*  下一步，如果成員是*叫用*中，所有非-*invocable*成員會從集合中移除。
*  接下來，會隱藏其他成員的成員會從集合移除。 每位成員`S.M`集中，其中`S`是在其中的類型成員 `M`宣告，會套用下列規則：
    * 如果`M`是常數、 欄位、 屬性、 事件或列舉成員，則基底類型中宣告的所有成員`S`從集合中移除。
    * 如果`M`是型別宣告，則所有非類型的基底類型中宣告`S`會從集合中移除所有輸入具有相同數目的型別參數宣告`M`基底類型中宣告`S`會移除從集合中。
    * 如果`M`是一種方法，則基底類型中宣告的所有非方法成員`S`從集合中移除。
*  接下來，會隱藏類別成員的介面成員會從集合移除。 此步驟只會有作用`T`是型別參數和`T`以外的其他具有這兩個的有效基底類別`object`和設定的非空白有效的介面 ([類型參數條件約束](classes.md#type-parameter-constraints))。 每位成員`S.M`集中，其中`S`是在其中的類型成員`M`宣告，下列規則適用於`S`而不是類別宣告`object`:
    * 如果`M`是常數、 欄位、 屬性、 事件、 列舉成員或型別宣告，則會從集合中移除所有在 interface 宣告中宣告的成員。
    * 如果`M`是一種方法，則在 interface 宣告中宣告的所有非方法成員集合，與具有相同的簽章的所有方法中移除`M`宣告介面中宣告從集合中移除。
*  最後，移除隱藏的成員，該查詢的結果決定：
    * 如果集合包含不是方法的單一成員，這個成員是該查詢的結果。
    * 否則，如果集合包含只有方法，然後這群方法就會是該查詢的結果。
    * 否則，查閱模稜兩可，並在繫結階段錯誤發生。

型別參數和介面，以外的型別中的成員查閱和嚴格的單一繼承的介面中的成員查閱 （繼承鏈結中的每個介面具有剛好零個或一個直接基底介面），查閱規則的效果只是指衍生成員隱藏基底成員具有相同的名稱或簽章。 這種單一繼承查閱是永遠不會模稜兩可。 模稜兩可可能造成多個繼承介面成員查閱中所述[介面成員存取](interfaces.md#interface-member-access)。

### <a name="base-types"></a>基底類型

為了使用成員查詢，為型別`T`被視為具有下列基底類型：

*  如果`T`已`object`，然後`T`沒有基底類型。
*  如果`T`是*enum_type*，基底型別的`T`是類別型別`System.Enum`， `System.ValueType`，和`object`。
*  如果`T`是*struct_type*，基底型別的`T`是類別型別`System.ValueType`和`object`。
*  如果`T`是*class_type*，基底型別的`T`的基底類別`T`，包括的類別型別`object`。
*  如果`T`是*interface_type*，基底型別的`T`的基底介面`T`類別型別和`object`。
*  如果`T`是*array_type*，基底型別的`T`是類別型別`System.Array`和`object`。
*  如果`T`是*delegate_type*，基底型別的`T`是類別型別`System.Delegate`和`object`。

## <a name="function-members"></a>函式成員

函式成員是包含可執行的陳述式的成員。 函式成員皆為型別的成員，而且不能命名空間的成員。 C# 定義函式成員的下列的類別：

*  方法
*  屬性
*  事件
*  索引子
*  使用者定義的運算子
*  執行個體建構函式
*  靜態建構函式
*  解構函式

除了解構函式和靜態建構函式 （這無法明確地叫用），函式成員中包含的陳述式會執行透過函式成員引動過程。 實際的語法撰寫的函式成員引動過程取決於特定函式成員分類。

引數清單 ([引數清單](expressions.md#argument-lists)) 函式成員的引動過程提供實際的值或變數參考參數的函式成員。

泛型方法的引動過程可能會採用型別推斷來判斷要傳遞至方法的型別引數的集合。 此程序所述[型別推斷](expressions.md#type-inference)。

引動過程的方法、 索引子、 運算子和執行個體建構函式會採用多載解析，以決定哪一組候選函式成員叫用。 此程序所述[多載解析](expressions.md#overload-resolution)。

識別特定函式成員繫結時間之後, 可能是透過多載解析，叫用函式成員的實際執行階段程序所述[編譯時期檢查動態的多載解析](expressions.md#compile-time-checking-of-dynamic-overload-resolution).

下表摘要說明的處理會涉及可以明確叫用的函式成員的六個類別的建構中的位置。 在資料表中， `e`， `x`， `y`，和`value`表示分類為變數或值的運算式`T`指出運算式分類為型別，`F`是簡單的方法，而名稱`P`是簡單的屬性名稱。


| __建構__     | __範例__    | __描述__ |
|-------------------|----------------|-----------------|
| 方法引動過程 | `F(x,y)`       | 多載解析會選取最佳的方式套用`F`中包含的類別或結構。 使用引數清單叫用方法`(x,y)`。 如果方法不是`static`，此執行個體運算式`this`。 | 
|                   | `T.F(x,y)`     | 多載解析會選取最佳的方式套用`F`類別或結構中`T`。 如果方法不是，就會發生的繫結時間錯誤`static`。 使用引數清單叫用方法`(x,y)`。 | 
|                   | `e.F(x,y)`     | 多載解析套用至類別、 結構或介面的型別所指定在選取最佳的方法 F `e`。 如果方法是，就會發生繫結時間錯誤`static`。 方法會叫用執行個體運算式`e`和引數清單`(x,y)`。 | 
| 屬性存取   | `P`            | `get`屬性存取子`P`中包含的類別或結構會叫用。 如果，就會發生編譯時期錯誤`P`是唯寫。 如果`P`不是`static`，此執行個體運算式`this`。 | 
|                   | `P = value`    | `set`屬性存取子`P`中包含的類別或結構會叫用具有引數清單`(value)`。 如果，就會發生編譯時期錯誤`P`處於唯讀狀態。 如果`P`不是`static`，此執行個體運算式`this`。 | 
|                   | `T.P`          | `get`屬性存取子`P`類別或結構中`T`叫用。 如果，就會發生編譯時期錯誤`P`不是`static`或者`P`是唯寫。 | 
|                   | `T.P = value`  | `set`屬性存取子`P`類別或結構中`T`引數清單叫用`(value)`。 如果，就會發生編譯時期錯誤`P`不是`static`或者`P`處於唯讀狀態。 | 
|                   | `e.P`          | `get`屬性存取子`P`在類別、 結構或介面的型別所給定`e`叫用執行個體運算式`e`。 如果繫結時間錯誤就會發生`P`是`static`或者`P`是唯寫。 | 
|                   | `e.P = value`  | `set`屬性存取子`P`在類別、 結構或介面的型別所給定`e`叫用執行個體運算式`e`和引數清單`(value)`。 如果繫結時間錯誤就會發生`P`是`static`或者`P`處於唯讀狀態。 | 
| 事件存取      | `E += value`   | `add`事件存取子`E`中包含的類別或結構會叫用。 如果`E`為非靜態的該執行個體運算式是`this`。 | 
|                   | `E -= value`   | `remove`事件存取子`E`中包含的類別或結構會叫用。 如果`E`為非靜態的該執行個體運算式是`this`。 | 
|                   | `T.E += value` | `add`事件存取子`E`類別或結構中`T`叫用。 若時期繫結錯誤`E`不是靜態。 | 
|                   | `T.E -= value` | `remove`事件存取子`E`類別或結構中`T`叫用。 若時期繫結錯誤`E`不是靜態。 | 
|                   | `e.E += value` | `add`事件存取子`E`在類別、 結構或介面的型別所給定`e`叫用執行個體運算式`e`。 若時期繫結錯誤`E`是靜態的。 | 
|                   | `e.E -= value` | `remove`事件存取子`E`在類別、 結構或介面的型別所給定`e`叫用執行個體運算式`e`。 若時期繫結錯誤`E`是靜態的。 | 
| 索引子存取    | `e[x,y]`       | 多載解析會套用至類別、 結構或 e 的型別所提供的介面中選取最佳的索引子。 `get`的索引子的存取子會叫用執行個體運算式`e`和引數清單`(x,y)`。 如果這個索引子是唯寫，就會發生的繫結階段錯誤。 | 
|                   | `e[x,y] = value` | 多載解析會套用至類別、 結構或介面的型別所指定在選取最佳的索引子`e`。 `set`的索引子的存取子會叫用執行個體運算式`e`和引數清單`(x,y,value)`。 如果索引子會是唯讀的就會發生的繫結階段錯誤。 | 
| 運算子的引動過程 | `-x`         | 多載解析會套用至類別或型別所指定的結構中選取最佳的一元運算子`x`。 選取的運算子會叫用具有引數清單`(x)`。 | 
|                     | `x + y`      | 多載解析套用至類別或類型的所指定的結構中選取最佳的二元運算子`x`和`y`。 選取的運算子會叫用具有引數清單`(x,y)`。 | 
| 執行個體建構函式引動過程 | `new T(x,y)` | 多載解析會套用至類別或結構中選取最佳的執行個體建構函式`T`。 執行個體建構函式會叫用具有引數清單`(x,y)`。 | 

### <a name="argument-lists"></a>引數清單

每個函式成員和委派叫用包含可提供實際的值或變數參考參數的函式成員的引數清單。 指定的函式成員引動過程的引數清單的語法取決於函式成員分類：

*  執行個體建構函式、 方法、 索引子和委派的引數會指定為*argument_list*，如下所述。 針對索引子，叫用時`set`存取子的引數清單此外也包含為指派運算子的右運算元所指定的運算式。
*  屬性，引數清單是空的時叫用`get`存取子，並叫用時，為指派運算子的右運算元指定的運算式所組成`set`存取子。
*  事件引數清單所組成的右運算元為指定的運算式`+=`或`-=`運算子。
*  使用者定義的運算子，引數清單包含單一運算子的運算元一元或二元運算子的兩個運算元。

屬性的引數 ([屬性](classes.md#properties))，事件 ([事件](classes.md#events))，和使用者定義運算子 ([運算子](classes.md#operators)) 一定會傳遞做為值參數 ([值參數](classes.md#value-parameters))。 索引子的引數 ([索引子](classes.md#indexers)) 一定會傳遞做為值參數 ([實值參數](classes.md#value-parameters)) 或參數陣列 ([參數陣列](classes.md#parameter-arrays))。 這些函式成員的類別不支援的參考和輸出參數。

執行個體建構函式、 方法、 索引子或委派引動過程的引數會指定為*argument_list*:

```antlr
argument_list
    : argument (',' argument)*
    ;

argument
    : argument_name? argument_value
    ;

argument_name
    : identifier ':'
    ;

argument_value
    : expression
    | 'ref' variable_reference
    | 'out' variable_reference
    ;
```

*Argument_list*包含一個或多個*引數*s，並以逗號分隔。 每個引數所組成的選擇性*數名稱*後面*argument_value*。 *引數*具有*數名稱*指***具名引數***，而*引數*沒有*數名稱*已***位置引數***。 它是位置引數中的具名引數之後顯示的錯誤*argument_list*。

*Argument_value*可以採用下列格式之一：

*  *運算式*，表示引數會傳遞做為值參數 ([實值參數](classes.md#value-parameters))。
*  關鍵字`ref`後面接著*variable_reference* ([變數參考](variables.md#variable-references))，表示引數會傳遞做為參考參數 ([參考參數](classes.md#reference-parameters)). 變數必須明確進行指派 ([明確指派](variables.md#definite-assignment)) 將它傳遞做為參考參數之前。 關鍵字`out`後面接著*variable_reference* ([變數參考](variables.md#variable-references))，表示引數會傳遞做為輸出參數 ([輸出參數](classes.md#output-parameters)). 變數會被視為已明確指派 ([明確指派](variables.md#definite-assignment)) 遵循變數被當做輸出參數的函式成員引動過程。

#### <a name="corresponding-parameters"></a>對應的參數

每個引數的引數清單中應該有對應的參數所叫用委派的函式成員中。

使用下列的參數清單的判斷方式如下：

*  虛擬方法和類別中定義的索引子，參數清單會挑出最明確的宣告，或覆寫函式成員，開始的接收者，靜態類型，並搜尋其基底類別。
*  介面方法和索引子，參數清單會挑出形成最明確的定義開頭的介面型別和基底介面中搜尋的成員。 如果沒有唯一的參數清單中找到，建構使用無法存取名稱以及任何選擇性參數的參數清單，以便引動過程不能使用具名的參數，或省略的選擇性引數。
*  部分方法，會使用定義的部分方法宣告的參數清單。
*  針對所有其他函式成員與委派沒有只有單一參數清單時，也就是使用一個。

引數或參數的位置會定義為引數或引數清單或參數清單中在它前面的參數數目。

建立函式成員的引數的對應參數，如下所示：

*  中的引數*argument_list*的執行個體建構函式、 方法、 索引子和委派：
    * 固定的參數在參數清單中相同的位置發生的所在位置的引數會對應至該參數。
    * 含有參數陣列叫用的一般形式的函式成員的位置引數會對應至參數陣列，它必須出現在參數清單中的相同位置。
    * 含有參數陣列叫用其展開的形式，其中沒有固定的參數就會發生在相同的位置參數清單中，函式成員的位置引數會對應至參數陣列中的項目。
    * 具名引數會對應至參數清單中的相同名稱的參數。
    * 針對索引子，叫用時`set`存取子，指定對應至隱含的指派運算子的右運算元，運算式`value`參數`set`存取子宣告。
*  屬性，叫用時`get`引數，就有存取子。 當叫用`set`存取子，指定對應至隱含的指派運算子的右運算元，運算式`value`參數`set`存取子宣告。
*  使用者定義的一元運算子 （包括轉換），在單一運算元對應運算子宣告單一參數。
*  使用者定義的二元運算子的左的運算元對應到第一個參數，而右運算元對應運算子宣告的第二個參數。

#### <a name="run-time-evaluation-of-argument-lists"></a>執行階段評估的引數清單

在執行階段的處理函式成員引動過程期間 ([編譯時期檢查動態的多載解析](expressions.md#compile-time-checking-of-dynamic-overload-resolution))，運算式或變數的參考，引數清單的評估順序，從左到右，做為如下所示：

*  引數運算式會評估為值參數和隱含的轉換 ([隱含轉換](conversions.md#implicit-conversions)) 相對應的參數來執行類型。 產生的值會變成函式成員引動過程中的 value 參數的初始值。
*  參考或輸出參數，在評估變數的參考而產生的儲存位置會變成函式成員引動過程中的參數所表示的儲存位置。 如果變數參考做為參考或輸出參數所指定之陣列元素*reference_type*，執行階段會執行檢查以確保陣列的元素型別參數的型別相同。 如果這項檢查失敗，`System.ArrayTypeMismatchException`就會擲回。

方法、 索引子、 使用和執行個體建構函式可以宣告它們的最右邊的參數，參數陣列 ([參數陣列](classes.md#parameter-arrays))。 以一般形式或以其展開的形式，取決於適用於叫用這類函式成員 ([適用的函式成員](expressions.md#applicable-function-member)):

*  一般形式叫用含有參數陣列的函式成員時，提供給參數陣列引數必須是可以隱含轉換的單一運算式 ([隱含轉換](conversions.md#implicit-conversions)) 為參數陣列型別。 在此情況下，參數陣列的行為很類似值的參數。
*  叫用其展開的形式叫用含有參數陣列的函式成員時，必須指定為參數陣列，其中每個引數是可以隱含地轉換運算式的零或多個位置引數 ([隱含轉換](conversions.md#implicit-conversions)) 參數陣列的項目型別。 在此情況下，叫用建立具有相對應的引數的長度參數陣列型別的執行個體初始化為指定的引數的值，將陣列執行個體的項目，做為新建立的陣列執行個體的實際引數。

引數清單的運算式一律會將它們寫入順序進行評估。 因此，範例
```csharp
class Test
{
    static void F(int x, int y = -1, int z = -2) {
        System.Console.WriteLine("x = {0}, y = {1}, z = {2}", x, y, z);
    }

    static void Main() {
        int i = 0;
        F(i++, i++, i++);
        F(z: i++, x: i++);
    }
}
```
產生下列輸出
```
x = 0, y = 1, z = 2
x = 4, y = -1, z = 3
```

陣列共同變異數規則 ([陣列共變數](arrays.md#array-covariance)) 允許值的陣列型別`A[]`是陣列型別的執行個體的參考`B[]`，前提是隱含參考轉換存在從`B`至`A`. 因為這些規則，當陣列元素的*reference_type*傳遞做為參考或輸出參數，執行階段檢查，才能確保陣列的實際項目型別完全相同的參數。 在範例
```csharp
class Test
{
    static void F(ref object x) {...}

    static void Main() {
        object[] a = new object[10];
        object[] b = new string[10];
        F(ref a[0]);        // Ok
        F(ref b[1]);        // ArrayTypeMismatchException
    }
}
```
第二個引動過程`F`會導致`System.ArrayTypeMismatchException`因為實際的項目類型的擲回`b`是`string`而非`object`。

在展開的形式叫用含有參數陣列的函式成員時，引動過程處理完全如同陣列建立運算式中使用陣列初始設定式 ([陣列建立運算式](expressions.md#array-creation-expressions)) 周圍插入展開的參數。 例如，假設宣告
```csharp
void F(int x, int y, params object[] args);
```
展開的形式的方法中的下列引動過程
```csharp
F(10, 20);
F(10, 20, 30, 40);
F(10, 20, 1, "hello", 3.0);
```
實際上會對應至
```csharp
F(10, 20, new object[] {});
F(10, 20, new object[] {30, 40});
F(10, 20, new object[] {1, "hello", 3.0});
```

特別是，請注意，給定的參數陣列引數時，會建立空的陣列。

當從對應的選擇性參數的函式成員，會省略引數時，函式成員宣告的預設引數會以隱含方式傳遞。 由於這些一律是常數，則其評估不會影響其餘引數的評估順序。

### <a name="type-inference"></a>型別推斷

未指定類型引數，呼叫泛型方法時***型別推斷***程序會嘗試推斷呼叫的型別引數。 型別推斷的目前狀態可讓更方便的語法，以設定用來呼叫泛型方法，並可以讓程式設計師，若要避免指定備援類型資訊。 例如，假設方法宣告：
```csharp
class Chooser
{
    static Random rand = new Random();

    public static T Choose<T>(T first, T second) {
        return (rand.Next(2) == 0)? first: second;
    }
}
```
可叫用`Choose`不需明確指定型別引數的方法：
```csharp
int i = Chooser.Choose(5, 213);                 // Calls Choose<int>

string s = Chooser.Choose("foo", "bar");        // Calls Choose<string>
```

透過型別推斷，型別引數`int`和`string`方法取決於從引數。

型別推斷，就會發生的繫結階段處理的方法引動過程的一部分 ([方法引動過程](expressions.md#method-invocations)) 和引動過程多載解析步驟之前會發生。 當未指定特定方法群組中的方法引動過程，和任何類型引數會指定為方法引動過程的一部分時，型別推斷會套用到方法群組中每個泛型方法。 如果型別推斷成功，則會使用以判斷後續多載解析的引數型別推斷的型別引數。 如果多載解析會選擇做為要叫用泛型方法，則會使用推斷的型別引數為實際型別引數的引動過程。 如果特定方法的型別推斷失敗，該方法不會參與多載解析。 失敗的型別推斷，本身，不會繫結時間錯誤。 不過，它通常會導致繫結錯誤時若要尋找任何適用的方法就會多載解析失敗。

如果提供的引數是不同的方法中的參數數目，則推斷立即失敗。 否則，假設泛型的方法具有下列簽章：
```csharp
Tr M<X1,...,Xn>(T1 x1, ..., Tm xm)
```

方法呼叫的表單`M(E1...Em)`的型別推斷工作是要尋找唯一的型別引數`S1...Sn`每個類型參數`X1...Xn`以便呼叫`M<S1...Sn>(E1...Em)`變成有效。

推斷程序期間，每個類型參數`Xi`是*修正*成特定的型別`Si`或*unfixed*具有一組相關聯的*界限*. 每個範圍都是某種類型`T`。 一開始，每個型別變數`Xi`是 unfixed 與範圍的空集合。

型別推斷會採用階段中的位置。 每個階段會嘗試推斷類型引數的多個類型的變數，根據前一個階段的結果。 第一個階段會讓一些初始推斷的範圍中，而第二個階段可以修正特定類型的型別變數，並推測進一步界限。 第二個階段可能是重複次數。

*注意：* 型別推斷就會發生不只會呼叫泛型方法。 所述的方法群組轉換的型別推斷[的方法群組轉換的型別推斷](expressions.md#type-inference-for-conversion-of-method-groups)尋找一組運算式的最常用的型別述[找出一組常見的最佳類型運算式的](expressions.md#finding-the-best-common-type-of-a-set-of-expressions)。

#### <a name="the-first-phase"></a>第一個階段

針對每個方法引數的`Ei`:

*   如果`Ei`是匿名的函式*明確的參數型別推斷*([明確的參數型別推斷](expressions.md#explicit-parameter-type-inferences)) 從進行`Ei`至 `Ti`
*   否則，如果`Ei`具有型別的`U`並`xi`是實值參數則會顯示*下限推斷*進行*從* `U` *至*`Ti`.
*   否則，如果`Ei`具有型別的`U`並`xi`是`ref`或`out`參數則*精確推斷*進行*從* `U`*要* `Ti`。
*   否則，無法推斷會將這個引數。


#### <a name="the-second-phase"></a>第二個階段

第二個階段如下所示：

*   所有*unfixed*類型變數`Xi`哪些則否*取決於*([相依性](expressions.md#dependence)) 任何`Xj`固定的 ([正在修復](expressions.md#fixing)).
*   如果存在這類的型別變數，全部*unfixed*類型變數`Xi`會*修正*，下列全部保留：
    *   至少一個型別變數`Xj`相依於 `Xi`
    *   `Xi` 具有非空白集的範圍
*   如果沒有這類的型別變數存在，而且還有*unfixed*類型變數、 類型推斷失敗。
*   否則，如果有任何進一步*unfixed*有型別變數、 型別推斷會成功。
*   否則，所有引數`Ei`與對應參數類型`Ti`所在*輸出類型*([輸出類型](expressions.md#output-types)) 包含*unfixed*輸入變數`Xj`但*輸入型別*([的輸入類型](expressions.md#input-types)) 未這麼做，*輸出型別推斷*([輸出型別推斷](expressions.md#output-type-inferences)) 由*從* `Ei` *來* `Ti`。 然後，系統會重複第二個階段。

#### <a name="input-types"></a>輸入的類型

如果`E`是方法群組或隱含型別的匿名函式與`T`則委派型別或運算式樹狀架構類型的所有參數類型`T`會*的輸入類型*的`E` *與類型* `T`。

####  <a name="output-types"></a>輸出類型

如果`E`方法群組或匿名函式與`T`是委派型別或運算式樹狀架構型別則傳回型別`T`是*輸出的型別* `E` *類型* `T`.

#### <a name="dependence"></a>相依性

*Unfixed*類型變數`Xi`*直接相依於*unfixed 型別變數`Xj`某些引數的 if`Ek`類型`Tk` `Xj`中，就會發生*輸入類型*的`Ek`類型`Tk`並`Xi`中發生*輸出類型*的`Ek`類型`Tk`。

`Xj` *取決於*`Xi`如果`Xj`*直接相依於*`Xi`或者`Xi`*直接相依於*`Xk`和`Xk`*而定* `Xj`。 因此 「 相依於 」 是 「 相依於直接 」 的可轉移的但不是 （reflexive relationship） 結束。

#### <a name="output-type-inferences"></a>輸出型別推斷

*輸出型別推斷*更為*從*運算式`E`*至*類型`T`方式如下：

*  如果`E`推斷傳回類型為匿名函式`U`([推斷傳回型別](expressions.md#inferred-return-type)) 和`T`是委派類型或傳回類型的運算式樹狀架構類型`Tb`，然後*下限推斷*([下限推斷](expressions.md#lower-bound-inferences)) 進行*從* `U` *到* `Tb`。
*  否則，如果`E`是方法群組和`T`是委派型別或參數類型的運算式樹狀架構型`T1...Tk`和傳回型別`Tb`，和的多載解析`E`類型`T1...Tk`產生單一方法的傳回型別`U`，則會顯示*下限推斷*進行*從* `U` *至* `Tb`。
*  否則，如果`E`是一個運算式與型別`U`，則會顯示*下限推斷*進行*從* `U` *到* `T`.
*  否則，會不進行任何推斷。

#### <a name="explicit-parameter-type-inferences"></a>明確的參數型別推斷

*明確的參數型別推斷*更為*從*運算式`E`*至*類型`T`方式如下：

*  如果`E`是以參數類型的明確型別的匿名函式`U1...Uk`並`T`是委派型別或參數類型的運算式樹狀架構類型`V1...Vk`然後針對每個`Ui`*確切推斷*([精確推斷](expressions.md#exact-inferences)) 進行*從* `Ui` *至*對應`Vi`。

#### <a name="exact-inferences"></a>精確推斷

*精確推斷**從*型別的`U`*至*類型`V`為止，如下所示：

*  如果`V`是其中一個*unfixed* `Xi`然後`U`新增至確切繫結的一組`Xi`。

*  否則，會設定`V1...Vk`和`U1...Uk`取決於檢查如果下列任何情況下套用：

   *  `V` 陣列型別`V1[...]`並`U`是陣列類型`U1[...]`相同的順序
   *  `V` 是的型別`V1?`和`U`是類型 `U1?`
   *  `V` 是建構的型別`C<V1...Vk>`和`U`為建構的類型 `C<U1...Uk>`

   如果任何這些情況下再*精確推斷*進行*從*每個`Ui`*至*對應`Vi`。

*  否則，系統會不進行任何推斷。

#### <a name="lower-bound-inferences"></a>下限推斷

A*下限推斷**從*類型`U`*至*類型`V`為止，如下所示：

*  如果`V`是其中一個*unfixed* `Xi`然後`U`新增至集合的下限`Xi`。
*  否則，如果`V`是型別`V1?`並`U`是型別`U1?`則會進行從下限推斷`U1`至`V1`。
*  否則，會設定`U1...Uk`和`V1...Vk`取決於檢查如果下列任何情況下套用：
   *  `V` 陣列型別`V1[...]`並`U`是陣列類型`U1[...]`(或型別參數的有效基底型別`U1[...]`) 相同的順序
   *  `V` 是其中一個`IEnumerable<V1>`，`ICollection<V1>`或是`IList<V1>`並`U`是一維陣列類型`U1[]`(或類型參數的有效基底型別`U1[]`)
   *  `V` 是建構的類別、 結構、 介面或委派型別`C<V1...Vk>`，而且沒有唯一的型別`C<U1...Uk>`使得`U`(或者，如果`U`型別參數，其有效的基底類別或其有效的介面集的任何成員) 是完全一樣，繼承自 （直接或間接），或實作 （直接或間接） `C<U1...Uk>`。

      ("唯一性 」 限制表示大小寫的介面中`C<T> {} class U: C<X>, C<Y> {}`，然後從推斷時，才無法推斷`U`來`C<T>`因為`U1`可能`X`或`Y`。)

   如果任何這些情況下則會進行推斷*從*每個`Ui`*來*對應`Vi`，如下所示：

   *  如果`Ui`不已知為參考型別就*精確推斷*進行
   *  否則，如果`U`是陣列類型則會顯示*下限推斷*進行
   *  否則，如果`V`已`C<V1...Vk>`推斷而定的第 i 個類型參數則`C`:
      *  如果它是 covariant 則會顯示*下限推斷*為止。
      *  如果其為 contravariant 就*上限推斷*為止。
      *  如果非變異就*精確推斷*進行。
*  否則，會不進行任何推斷。

#### <a name="upper-bound-inferences"></a>上限推斷

*上限推斷**從*型別的`U`*至*類型`V`為止，如下所示：

*  如果`V`是其中一個*unfixed* `Xi`然後`U`加到上限的集合`Xi`。
*  否則，會設定`V1...Vk`和`U1...Uk`取決於檢查如果下列任何情況下套用：
   *  `U` 陣列型別`U1[...]`並`V`是陣列類型`V1[...]`相同的順序
   *  `U` 是其中一個`IEnumerable<Ue>`，`ICollection<Ue>`或是`IList<Ue>`和`V`是一維陣列類型 `Ve[]`
   *  `U` 是的型別`U1?`和`V`是類型 `V1?`
   *  `U` 建構的類別、 結構、 介面或委派的型別`C<U1...Uk>`和`V`是類別、 結構、 介面或委派的類型，也就是完全一樣，繼承自 （直接或間接） 或實作 （直接或間接） 唯一的型別 `C<V1...Vk>`

      (「 唯一性 」 限制表示，如果我們有`interface C<T>{} class V<Z>: C<X<Z>>, C<Y<Z>>{}`，然後從推斷時，才無法推斷`C<U1>`來`V<Q>`。 推斷不會從`U1`設為`X<Q>`或`Y<Q>`。)

   如果任何這些情況下則會進行推斷*從*每個`Ui`*來*對應`Vi`，如下所示：
   *  如果`Ui`不已知為參考型別就*精確推斷*進行
   *  否則，如果`V`陣列型別就*上限推斷*進行
   *  否則，如果`U`已`C<U1...Uk>`推斷而定的第 i 個類型參數則`C`:
      *  如果它是 covariant 就*上限推斷*為止。
      *  如果這是逆變性則會顯示*下限推斷*進行。
      *  如果非變異就*精確推斷*進行。
*  否則，會不進行任何推斷。   

#### <a name="fixing"></a>修正

*Unfixed*類型變數`Xi`界限的一組會*修正*，如下所示：

*  一組*候選型別*`Uj`界限的集合中的所有類型的集合一開始都`Xi`。
*  然後，我們檢驗每個繫結的`Xi`依次：每個實際的繫結`U`的`Xi`所有型別`Uj`並不是等於`U`從候選項目集合中移除。 針對每個下限`U`的`Xi`所有型別`Uj`若其中有要*不*的隱含轉換`U`從候選項目集合中移除。 針對每個的上限`U`的`Xi`所有型別`Uj`從它*不*隱含轉換成`U`從候選項目集合中移除。
*  如果在剩餘的候選項目類型之間`Uj`沒有唯一的型別`V`包括不的隱含轉換為所有其他的候選項目類型，然後從`Xi`會固定為`V`。
*  否則，型別推斷會失敗。

#### <a name="inferred-return-type"></a>推斷傳回型別

推斷傳回類型的匿名函式`F`會使用於型別推斷和多載解析。 所有的參數型別已知，可能是因為它們已明確指定，其中提供透過匿名函式轉換或推斷泛型上為封入型別推斷期間的匿名函式只可以判斷推斷傳回型別方法引動過程。

***推斷結果型別***判斷方式如下：

*  如果主體`F`已*運算式*具有一個型別，則推斷的結果型別`F`是該運算式的型別。
*  如果主體`F`是*區塊*和運算式中的區塊集`return`陳述式有最佳的一般型別`T`([找出最佳的常見類型的一組運算式](expressions.md#finding-the-best-common-type-of-a-set-of-expressions))，然後的推斷的結果型別`F`是`T`。
*  否則，結果型別無法推斷`F`。

***推斷傳回型別***判斷方式如下：

*  如果`F`且非同步的主體`F`是歸類為執行任何動作的運算式 ([運算式分類](expressions.md#expression-classifications))，或陳述式區塊，其中沒有 return 陳述式有運算式，推斷傳回類型 `System.Threading.Tasks.Task`
*  如果`F`非同步處理，且具有推斷的結果型別`T`，推斷傳回類型為`System.Threading.Tasks.Task<T>`。
*  如果`F`非同步，且具有推斷的結果型別`T`，推斷傳回類型為`T`。
*  否則傳回的型別無法推斷`F`。

涉及匿名函式的型別推斷的範例，請考慮`Select`擴充方法中宣告`System.Linq.Enumerable`類別：
```csharp
namespace System.Linq
{
    public static class Enumerable
    {
        public static IEnumerable<TResult> Select<TSource,TResult>(
            this IEnumerable<TSource> source,
            Func<TSource,TResult> selector)
        {
            foreach (TSource element in source) yield return selector(element);
        }
    }
}
```

假設`System.Linq`與已匯入命名空間`using`子句，並假設類別`Customer`與`Name`型別的屬性`string`，`Select`方法可用來選取一份客戶清單的名稱：
```csharp
List<Customer> customers = GetCustomerList();
IEnumerable<string> names = customers.Select(c => c.Name);
```

擴充方法引動過程 ([擴充方法引動過程](expressions.md#extension-method-invocations)) 的`Select`處理重寫至靜態方法的引動過程的引動過程：
```csharp
IEnumerable<string> names = Enumerable.Select(customers, c => c.Name);
```

因為未明確指定類型引數，型別推斷來推斷類型引數。 首先，`customers`引數與相關`source`參數，推斷`T`要`Customer`。 然後，使用匿名函式輸入上面所述的推斷程序`c`為 object 型別`Customer`，和運算式`c.Name`相關的傳回型別`selector`參數，推斷`S`要`string`. 因此，此引動過程相當於
```csharp
Sequence.Select<Customer,string>(customers, (Customer c) => c.Name)
```
結果會是類型`IEnumerable<string>`。

下列範例示範如何匿名函式型別推斷可讓 「 順著 」 中的泛型方法引動過程的引數之間的型別資訊。 有了方法：
```csharp
static Z F<X,Y,Z>(X value, Func<X,Y> f1, Func<Y,Z> f2) {
    return f2(f1(value));
}
```

引動過程的型別推斷：
```csharp
double seconds = F("1:15:30", s => TimeSpan.Parse(s), t => t.TotalSeconds);
```
繼續進行，如下所示：首先，引數`"1:15:30"`與相關`value`參數，推斷`X`要`string`。 接著，第一個匿名函式的參數`s`，指定推斷的型別`string`，和運算式`TimeSpan.Parse(s)`相關的傳回型別`f1`、 推斷`Y`要`System.TimeSpan`。 最後，第二個匿名函式的參數`t`，指定推斷的型別`System.TimeSpan`，和運算式`t.TotalSeconds`相關的傳回型別`f2`、 推斷`Z`要`double`。 因此，此引動過程的結果屬於類型`double`。

#### <a name="type-inference-for-conversion-of-method-groups"></a>方法群組轉換的型別推斷

與泛型方法的呼叫相似，型別推斷也必須套用方法群組時`M`包含泛型方法會轉換成指定的委派型別`D`([方法群組轉換](conversions.md#method-group-conversions))。 指定方法
```csharp
Tr M<X1...Xn>(T1 x1 ... Tm xm)
```
和方法群組`M`指派給委派型別`D`的型別推斷工作是要尋找型別引數`S1...Sn`以便運算式：
```csharp
M<S1...Sn>
```
會變成相容 ([委派宣告](delegates.md#delegate-declarations)) 與`D`。

不同於一般方法呼叫的型別推斷演算法，在此情況下有只有引數*型別*，沒有引數*運算式*。 特別是，沒有匿名函式，因此不需要推斷的多個階段。

相反地，所有`Xi`會被視為*unfixed*，以及*下限推斷*進行*從*每個引數類型`Uj`的`D`*要*的對應參數類型`Tj`的`M`。 如果任一`Xi`找不到任何界限、 型別推斷失敗。 否則，所有`Xi`會*固定*對應`Si`，是型別推斷的結果。

#### <a name="finding-the-best-common-type-of-a-set-of-expressions"></a>找出一組運算式的最常見類型

在某些情況下，常見的類型必須為一組運算式推斷。 在特定的隱含類型陣列的項目類型，使用匿名函式的傳回型別*區塊*主體可在這種方式。

直接易懂的方式，提供一組運算式`E1...Em`此推斷應該是相當於呼叫方法
```csharp
Tr M<X>(X x1 ... X xm)
```
使用`Ei`做為引數。

更精確地說，推斷開頭*unfixed*類型變數`X`。 *輸出型別推斷*就會*從*每個`Ei`*來* `X`。 最後，`X`已*修正*而且，如果成功，所產生的輸入`S`是運算式結果最常見的類型。 如果沒有這種`S`存在，這些運算式具有不常見的最佳類型。

### <a name="overload-resolution"></a>多載解析

多載解析會選取最佳函式成員叫用指定的引數清單和一組候選函式成員的繫結階段機制。 多載解析會選取要在 C# 中的下列不同內容中叫用的函式成員：

*  在名為方法引動過程*invocation_expression* ([方法引動過程](expressions.md#method-invocations))。
*  在中命名的執行個體建構函式的引動過程*object_creation_expression* ([物件建立運算式](expressions.md#object-creation-expressions))。
*  透過索引子存取子的引動過程*element_access* ([項目存取](expressions.md#element-access))。
*  在運算式中參考的預先定義或使用者定義運算子的引動過程 ([一元運算子多載解析](expressions.md#unary-operator-overload-resolution)並[二元運算子多載解析](expressions.md#binary-operator-overload-resolution))。

每個這些內容定義一組候選函式成員及引數清單在它自己的唯一方式，如上面所列各節中的詳細資料中所述。 比方說，方法引動過程的候選項目集不包含標記的方法`override`([成員查閱](expressions.md#member-lookup))，以及基底類別中的方法不是候選項目是否適用於在衍生類別中的任何方法 ([方法引動過程](expressions.md#method-invocations))。

一旦識別候選函式成員 」 和 「 引數清單，選取最佳函式成員是在所有情況下相同的：

*  指定適用的候選函式成員的集合，最佳的函式成員，因為位於集。 如果集合包含只有一個函式成員，該函式成員就會是最佳的函式成員。 否則，最佳成員就是優於相對於指定的引數清單中，所有其他函式成員，前提是每個函式成員相較於使用中的規則中其他函式成員的一個函式成員[更好的函式成員](expressions.md#better-function-member)。 如果不是正好一個優於其他所有函式成員的函式成員，然後函式成員引動過程模稜兩可，並在繫結階段錯誤發生。

下列章節會定義詞彙的確切意義***適用的函式成員***並***更好的函式成員***。

#### <a name="applicable-function-member"></a>可用的函式成員

函式成員即為***適用的函式成員***引數清單而言`A`當所有下列條件成立：

*  在每個引數`A`對應至函式成員宣告中的參數中所述[相對應參數](expressions.md#corresponding-parameters)，沒有引數對應任何參數是選擇性的參數。
*  中的每個引數`A`、 參數傳遞的引數的模式 (亦即，值`ref`，或`out`) 等同於相對應的參數，參數傳遞模式和
   *  value 參數或參數陣列，隱含的轉換 ([隱含轉換](conversions.md#implicit-conversions)) 從引數存在之對應參數的型別或
   *  針對`ref`或`out`參數的引數類型是與對應參數的型別相同。 畢竟`ref`或`out`參數是傳遞的引數的別名。

包含的參數陣列的函式成員函式成員是否適用上述規則，它稱為適用於其***一般形式***。 如果不適用一般形式，包括參數陣列的函式成員，函式成員而可能適用於其***展開表單***:

*  擴充的形式的建構函式成員宣告中的參數陣列取代零或更多值參數的項目型別參數的陣列，例如該引數清單中的引數數目`A`符合總計參數的數目。 如果`A`函式成員宣告中有比固定的參數數目的引數數目少，無法建構函式成員的展開的表單，並因此並不適用。
*  否則，請展開的形式是適用於每個引數中如果`A`引數的參數傳遞模式完全相同之對應參數的參數傳遞模式和
   *  固定的值參數，或建立的擴充，也就是隱含的轉換值參數 ([隱含轉換](conversions.md#implicit-conversions)) 之對應參數的型別引數的型別或
   *  針對`ref`或`out`參數的引數類型是與對應參數的型別相同。

#### <a name="better-function-member"></a>更好的函式成員

為了判斷更好的函式成員，精簡的引數清單的會建構包含只是引數中的運算式本身原始的引數清單中出現的順序。

參數會列出每個候選函式成員建構方式如下：

*  只適用於展開的形式的函式成員時，會使用展開的形式。
*  沒有對應的引數的選擇性參數是從參數清單中移除
*  使這些備份在做為對應的引數的相同位置的引數清單中，已重新排列參數。

指定引數清單`A`與一組引數運算式`{E1, E2, ..., En}`和兩個可用的函式成員`Mp`並`Mq`與參數型別`{P1, P2, ..., Pn}`和`{Q1, Q2, ..., Qn}`，`Mp`會定義為***更好的函式成員***比`Mq`如果

*  每個引數，從隱含轉換`Ex`要`Qx`不是優於隱含方式轉換`Ex`到`Px`，和
*  至少一個引數，從轉換`Ex`要`Px`優於從轉換`Ex`至`Qx`。

如果執行這項評估時`Mp`或`Mq`是適用於其展開的形式，則`Px`或`Qx`指的是參數清單的展開表單中的參數。

如果參數型別序列 `{P1, P2, ..., Pn}`和`{Q1, Q2, ..., Qn}`是相等的 (也就是每個`Pi`具有身分識別轉換至對應`Qi`)，套用下列繫結分行規則，以順序，以判斷好函式成員。

*  如果`Mp`是一種非泛型方法和`Mq`是泛型方法，則`Mp`優於`Mq`。
*  否則，如果`Mp`適用於一般形式及`Mq`已`params`陣列，且只適用於其展開的形式，然後`Mp`優於`Mq`。
*  否則，如果`Mp`具有多個宣告參數多於`Mq`，然後`Mp`優於`Mq`。 這可能會發生這兩種方法有`params`陣列且只適用於其展開的形式。
*  否則如果所有參數的`Mp`有相對應的引數，而需要用來取代中至少一個選擇性參數的預設引數`Mq`再`Mp`優於`Mq`。
*  否則，如果`Mp`具有更特定的參數型別比`Mq`，然後`Mp`優於`Mq`。 可讓`{R1, R2, ..., Rn}`並`{S1, S2, ..., Sn}`代表的未具現化及未展開的參數型別`Mp`和`Mq`。 `Mp`參數型別都比更明確`Mq`的每個參數，如果`Rx`不是較不特定比`Sx`，和至少一個參數，如`Rx`比更特定`Sx`:
   *  較不特定非類型參數的型別參數。
   *  以遞迴方式，建構的型別是具體比另一個建構的類型 （具有型別引數數目相同） 至少一個類型引數是否更明確，而且沒有型別引數比對應的型別引數，在其他較不明確。
   *  如果第一個項目型別是比第二個項目類型更特定，陣列型別是 （具有相同的維度數目） 的另一個陣列型別比更明確。
*  否則如果一個成員是提昇的運算子，另一個是提昇的運算子，非提昇的是較佳。
*  否則，都不函式成員較佳。

#### <a name="better-conversion-from-expression"></a>更好轉換運算式

提供的隱含轉換`C1`可將運算式的轉換`E`型別`T1`，並隱含地轉換`C2`可將運算式的轉換`E`型別`T2`， `C1`已***更好的轉換***比`C2`如果`E`不完全符合`T2`，至少下列其中之一會裝載：

* `E` 完全符合`T1`([完全比對運算式](expressions.md#exactly-matching-expression))
* `T1` 是更好的轉換目標比`T2`([更好的轉換目標](expressions.md#better-conversion-target))

#### <a name="exactly-matching-expression"></a>完全比對運算式

指定運算式`E`和型別`T`，`E`完全符合`T`如果下列其中一種保留：

*  `E` 具有類型`S`，且從身分識別轉換`S`至 `T`
*  `E` 是匿名的函式`T`是委派型別`D`或運算式樹狀架構類型`Expression<D>`和下列其中一種保留：
   *  推斷的傳回型別`X`存在於`E`的參數清單的內容中`D`([推斷傳回型別](expressions.md#inferred-return-type))，且從身分識別轉換`X`的傳回型別 `D`
   *  任一`E`是非同步和`D`的傳回型別`Y`或`E`是非同步和`D`的傳回型別`Task<Y>`，而且下列其中一種保存：
      * 主體`E`是一種運算式完全相符 `Y`
      * 主體`E`是陳述式區塊，其中每個傳回陳述式會傳回的運算式也完全相符項目 `Y`

#### <a name="better-conversion-target"></a>更好的轉換目標

提供兩種不同類型`T1`並`T2`，`T1`是更好的轉換目標比`T2`如果沒有隱含的轉換，從`T2`至`T1`存在，而且至少下列其中之一會保存：

*  從的隱含轉換`T1`至`T2`存在
*  `T1` 是委派型別`D1`或運算式樹狀架構型別`Expression<D1>`，`T2`是委派型別`D2`或運算式樹狀架構型別`Expression<D2>`，`D1`的傳回型別`S1`以及其中一個下列保留：
   * `D2` 傳回 void
   * `D2` 傳回型別`S2`，和`S1`是更好的轉換目標比 `S2`
*  `T1` 已`Task<S1>`，`T2`是`Task<S2>`，和`S1`是更好的轉換目標比 `S2`
*  `T1` 是`S1`或`S1?`其中`S1`是帶正負號的整數類資料類型，以及`T2`會`S2`或`S2?`其中`S2`是不帶正負號的整數類資料類型。 尤其是：
   * `S1` 已`sbyte`並`S2`是`byte`， `ushort`， `uint`，或 `ulong`
   * `S1` 已`short`並`S2`是`ushort`， `uint`，或 `ulong`
   * `S1` 已`int`並`S2`是`uint`，或 `ulong`
   * `S1` 已`long`和`S2`是 `ulong`

#### <a name="overloading-in-generic-classes"></a>多載泛型類別中

雖然宣告的簽章必須是唯一的就可以替代型別引數會導致相同的簽章。 在此情況下，上述的多載解析的繫結分行規則將會挑選最特定的成員。

下列範例會顯示有效和無效根據這個規則的多載：

```csharp
interface I1<T> {...}

interface I2<T> {...}

class G1<U>
{
    int F1(U u);                  // Overload resolution for G<int>.F1
    int F1(int i);                // will pick non-generic

    void F2(I1<U> a);             // Valid overload
    void F2(I2<U> a);
}

class G2<U,V>
{
    void F3(U u, V v);            // Valid, but overload resolution for
    void F3(V v, U u);            // G2<int,int>.F3 will fail

    void F4(U u, I1<V> v);        // Valid, but overload resolution for    
    void F4(I1<V> v, U u);        // G2<I1<int>,int>.F4 will fail

    void F5(U u1, I1<V> v2);      // Valid overload
    void F5(V v1, U u2);

    void F6(ref U u);             // valid overload
    void F6(out V v);
}
```

### <a name="compile-time-checking-of-dynamic-overload-resolution"></a>編譯時期檢查動態的多載解析

最動態繫結的作業是在編譯時期未知組可能的候選項目進行解析。 不過在某些情況下，候選集合是已知在編譯時間：

*  與動態引數的靜態方法呼叫
*  其中接收者不是動態運算式的執行個體方法呼叫
*  索引子呼叫，其中接收者不是動態運算式
*  與動態引數的建構函式呼叫

在這些情況下，有限的編譯時間檢查會針對每個候選項目，以查看 是否其中任何可能無法套用在執行階段執行的。這項檢查包含下列步驟：

*  部分型別推斷：任何類型引數，而不會直接或間接的型別引數`dynamic`使用的規則會推斷[型別推斷](expressions.md#type-inference)。 其餘的型別引數是未知的。
*  部分的適用性檢查：根據檢查適用性[適用的函式成員](expressions.md#applicable-function-member)，但忽略其類型是未知的參數。
*  如果沒有候選人通過此測試，就會發生編譯時期錯誤。

### <a name="function-member-invocation"></a>函式成員引動過程

本章節描述的程序發生在執行階段叫用的特定函式成員。 它會假設階段繫結程序已經決定要叫用，可能是藉由套用多載解析，以一組候選函式成員的特定成員。

描述叫用處理序的目的而言，函式成員分成兩個類別：

*  靜態函式成員。 這些是執行個體建構函式、 靜態方法，靜態屬性存取子和使用者定義的運算子。 靜態函式成員一律為非虛擬的。
*  執行個體函式成員。 這些是執行個體方法 」、 「 執行個體屬性存取子和 「 索引子存取子。 執行個體函式成員非虛擬或虛擬的並一律在特定的執行個體上叫用。 執行個體運算式，會計算執行個體，並內為該函式成員存取變得`this`([這項存取](expressions.md#this-access))。

執行階段的處理函式成員引動過程包含下列步驟中，其中`M`是函式成員而且，如果`M`是執行個體成員，只有`E`是執行個體運算式：

*  如果`M`是靜態函式成員：
   * 當引數清單中所述，會評估[引數清單](expressions.md#argument-lists)。
   * `M` 會叫用。

*  如果`M`執行個體函式成員宣告中*value_type*:
   * `E` 會評估。 如果此評估會產生例外狀況，則會不執行任何進一步的步驟。
   * 如果`E`不會分類為變數，則的暫存區域變數`E`的型別建立，而`E`指派給該變數。 `E` 然後分類為該暫存的本機變數的參考。 暫存變數是那樣`this`內`M`，但不是在任何其他方式。 因此，只有當`E`是的則為 true 的變數是讓呼叫端所作的變更，`M`對`this`。
   * 當引數清單中所述，會評估[引數清單](expressions.md#argument-lists)。
   * `M` 會叫用。 所參考的變數`E`變成所參考的變數`this`。

*  如果`M`執行個體函式成員宣告中*reference_type*:
   * `E` 會評估。 如果此評估會產生例外狀況，則會不執行任何進一步的步驟。
   * 當引數清單中所述，會評估[引數清單](expressions.md#argument-lists)。
   * 如果類型`E`是*value_type*，boxing 轉換 ([Boxing 轉換](types.md#boxing-conversions)) 會執行轉換`E`輸入`object`，和`E`會被視為必須是類型`object`在下列步驟。 在此情況下，`M`僅可屬於`System.Object`。
   * 值`E`檢查為有效。 如果值`E`已`null`、`System.NullReferenceException`就會擲回，而且會執行任何進一步的步驟。
   * 決定要叫用函式成員實作：
     * 如果繫結階段類型`E`是一種介面，來叫用的函式成員是實作`M`所參考的執行個體的執行階段類型提供`E`。 此函式成員由套用的介面對應規則 ([介面對應](interfaces.md#interface-mapping)) 來判斷實作`M`所參考的執行個體的執行階段類型提供`E`。
     * 否則，如果`M`是虛擬函式成員，來叫用的函式成員是實作`M`所參考的執行個體的執行階段類型提供`E`。 此函式成員由套用規則來決定最具衍生性的實作 ([虛擬方法](classes.md#virtual-methods)) 的`M`相對於所參考的執行個體的執行階段類型`E`。
     * 否則，請`M`非虛擬函式成員，並叫用的函式成員`M`本身。
   * 在上述步驟中決定的成員函式實作會叫用。 所參考的物件`E`變成所參考的物件`this`。

#### <a name="invocations-on-boxed-instances"></a>經過 boxing 處理的執行個體上的引動過程

函式成員中實作*value_type*透過經過 boxing 處理的執行個體，就可以叫用*value_type*在下列情況：

*  函式成員時`override`的方法繼承自型別的`object`，並叫用類型的執行個體運算式透過`object`。
*  當函式成員的是實作介面函式成員的位置，並透過執行個體運算式的叫用*interface_type*。
*  透過委派叫用函式成員時。

在這些情況下，已封裝的執行個體視為包含的變數*value_type*，而這個變數會變成所參考的變數`this`內函式成員引動過程。 特別是，這表示，已封裝的執行個體上叫用函式成員時，可能會修改已封裝的執行個體中包含的值的函式成員。

## <a name="primary-expressions"></a>主要運算式

主要運算式包含最簡單的形式的運算式。

```antlr
primary_expression
    : primary_no_array_creation_expression
    | array_creation_expression
    ;

primary_no_array_creation_expression
    : literal
    | interpolated_string_expression
    | simple_name
    | parenthesized_expression
    | member_access
    | invocation_expression
    | element_access
    | this_access
    | base_access
    | post_increment_expression
    | post_decrement_expression
    | object_creation_expression
    | delegate_creation_expression
    | anonymous_object_creation_expression
    | typeof_expression
    | checked_expression
    | unchecked_expression
    | default_value_expression
    | nameof_expression
    | anonymous_method_expression
    | primary_no_array_creation_expression_unsafe
    ;
```

主要運算式分屬*array_creation_expression*s 並*primary_no_array_creation_expression*s。 如此一來，將陣列建立運算式，而非列出的其他簡單運算式的表單，以及可讓這類不允許可能令人混淆的程式碼的文法
```csharp
object o = new int[3][1];
```
這會否則會被解譯為
```csharp
object o = (new int[3])[1];
```

### <a name="literals"></a>常值

A *primary_expression*這是組成*常值*([常值](lexical-structure.md#literals)) 會分類為值。


### <a name="interpolated-strings"></a>插入字串

*Interpolated_string_expression*組成`$`正負號的後面接著定期或逐字字串常值，其中漏洞，分隔`{`和`}`、 括住的運算式和格式化規格。 字串插值的運算式是結果*interpolated_string_literal* ，具有已分割成個別的語彙基元中所述[插補字串常值](lexical-structure.md#interpolated-string-literals)。

```antlr
interpolated_string_expression
    : '$' interpolated_regular_string
    | '$' interpolated_verbatim_string
    ;

interpolated_regular_string
    : interpolated_regular_string_whole
    | interpolated_regular_string_start interpolated_regular_string_body interpolated_regular_string_end
    ;

interpolated_regular_string_body
    : interpolation (interpolated_regular_string_mid interpolation)*
    ;

interpolation
    : expression
    | expression ',' constant_expression
    ;

interpolated_verbatim_string
    : interpolated_verbatim_string_whole
    | interpolated_verbatim_string_start interpolated_verbatim_string_body interpolated_verbatim_string_end
    ;

interpolated_verbatim_string_body
    : interpolation (interpolated_verbatim_string_mid interpolation)+
    ;
```

*Constant_expression*插補中必須有隱含轉換成`int`。

*Interpolated_string_expression*會分類為值。 如果立即轉換成`System.IFormattable`或是`System.FormattableString`隱含的字串插值轉換 ([隱含插補字串轉換](conversions.md#implicit-interpolated-string-conversions))，字串插值的運算式有該型別。 否則，它具有類型`string`。

字串插值的類型是否`System.IFormattable`或是`System.FormattableString`，意思是呼叫`System.Runtime.CompilerServices.FormattableStringFactory.Create`。 如果類型是`string`，運算式的意義是呼叫`string.Format`。 在這兩種情況下，呼叫的引數清單包含格式字串常值預留位置的每個插補，與每個對應到預留位置的運算式的引數。

格式字串常值的建構如下，其中`N`中的內插補點數目*interpolated_string_expression*:

*  如果*interpolated_regular_string_whole*該*interpolated_verbatim_string_whole*遵循`$`登入，則格式字串常值是該語彙基元。
*  否則，格式字串常值所組成： 
   *  第一個*interpolated_regular_string_start*或*interpolated_verbatim_string_start*
   *  然後針對每一個數字`I`從`0`到`N-1`: 
      * 十進位表示法 `I`
      * 之後，如果對應*插補*已*constant_expression*，則`,`（逗號） 後面的值的十進位表示法*constant_expression*
      * 然後*interpolated_regular_string_mid*， *interpolated_regular_string_end*， *interpolated_verbatim_string_mid*或*interpolated_verbatim_string_end*緊接著對應的插補。

後續的引數是只要*運算式*從*內插補點*（如果有的話），在順序中。

TODO： 範例。


### <a name="simple-names"></a>簡單名稱

A *simple_name*識別項，並且選擇性地加型別引數清單所組成：

```antlr
simple_name
    : identifier type_argument_list?
    ;
```

A *simple_name*是其中一種形式`I`，或格式`I<A1,...,Ak>`，其中`I`是以單一識別項和`<A1,...,Ak>`是選擇性*type_argument_list*。 若未*type_argument_list*會指定，請考慮`K`為零。 *Simple_name*評估和分類，如下所示：

*  如果`K`為零， *simple_name*內會出現*區塊*如果*區塊*的 (或為封入*區塊*的) 本機變數宣告空間 ([宣告](basic-concepts.md#declarations)) 包含本機變數、 參數或常數名稱 `I`，然後在*simple_name*參考該區域變數參數或常數，而分類為變數或值。
*  如果`K`為零， *simple_name*出現在泛型方法宣告的主體內，如果宣告包含名稱的型別參數 `I`，則*simple_name*指的是該型別參數。
*  否則，對於每個執行個體型別 `T`([執行個體類型](classes.md#the-instance-type))，開始立即封入型別宣告的執行個體類型，並繼續進行的每個封入類別或結構的執行個體類型宣告 （如果有的話）：
   *  如果`K`是零，宣告`T`包含名稱的型別參數 `I`，然後在*simple_name*指的是該型別參數。
   *  否則，如果成員查閱 ([成員查閱](expressions.md#member-lookup)) 的`I`中`T`具有`K` 型別引數會產生相符項目：
      * 如果`T`與其直接封入類別或結構類型的執行個體類型和查閱找出一或多個方法，結果是具有相關聯的執行個體運算式的方法群組`this`。 如果指定型別引數清單，則用來呼叫泛型方法 ([方法引動過程](expressions.md#method-invocations))。
      * 否則，如果`T`是立即封入類別或結構類型的執行個體類型，如果查閱識別執行個體成員，且參考發生的執行個體建構函式、 執行個體方法或執行個體存取子的主體內結果是成員存取相同 ([成員存取](expressions.md#member-access)) 格式的`this.I`。 這只會發生時`K`為零。
      * 否則，結果就是成員存取相同 ([成員存取](expressions.md#member-access)) 的表單`T.I`或`T.I<A1,...,Ak>`。 在此情況下，它會繫結時間錯誤*simple_name*參考執行個體成員。

*  否則，對於每個命名空間 `N`，從命名空間，其中*simple_name*發生，請繼續進行與每個封入命名空間 （如果有的話），和全域命名空間中，做為結尾，則下列步驟評估直到找到實體為止：
   *  如果`K`為零並`I`中的命名空間名稱 `N`，然後：
      * 如果位置所在*simple_name*就會發生加上命名空間宣告`N`且命名空間宣告包含*extern_alias_directive*或*using_alias_directive* ，將名稱產生關聯 `I`與命名空間或類型，則*simple_name*模稜兩可，就會發生編譯時期錯誤。
      * 否則，請*simple_name*名為命名空間是指`I`在`N`。
   *  否則，如果`N`包含可存取的型別具有名稱 `I`並`K` 型別參數，然後：
      * 如果`K`是零，位置所在*simple_name*就會發生加上命名空間宣告`N`和命名空間宣告包含*extern_alias_directive*或*using_alias_directive* ，將名稱產生關聯 `I`命名空間或類型，則*simple_name*模稜兩可並發生編譯時期錯誤。
      * 否則，請*namespace_or_type_name*指的是使用指定的型別引數建構的類型。
   *  否則，如果位置所在*simple_name*就會發生加上命名空間宣告 `N`:
      * 如果`K`為零，而命名空間宣告包含*extern_alias_directive*或是*using_alias_directive*名稱建立關聯的 `I`與匯入的命名空間或型別，則*simple_name*參考到該命名空間或型別。
      * 否則，如果所匯入的命名空間和類型的宣告*using_namespace_directive*s 並*using_static_directive*的命名空間宣告包含一個可存取的型別或不可擴充的靜態成員具有名稱 `I`並`K` 型別參數，則*simple_name*參考該類型或成員建構具有指定的型別引數。
      * 否則，如果匯入的命名空間和類型*using_namespace_directive*的命名空間宣告包含一個以上可存取的型別或非擴充方法的靜態成員具有名稱 `I`並`K` 型別參數，則*simple_name*模稜兩可並發生錯誤。

   請注意，這整個步驟是在處理對應的步驟完全平行*namespace_or_type_name* ([命名空間和型別名稱](basic-concepts.md#namespace-and-type-names))。

*  否則，請*simple_name*是未定義，而且會發生編譯時期錯誤。


### <a name="parenthesized-expressions"></a>括號運算式

A *parenthesized_expression*組成*運算式*括號括住。

```antlr
parenthesized_expression
    : '(' expression ')'
    ;
```

A *parenthesized_expression*評估藉由評估*運算式*括號內。 如果*運算式*括號內代表命名空間或型別，就會發生編譯時期錯誤。 否則，結果*parenthesized_expression*是包含評估的結果*運算式*。

### <a name="member-access"></a>成員存取

A *member_access*組成*primary_expression*，則*predefined_type*，或*qualified_alias_member*，後面接著"`.`「 語彙基元，後面接著*識別項*，選擇性地接著*type_argument_list*。

```antlr
member_access
    : primary_expression '.' identifier type_argument_list?
    | predefined_type '.' identifier type_argument_list?
    | qualified_alias_member '.' identifier
    ;

predefined_type
    : 'bool'   | 'byte'  | 'char'  | 'decimal' | 'double' | 'float' | 'int' | 'long'
    | 'object' | 'sbyte' | 'short' | 'string'  | 'uint'   | 'ulong' | 'ushort'
    ;
```

*Qualified_alias_member*中所定義的生產環境[命名空間別名限定詞](namespaces.md#namespace-alias-qualifiers)。

A *member_access*是其中一種形式`E.I`，或格式`E.I<A1, ..., Ak>`，其中`E`是主要運算式`I`是以單一識別項和`<A1, ..., Ak>`是選擇性*type_argument_list*。 若未*type_argument_list*會指定，請考慮`K`為零。

A *member_access*具有*primary_expression*型別的`dynamic`動態繫結 ([動態繫結](expressions.md#dynamic-binding))。 在此情況下，編譯器會將成員存取分類為類型的屬性存取`dynamic`。 規則來判斷的意義*member_access*接著會在執行階段，而不編譯時期類型使用的執行階段型別套用*primary_expression*。 如果此執行階段分類會導致方法群組，則必須是成員存取*primary_expression*的*invocation_expression*。

*Member_access*評估和分類，如下所示：

*  如果`K`為零並`E`是命名空間並`E`包含具有名稱的巢狀命名空間 `I`，則結果為該命名空間。
*  否則，如果`E`是命名空間並`E`包含可存取的型別具有名稱 `I`並`K` 型別參數，則結果為使用指定的型別引數建構的型別。
*  如果`E`是*predefined_type*或*primary_expression*分類為型別，如果`E`不是類型參數，而且如果成員查閱 ([成員查閱](expressions.md#member-lookup))`I`中`E`具有`K` 型別參數會產生相符項目，然後`E.I`評估和分類，如下所示：
   *  如果`I`識別類型，則結果為使用指定的型別引數建構的型別。
   *  如果`I`識別一或多個方法，則結果為沒有相關聯的執行個體運算式的方法群組。 如果指定型別引數清單，則用來呼叫泛型方法 ([方法引動過程](expressions.md#method-invocations))。
   *  如果`I`識別`static`屬性，則結果是沒有相關聯的執行個體運算式的屬性存取。
   *  如果`I`識別`static`欄位：
      * 如果欄位是`readonly`和參考，就會發生的類別或結構中宣告的欄位，靜態建構函式之外，則結果為一個值，也就是靜態欄位的值 `I`在 `E`。
      * 否則，結果就是一個變數，也就是靜態欄位 `I`在 `E`。
   *  如果`I`識別`static`事件：
      * 如果參考就會發生在類別或結構中宣告事件，並在宣告事件時未*event_accessor_declarations* ([事件](classes.md#events))，然後`E.I`完全處理如同`I`靜態欄位。
      * 否則，結果就是事件存取沒有相關聯的執行個體的運算式。
   *  如果`I`識別常數，則結果為一個值，也就是該常數的值。
    * 如果`I`識別列舉成員，則結果為一個值，也就是該列舉成員的值。
    * 否則，`E.I`是無效的成員參考，則會發生編譯時期錯誤。
*  如果`E`是屬性存取、 索引子存取、 變數或值的類型是 `T`，和成員查閱 ([成員查閱](expressions.md#member-lookup)) 的`I`中`T`具有`K`  型別引數會產生相符項目，然後`E.I`評估和分類，如下所示：
   *  首先，如果`E`是屬性或索引子存取，則屬性的值，或取得索引子存取 ([運算式的值](expressions.md#values-of-expressions)) 和`E`分類為值。
   *  如果`I`識別一或多個方法，則結果為方法群組有相關聯的執行個體運算式`E`。 如果指定型別引數清單，則用來呼叫泛型方法 ([方法引動過程](expressions.md#method-invocations))。
   *  如果`I`識別一個執行個體的屬性，
      * 如果`E`已`this`，`I`識別自動實作的屬性 ([自動實作屬性](classes.md#automatically-implemented-properties)) 沒有 setter 和參考，就會發生的執行個體建構函式類別或結構的型別`T`，則結果為變數時，也就是隱藏的支援欄位所指定之自動屬性`I`執行個體中`T`藉由指定`this`。
      * 否則，結果就是具有相關聯的執行個體運算式的屬性存取 `E`。
   *  如果`T`已*class_type*並`I`識別該執行個體欄位*class_type*:
      * 如果值`E`已`null`，則會顯示`System.NullReferenceException`就會擲回。
      * 否則，如果欄位是`readonly`和參考，就會發生在宣告的欄位，該類別的執行個體建構函式之外，則結果為一個值，也就是欄位的值 `I`中所參考的物件 `E`。
      * 否則，結果就是一個變數，也就是欄位 `I`中所參考的物件 `E`。
   *  如果`T`已*struct_type*並`I`識別該執行個體欄位*struct_type*:
      * 如果`E`是一個值，或如果欄位是`readonly`和參考，就會發生在宣告的欄位，該結構的執行個體建構函式之外，則結果為一個值，也就是欄位的值 `I`中所指定的結構執行個體 `E`.
      * 否則，結果就是一個變數，也就是欄位 `I`中所指定的結構執行個體 `E`。
   *  如果`I`識別執行個體的事件：
      * 如果參考就會發生在類別或結構中宣告事件，並在宣告事件時未*event_accessor_declarations* ([事件](classes.md#events))，並為不會發生參考左手邊`+=`或是`-=`運算子，然後`E.I`完全處理如同`I`已執行個體欄位。
      * 否則，結果就是具有相關聯的執行個體運算式的事件存取 `E`。
*  否則，嘗試處理`E.I`作為擴充方法引動過程 ([擴充方法引動過程](expressions.md#extension-method-invocations))。 如果失敗，`E.I`是無效的成員參考，並在繫結階段錯誤發生。

#### <a name="identical-simple-names-and-type-names"></a>相同簡單名稱和類型名稱

在表單的成員存取`E.I`，如果`E`是單一的識別項，而且如果的意義`E`做為*simple_name* ([簡單名稱](expressions.md#simple-names)) 是常數、 欄位、 屬性，本機變數或參數類型與相同類型的意義`E`做為*type_name* ([命名空間和型別名稱](basic-concepts.md#namespace-and-type-names))，則這兩個可能的意思的`E`是允許使用。 兩個可能的意思`E.I`永遠都不會模稜兩可，因為`I`一定必須是型別的成員`E`這兩種情況。 換句話說，此規則僅允許存取的靜態成員和巢狀型別`E`在已經發生編譯時期錯誤。 例如: 
```csharp
struct Color
{
    public static readonly Color White = new Color(...);
    public static readonly Color Black = new Color(...);

    public Color Complement() {...}
}

class A
{
    public Color Color;                // Field Color of type Color

    void F() {
        Color = Color.Black;           // References Color.Black static member
        Color = Color.Complement();    // Invokes Complement() on Color field
    }

    static void G() {
        Color c = Color.White;         // References Color.White static member
    }
}
```

#### <a name="grammar-ambiguities"></a>文法模稜兩可

針對生產*simple_name* ([簡單名稱](expressions.md#simple-names)) 和*member_access* ([成員存取](expressions.md#member-access)) 可以常理的語意模糊運算式的文法。 例如，陳述式：
```
F(G<A,B>(7));
```
無法解譯為呼叫`F`兩個引數時，`G < A`和`B > (7)`。 或者，它可解譯為呼叫`F`一個引數，也就是泛型方法的呼叫 `G`具有兩個類型引數和一個一般引數。

如果語彙基元序列中可剖析 （內容） 作為*simple_name* ([簡單名稱](expressions.md#simple-names))， *member_access* ([成員存取](expressions.md#member-access))，或*pointer_member_access* ([指標成員存取](unsafe-code.md#pointer-member-access)) 以結束*type_argument_list* ([型別引數](types.md#type-arguments))，緊接在結尾的語彙基元`>`語彙基元會進行檢查。 如果它是其中一個
```csharp
(  )  ]  }  :  ;  ,  .  ?  ==  !=  |  ^
```
然後*type_argument_list*保留為一部分*simple_name*， *member_access*或*pointer_member_access*以及任何其他可能的剖析的語彙基元順序會被捨棄。 否則，請*type_argument_list*不是要納入*simple_name*， *member_access*或*pointer_member_access*，即使沒有任何其他可能的語彙基元序列的剖析。 請注意，這些規則不會套用時剖析*type_argument_list*中*namespace_or_type_name* ([命名空間和型別名稱](basic-concepts.md#namespace-and-type-names))。 陳述式
```csharp
F(G<A,B>(7));
```
將根據這項規則，會解譯為呼叫`F`一個引數，也就是泛型方法的呼叫`G`具有兩個類型引數和一個一般引數。 陳述式
```csharp
F(G < A, B > 7);
F(G < A, B >> 7);
```
將每個會解譯為呼叫`F`兩個引數。 陳述式
```csharp
x = F < A > +y;
```
將會視為已撰寫的陳述式必須解譯為小於運算子，大於運算子和一元加號運算子`x = (F < A) > (+y)`，而不是做為*simple_name*具有*type_argument_list*後面接著二元加法運算子。 陳述式中
```csharp
x = y is C<T> + z;
```
語彙基元`C<T>`解譯為*namespace_or_type_name*具有*type_argument_list*。

### <a name="invocation-expressions"></a>叫用運算式

*Invocation_expression*用來叫用方法。

```antlr
invocation_expression
    : primary_expression '(' argument_list? ')'
    ;
```

*Invocation_expression*動態繫結 ([動態繫結](expressions.md#dynamic-binding)) 如果至少下列其中之一為：

* *Primary_expression*編譯時期類型`dynamic`。
* 至少一個引數的選擇性*argument_list*已編譯時期型別`dynamic`並*primary_expression*沒有委派型別。

在此情況下，編譯器會將分類*invocation_expression*類型的值為`dynamic`。 規則來判斷的意義*invocation_expression*接著會在執行階段，使用執行階段類型，而不編譯時期型別，這些的套用*primary_expression*和已在編譯時期型別引數`dynamic`。 如果*primary_expression*沒有編譯時期型別`dynamic`，則方法叫用在中所述，就會進行有限的編譯時間檢查[編譯時期檢查動態的多載解析](expressions.md#compile-time-checking-of-dynamic-overload-resolution).

*Primary_expression*的*invocation_expression*必須是方法群組或值*delegate_type*。 如果*primary_expression*是方法群組*invocation_expression*是方法的引動過程 ([方法引動過程](expressions.md#method-invocations))。 如果*primary_expression*的值*delegate_type*，則*invocation_expression*是委派引動過程 ([委派引動過程](expressions.md#delegate-invocations)). 如果*primary_expression*是方法群組和值都不*delegate_type*，則繫結階段會發生錯誤。

選擇性*argument_list* ([引數清單](expressions.md#argument-lists)) 方法的參數提供值或變數參考。

評估的結果*invocation_expression*分類如下：

*  如果*invocation_expression*叫用方法或委派，會傳回`void`，結果就是執行任何動作。 運算式分類為不允許的內容中，只有*statement_expression* ([運算式陳述式](statements.md#expression-statements)) 或作為主體*lambda_expression*([匿名函式運算式](expressions.md#anonymous-function-expressions))。 否則就會發生的繫結階段錯誤。
*  否則，結果就是方法或委派傳回類型的值。

#### <a name="method-invocations"></a>方法引動過程

方法引動過程中， *primary_expression*的*invocation_expression*必須是方法群組。 叫用的一個方法或一組可供選擇要叫用的特定方法的多載方法，就會識別方法群組。 在後者的情況下，判斷特定的方法來叫用為基礎的類型中的引數所提供的內容*argument_list*。

繫結階段處理表單的方法引動過程`M(A)`，其中`M`是方法群組 (可能包括*type_argument_list*)，並`A`是選擇性*argument_清單*，包含下列步驟：

*  建構一組方法引動過程的候選項目方法。 每個方法`F`方法群組相關聯`M`:
   *  如果`F`為非泛型`F`是候選時：
      * `M` 沒有型別引數清單，以及
      * `F` 相對於適用於`A`([適用的函式成員](expressions.md#applicable-function-member))。
   *  如果`F`是泛型並`M`沒有型別引數清單中，`F`是候選時：
      * 型別推斷 ([型別推斷](expressions.md#type-inference)) 成功，推斷的型別引數呼叫，清單和
      * 所有建構型別參數清單中的 F 一旦推斷的型別引數會取代對應的方法類型參數，滿足其條件約束 ([滿足條件約束](types.md#satisfying-constraints))，並的參數清單`F`相對於適用於`A`([適用的函式成員](expressions.md#applicable-function-member))。
   *  如果`F`是泛型並`M`包含型別引數清單，`F`是候選時：
      * `F` 在類型引數清單中，提供了有相同數目的方法類型參數與
      * 所有建構型別參數清單中的 F 型別引數會取代對應的方法類型參數，一旦滿足其條件約束 ([滿足條件約束](types.md#satisfying-constraints))，以及參數清單`F`相對於適用於`A`([適用的函式成員](expressions.md#applicable-function-member))。
*  一組候選項目方法會減少到只包含方法的最具衍生性的類型：每個方法`C.F`集中，其中`C`是在其中的型別方法`F`宣告，基底類型中宣告的所有方法`C`從集合中移除。 此外，如果`C`而不是類別類型`object`，介面型別中宣告的所有方法會從集合中都移除。 （這個第二個規則只能有影響方法群組時需要有效的基底類別以外的物件和設定的非空白有效的介面的型別參數的成員查閱的結果）。
*  如果候選項目方法的結果集是空的再進一步處理沿著下列步驟會放棄，並改為嘗試處理為擴充方法引動過程的引動過程 ([擴充方法引動過程](expressions.md#extension-method-invocations)). 如果失敗，則不適用的方法存在，並在繫結階段錯誤發生。
*  一組候選項目方法的最佳方法用的多載解析規則來識別[多載解析](expressions.md#overload-resolution)。 如果找不到單一的最佳方法，方法引動過程模稜兩可，並在繫結階段錯誤發生。 執行多載解析時，泛型方法的參數後，會考慮替代的型別引數 （提供或推斷） 相對應的方法型別參數。
*  最終驗證所選的最佳方法被執行：
   * 方法會進行驗證的方法群組內容中：最好的方法是靜態方法，如果方法群組必須起因*simple_name*或是*member_access*透過型別。 最好的方法是執行個體方法，如果方法群組必須起因*simple_name*，則*member_access*透過變數或值，或*base_access*。 如果這些需求都為 true，則繫結階段會發生錯誤。
   * 最好的方法是泛型方法，如果型別引數 （提供或推斷） 會針對條件約束檢查 ([滿足條件約束](types.md#satisfying-constraints)) 宣告之泛型方法。 如果任何類型引數未滿足型別參數上的對應條件約束，繫結階段會發生錯誤。

當方法有選取，而且繫結時間經過上述步驟時，根據函式成員引動過程中所述的規則處理實際的執行階段引動過程[編譯時期檢查動態的多載解析](expressions.md#compile-time-checking-of-dynamic-overload-resolution).

上面所述的解析規則的直覺式的效果如下所示：若要尋找特定的方法叫用的方法引動過程，開頭的方法引動過程所表示的類型，並繼續繼承鏈結，直到找到至少一個適用、 存取、 非覆寫方法宣告。 然後執行型別推斷和多載解析將適用、 存取、 非覆寫的方法，該類型中宣告的集合，並叫用選取的方法。 如果找不到任何方法，請嘗試改為處理為擴充方法引動過程的引動過程。

#### <a name="extension-method-invocations"></a>擴充方法引動過程

方法引動過程中 ([經過 boxing 處理的執行個體上的引動過程](expressions.md#invocations-on-boxed-instances)) 的其中一種格式
```csharp
expr . identifier ( )

expr . identifier ( args )

expr . identifier < typeargs > ( )

expr . identifier < typeargs > ( args )
```
如果叫用的正常處理發現沒有適用的方法，會嘗試處理為擴充方法引動過程的建構。 如果*expr*或任何*args*編譯時期類型`dynamic`，將不會套用的擴充方法。

本節目標是要找出最*type_name* `C`，如此一來，可以進行對應的靜態方法引動過程：
```csharp
C . identifier ( expr )

C . identifier ( expr , args )

C . identifier < typeargs > ( expr )

C . identifier < typeargs > ( expr , args )
```

擴充方法`Ci.Mj`已***合格***如果：

*  `Ci` 非泛型、 非巢狀類別
*  名稱`Mj`是*識別碼*
*  `Mj` 是可存取且適用於如上所示，套用至引數作為靜態方法
*  隱含的身分識別、 參考或 boxing 轉換存在*expr*的第一個參數的型別`Mj`。

搜尋`C`程序如下：

*  開頭為最接近封入命名空間宣告，每個封入的命名空間宣告，再繼續，並以包含編譯單位中，作為結束連續嘗試尋找一組候選的擴充方法：
   * 如果指定的命名空間或編譯單位就會直接包含非泛型型別宣告`Ci`符合資格的擴充方法與`Mj`，則這些擴充方法的集合是候選集合。
   * 如果類型`Ci`匯入*using_static_declarations*並直接匯入的命名空間中宣告*using_namespace_directive*指定命名空間或編譯單位中直接的 s包含符合資格的擴充方法`Mj`，則這些擴充方法的集合是候選集合。
*  如果找到任何封入的命名空間宣告或編譯單位中沒有候選項目集，則會發生編譯時期錯誤。
*  多載解析候選版本中所述，設定的套用，否則為 ([多載解析](expressions.md#overload-resolution))。 如果找不到任何單一的最佳方法，就會發生編譯時期錯誤。
*  `C` 是在其中的最佳方法宣告為擴充方法的類型。

使用`C`做為目標，方法呼叫接著會處理當做靜態方法的引動過程 ([編譯時期檢查動態的多載解析](expressions.md#compile-time-checking-of-dynamic-overload-resolution))。

上述規則表示，執行個體方法優先於延伸方法、，內部命名空間宣告所提供的延伸模組方法優先於外部命名空間宣告和該延伸模組中可用的擴充方法直接在命名空間中宣告方法的優先順序高於匯入到該相同的命名空間中使用的擴充方法的命名空間指示詞。 例如: 
```csharp
public static class E
{
    public static void F(this object obj, int i) { }

    public static void F(this object obj, string s) { }
}

class A { }

class B
{
    public void F(int i) { }
}

class C
{
    public void F(object obj) { }
}

class X
{
    static void Test(A a, B b, C c) {
        a.F(1);              // E.F(object, int)
        a.F("hello");        // E.F(object, string)

        b.F(1);              // B.F(int)
        b.F("hello");        // E.F(object, string)

        c.F(1);              // C.F(object)
        c.F("hello");        // C.F(object)
    }
}
```

在範例中，`B`的方法都優先於第一個擴充方法，和`C`的方法的優先順序高於這兩個擴充方法。

```csharp
public static class C
{
    public static void F(this int i) { Console.WriteLine("C.F({0})", i); }
    public static void G(this int i) { Console.WriteLine("C.G({0})", i); }
    public static void H(this int i) { Console.WriteLine("C.H({0})", i); }
}

namespace N1
{
    public static class D
    {
        public static void F(this int i) { Console.WriteLine("D.F({0})", i); }
        public static void G(this int i) { Console.WriteLine("D.G({0})", i); }
    }
}

namespace N2
{
    using N1;

    public static class E
    {
        public static void F(this int i) { Console.WriteLine("E.F({0})", i); }
    }

    class Test
    {
        static void Main(string[] args)
        {
            1.F();
            2.G();
            3.H();
        }
    }
}
```

此範例的輸出為：
```
E.F(1)
D.G(2)
C.H(3)
```
`D.G` 優先順序高於`C.G`，並`E.F`優先於兩者`D.F`和`C.F`。

#### <a name="delegate-invocations"></a>委派引動過程

委派引動過程中， *primary_expression*的*invocation_expression*的值必須*delegate_type*。 此外，考慮*delegate_type*是相同的參數清單的函式成員*delegate_type*，則*delegate_type*必須適用於 （[適用的函式成員](expressions.md#applicable-function-member)) 相對於*argument_list*的*invocation_expression*。

執行階段處理表單的委派引動過程`D(A)`，其中`D`是*primary_expression*的*delegate_type*並`A`是選擇性的*argument_list*，包含下列步驟：

*  `D` 會評估。 如果此評估會產生例外狀況，則會不執行任何進一步的步驟。
*  值`D`檢查為有效。 如果值`D`已`null`、`System.NullReferenceException`就會擲回，而且會執行任何進一步的步驟。
*  否則，`D`委派執行個體的參考。 函式成員叫用 ([編譯時期檢查動態的多載解析](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) 會在每個委派引動過程清單中的可呼叫實體上執行。 對於可呼叫的實體，其中包含執行個體和執行個體方法，叫用執行個體是可呼叫的實體中所包含的執行個體。

### <a name="element-access"></a>項目存取

*Element_access*組成*primary_no_array_creation_expression*，後面接著"`[`"語彙基元，後面接著*argument_list*，後面接著"`]`"token。 *Argument_list*包含一個或多個*引數*s，並以逗號分隔。

```antlr
element_access
    : primary_no_array_creation_expression '[' expression_list ']'
    ;
```

*Argument_list*的*element_access*不允許包含`ref`或`out`引數。

*Element_access*動態繫結 ([動態繫結](expressions.md#dynamic-binding)) 如果至少下列其中之一為：

* *Primary_no_array_creation_expression*編譯時期類型`dynamic`。
* 至少一個運算式*argument_list*已編譯時期型別`dynamic`並*primary_no_array_creation_expression*沒有陣列型別。

在此情況下，編譯器會將分類*element_access*類型的值為`dynamic`。 規則來判斷的意義*element_access*接著會在執行階段，使用執行階段類型，而不編譯時期型別，這些的套用*primary_no_array_creation_expression*並*argument_list*運算式有在編譯時期型別`dynamic`。 如果*primary_no_array_creation_expression*沒有編譯時期型別`dynamic`，然後項目存取在中所述，就會進行有限的編譯時間檢查[編譯時期檢查動態多載解析](expressions.md#compile-time-checking-of-dynamic-overload-resolution)。

如果*primary_no_array_creation_expression*的*element_access*的值*array_type*，則*element_access*是陣列存取 ([陣列存取](expressions.md#array-access))。 否則，請*primary_no_array_creation_expression*必須是變數或值的類別、 結構或介面型別具有一或多個索引子的成員，在此情況下*element_access*是索引子存取 ([索引子存取](expressions.md#indexer-access))。

#### <a name="array-access"></a>陣列存取

存取陣列*primary_no_array_creation_expression*的*element_access*的值必須*array_type*。 此外， *argument_list*陣列的存取不允許包含具名引數。中的運算式數目*argument_list*必須是相同的陣序規範*array_type*，和每個運算式必須是型別`int`， `uint`， `long`， `ulong`，或必須是隱含地轉換成一或多個這些型別。

評估陣列存取的結果是陣列，也就是陣列項目中之運算式的值所選取的項目類型的變數*argument_list*。

陣列存取表單的執行階段處理`P[A]`，其中`P`是*primary_no_array_creation_expression*的*array_type*並`A`是*argument_list*，包含下列步驟：

*  `P` 會評估。 如果此評估會產生例外狀況，則會不執行任何進一步的步驟。
*  索引運算式*argument_list*的評估順序，從左到右。 遵循每個索引運算式時，隱含轉換的評估結果 ([隱含轉換](conversions.md#implicit-conversions)) 執行下列類型的其中一個： `int`， `uint`， `long`， `ulong`。 第一個類型的隱含轉換存在，這份清單中選擇。 比方說，索引運算式屬於類型`short`然後隱含轉換成`int`會執行，因為隱含轉換，從`short`來`int`進出`short`至`long`可能會有。 如果評估的索引運算式或後續的隱含轉換導致例外狀況，然後沒有進一步的索引運算式會評估，並不再執行的步驟。
*  值`P`檢查為有效。 如果值`P`已`null`、`System.NullReferenceException`就會擲回，而且會執行任何進一步的步驟。
*  在每個運算式的值*argument_list*會針對每個維度的陣列執行個體所參考的實際界限檢查`P`。 如果一或多個值超出範圍，`System.IndexOutOfRangeException`就會擲回，而且會執行任何進一步的步驟。
*  計算指定之索引運算式的陣列元素的位置，及此位置會變成陣列存取的結果。

#### <a name="indexer-access"></a>索引子存取

索引子存取，如*primary_no_array_creation_expression*的*element_access*必須是變數或值的類別、 結構或介面型別，而且此型別必須實作一或多個適用於與索引子*argument_list*的*element_access*。

索引子存取表單的繫結時間處理`P[A]`，其中`P`是*primary_no_array_creation_expression*的類別、 結構或介面型別`T`，和`A`是*argument_list*，包含下列步驟：

*  所提供的索引子組`T`建構。 集合，包含的所有宣告索引子`T`或基底型別`T`不是`override`宣告和可存取在目前內容中 ([成員存取](basic-concepts.md#member-access))。
*  集合會縮減為那些索引子可適用且不是隱藏的其他索引子。 下列規則會套用至每個索引子`S.I`集中，其中`S`是要在其中類型索引子`I`宣告：
   * 如果`I`不適用相對於`A`([適用的函式成員](expressions.md#applicable-function-member))，然後`I`從集合中移除。
   * 如果`I`相對於適用於`A`([適用的函式成員](expressions.md#applicable-function-member))，然後將所有索引子宣告基底類型中`S`從集合中移除。
   * 如果`I`相對於適用於`A`([適用的函式成員](expressions.md#applicable-function-member)) 和`S`而不是類別類型`object`，介面中宣告的所有索引子會從集合中移除。
*  如果候選索引子的結果集是空的則不適用的索引子存在，並繫結階段發生錯誤。
*  候選索引子一組最佳的索引子用的多載解析規則來識別[多載解析](expressions.md#overload-resolution)。 如果找不到單一最佳的索引子，索引子存取模稜兩可，並在繫結階段錯誤發生。
*  索引運算式*argument_list*的評估順序，從左到右。 處理索引子存取的結果是歸類為索引子存取的運算式。 索引子存取運算式參考的索引子，在上述步驟中決定，而且沒有相關聯的執行個體的運算式`P`和相關聯的引數清單的`A`。

根據在其中使用的內容，索引子存取造成的其中一個引動過程*get 存取子*或*set 存取子*的索引子。 索引子存取做為目標的指派，如果*set 存取子*會叫用來指派新值 ([簡單指派](expressions.md#simple-assignment))。 在其他情況下， *get 存取子*會叫用來取得目前的值 ([運算式的值](expressions.md#values-of-expressions))。

### <a name="this-access"></a>此存取權

A *this_access*包含保留字`this`。

```antlr
this_access
    : 'this'
    ;
```

A *this_access*只有在允許*區塊*的執行個體建構函式、 執行個體方法，或執行個體存取子。 它具有下列意義的其中一個：

*  當`this`用於*primary_expression*內類別的執行個體建構函式，它會分類為值。 值的類型是此執行個體類型 ([的執行個體類型](classes.md#the-instance-type)) 的類別，在其中使用方式，就會發生，而值是所建構物件的參考。
*  當`this`用於*primary_expression*內的執行個體方法或類別的執行個體存取子，它會分類為值。 值的類型是此執行個體類型 ([的執行個體類型](classes.md#the-instance-type)) 的類別內的使用方式，就會發生，且值為已叫用方法或存取子時物件的參考。
*  當`this`用於*primary_expression*結構的執行個體建構函式，它會被歸類為變數。 變數的類型是此執行個體類型 ([的執行個體類型](classes.md#the-instance-type)) 在其中使用方式，就會發生，且該變數代表所建構之結構的結構。 `this`結構的執行個體建構函式的變數的行為完全相同`out`結構型別的參數 — 特別是，這表示，必須在執行個體的每個執行路徑中明確指派變數建構函式。
*  當`this`用於*primary_expression*內的執行個體方法或結構的執行個體存取子，它會被歸類為變數。 變數的類型是此執行個體類型 ([的執行個體類型](classes.md#the-instance-type)) 的使用狀況中的結構。
   * 如果方法或存取子不是迭代器 ([迭代器](classes.md#iterators))，則`this`變數代表的方法或存取子為叫用與行為完全相同的結構`ref`結構類型的參數。
   * 如果方法或存取子是迭代器，`this`變數代表的結構，並以其方法或存取子為叫用的行為與實值參數的結構類型完全相同複本。

利用`this`中*primary_expression*上面所列以外的內容中是編譯時期錯誤。 特別是，不可以參考`this`中的靜態方法，靜態屬性存取子，或在*variable_initializer*欄位宣告。

### <a name="base-access"></a>基底存取

A *base_access*包含保留字`base`後面 」`.`"語彙基元和的識別碼或*argument_list*以方括弧括住：

```antlr
base_access
    : 'base' '.' identifier
    | 'base' '[' expression_list ']'
    ;
```

A *base_access*用來存取目前的類別或結構中同樣的具名成員隱藏基底類別成員。 A *base_access*只有在允許*區塊*的執行個體建構函式、 執行個體方法，或執行個體存取子。 當`base.I`類別或結構中，就會發生`I`必須代表該類別或結構的基底類別的成員。 同樣地，當`base[E]`，就會發生在類別中，適當的索引子必須存在於基底類別。

在繫結階段*base_access*形式的運算式`base.I`並`base[E]`會進行評估，完全如同它們以寫入`((B)this).I`和`((B)this)[E]`，其中`B`之類別的基底類別或在其中建構，就會發生的結構。 因此，`base.I`並`base[E]`對應至`this.I`並`this[E]`，除了`this`視為基底類別的執行個體。

當*base_access*參考其中判斷函式成員，才能在執行階段叫用的虛擬函式成員 （方法、 屬性或索引子），([編譯時期檢查動態的多載解析](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) 已變更。 叫用的函式成員由尋找最具衍生性的實作 ([虛擬方法](classes.md#virtual-methods)) 函式成員相對於`B`(而不是相關的執行階段類型`this`，做為一般非基底存取）。 因此，在`override`的`virtual`函式成員*base_access*可以用來叫用函式成員的繼承的實作。 如果所參考的函式成員*base_access*是抽象的則繫結階段會發生錯誤。

### <a name="postfix-increment-and-decrement-operators"></a>後置遞增和遞減運算子

```antlr
post_increment_expression
    : primary_expression '++'
    ;

post_decrement_expression
    : primary_expression '--'
    ;
```

運算元的後置遞增或遞減作業必須是運算式分類為變數、 屬性存取或索引子存取。 作業的結果是相同的型別運算元的值。

如果*primary_expression*已在編譯時期型別`dynamic`然後運算子動態繫結 ([動態繫結](expressions.md#dynamic-binding))，則*post_increment_expression*或是*post_decrement_expression*已在編譯時期型別`dynamic`，並在執行階段使用的執行階段型別套用下列規則*primary_expression*。

如果後置的運算元遞增或遞減運算是屬性或索引子存取、 屬性或索引子必須兩者`get`和`set`存取子。 如果這不是這樣，繫結階段會發生錯誤。

一元運算子多載解析 ([一元運算子多載解析](expressions.md#unary-operator-overload-resolution)) 套用至選取的特定運算子實作。 預先定義的`++`並`--`運算子有下列類型： `sbyte`， `byte`， `short`， `ushort`， `int`， `uint`， `long`， `ulong`， `char``float`， `double`， `decimal`，以及任何列舉類型。 預先定義`++`運算子會傳回運算元，而預先定義上加 1，所產生的值`--`運算子會傳回所產生的減去 1 的運算元的值。 在 `checked`情況下，如果這個加法或減法運算的結果超出結果型別的範圍和結果型別是整數類資料類型或列舉型別，`System.OverflowException`就會擲回。

執行階段的處理後置遞增或遞減運算的表單`x++`或`x--`包含下列步驟：

*   如果`x`分類為變數：
    * `x` 在評估後產生的變數。
    * 值`x`儲存。
    * 選取的運算子會叫用儲存的值是`x`作為其引數。
    * 運算子的傳回值會儲存在評估所指定的位置`x`。
    * 已儲存的值`x`變成作業的結果。
*   如果`x`歸類為屬性或索引子的存取：
    * 執行個體運算式 (如果`x`不是`static`) 和引數清單 (如果`x`是索引子存取) 相關聯`x`會進行評估，而且結果會用於後續`get`和`set`存取子引動過程。
    * `get`存取子`x`叫用，並儲存傳回的值。
    * 選取的運算子會叫用儲存的值是`x`作為其引數。
    * `set`存取子`x`會使用該運算子作為所傳回的值叫用其`value`引數。
    * 已儲存的值`x`變成作業的結果。

`++`並`--`運算子也支援前置標記法 ([前置遞增和遞減運算子](expressions.md#prefix-increment-and-decrement-operators))。 一般而言，結果`x++`或`x--`的值`x`作業之前，而結果`++x`或`--x`的值`x`作業之後。 在任一情況下，`x`本身具有相同的值在作業之後。

`operator ++`或`operator --`實作可以使用來叫用前置詞或後置標記法。 您不可以有兩種標記法的個別運算子實作。

### <a name="the-new-operator"></a>new 運算子

`new`運算子用來建立新的執行個體的型別。

有三種形式的`new`運算式：

*  物件建立運算式用來建立新的執行個體的類別型別和實值型別。
*  陣列建立運算式用來建立新的執行個體的陣列類型。
*  委派建立運算式用來建立委派的新執行個體類型。

`new`運算子隱含建立的類型執行個體，但不一定表示動態配置的記憶體。 尤其，實值型別的執行個體需要任何額外的記憶體超過變數所在，和任何動態配置發生時`new`用來建立實值型別的執行個體。

#### <a name="object-creation-expressions"></a>物件建立運算式

*Object_creation_expression*用來建立的新執行個體*class_type*或是*value_type*。

```antlr
object_creation_expression
    : 'new' type '(' argument_list? ')' object_or_collection_initializer?
    | 'new' type object_or_collection_initializer
    ;

object_or_collection_initializer
    : object_initializer
    | collection_initializer
    ;
```

*型別*的*object_creation_expression*必須是*class_type*，則*value_type*或*type_parameter*. *型別*不得`abstract` *class_type*。

選擇性*argument_list* ([引數清單](expressions.md#argument-lists))，才允許*型別*是*class_type*或*struct_型別*。

物件建立運算式可以省略建構函式引數清單和封閉的括號提供它包含的物件初始設定式 」 或 「 集合初始設定式。 省略建構函式引數清單和封入括號相當於指定空白的引數清單。

處理的物件建立運算式，其中包含的物件初始設定式 」 或 「 集合初始設定式包含第一次處理的執行個體建構函式，然後再處理成員或項目初始設定指定的物件初始設定式 ([物件初始設定式](expressions.md#object-initializers)) 或集合初始設定式 ([集合初始設定式](expressions.md#collection-initializers))。

如果任一項中選擇性的引數*argument_list*已在編譯時期型別`dynamic`則*object_creation_expression*動態繫結 ([動態繫結](expressions.md#dynamic-binding))而下列規則會套用在執行階段使用的這些引數的執行階段型別*argument_list*具有的編譯時間類型`dynamic`。 不過，在物件的建立就會進行有限的編譯時間檢查中所述[編譯時期檢查動態的多載解析](expressions.md#compile-time-checking-of-dynamic-overload-resolution)。

繫結時間處理*object_creation_expression*的表單`new T(A)`，其中`T`是*class_type*或*value_type*並`A`是選擇性*argument_list*，包含下列步驟：

*   如果`T`已*value_type*和`A`不存在：
    * *Object_creation_expression*是預設建構函式引動過程。 結果*object_creation_expression*是類型的值`T`，也就是預設值`T`中所定義[System.ValueType 類型](types.md#the-systemvaluetype-type)。
*   否則，如果`T`已*type_parameter*和`A`不存在：
    * 如果沒有實值類型條件約束或建構函式條件約束 ([類型參數條件約束](classes.md#type-parameter-constraints)) 已指定為`T`，則繫結階段會發生錯誤。
    * 結果*object_creation_expression*是值型別的執行階段已繫結的型別參數，也就是叫用該類型的預設建構函式的結果。 執行階段型別可能是參考型別或實值型別。
*   否則，如果`T`已*class_type*或是*struct_type*:
    * 如果`T`已`abstract` *class_type*，就會發生編譯時期錯誤。
    * 使用的多載解析規則來決定要叫用的執行個體建構函式[多載解析](expressions.md#overload-resolution)。 候選項目執行個體建構函式的集合，包含的所有可存取的執行個體建構函式中宣告`T`這是相對於適用於`A`([適用的函式成員](expressions.md#applicable-function-member))。 如果候選項目執行個體建構函式的資料集是空的或如果找不到單一最佳的執行個體建構函式，繫結階段會發生錯誤。
    * 結果*object_creation_expression*是類型的值`T`，也就是叫用上述步驟中決定的執行個體建構函式所產生的值。
*  否則，請*object_creation_expression*無效，並在繫結階段錯誤發生。

即使*object_creation_expression*動態繫結，在編譯時期型別仍`T`。

執行階段處理*object_creation_expression*的表單`new T(A)`，其中`T`會*class_type*或*struct_type*和`A`是選擇性*argument_list*，包含下列步驟：

*   如果`T`已*class_type*:
    * 類別的新執行個體`T`配置。 如果不是記憶體不足，無法配置新的執行個體，`System.OutOfMemoryException`就會擲回，而且會執行任何進一步的步驟。
    * 新執行個體的所有欄位都初始化為其預設值 ([預設值](variables.md#default-values))。
    * 執行個體建構函式會叫用根據函式成員引動過程的規則 ([編譯時期檢查動態的多載解析](expressions.md#compile-time-checking-of-dynamic-overload-resolution))。 新配置的執行個體的參考會自動傳遞給執行個體建構函式，並可以從存取的執行個體，做為該建構函式內`this`。
*   如果`T`已*struct_type*:
    * 型別的執行個體`T`由配置暫時的區域變數。 之後的執行個體建構函式*struct_type*才能明確地將值指派給每個欄位所建立的暫存變數未初始化是必要的執行個體。
    * 執行個體建構函式會叫用根據函式成員引動過程的規則 ([編譯時期檢查動態的多載解析](expressions.md#compile-time-checking-of-dynamic-overload-resolution))。 新配置的執行個體的參考會自動傳遞給執行個體建構函式，並可以從存取的執行個體，做為該建構函式內`this`。

#### <a name="object-initializers"></a>物件初始設定式

***物件初始設定式***指定零或多個欄位、 屬性或索引的項目之物件的值。

```antlr
object_initializer
    : '{' member_initializer_list? '}'
    | '{' member_initializer_list ',' '}'
    ;

member_initializer_list
    : member_initializer (',' member_initializer)*
    ;

member_initializer
    : initializer_target '=' initializer_value
    ;

initializer_target
    : identifier
    | '[' argument_list ']'
    ;

initializer_value
    : expression
    | object_or_collection_initializer
    ;
```

物件初始設定包含成員初始設定式，用括住的一連串`{`和`}`語彙基元，並以逗號分隔。 每個*member_initializer*指定初始設定的目標。 *識別碼*必須命名為可存取的欄位或屬性的物件初始化時，而*argument_list*括在方括號必須指定可存取索引子的引數上正在初始化的物件。 它是包含一個以上的成員初始設定式相同的欄位或屬性的物件初始設定式的錯誤。

每個*initializer_target*後面號和運算式、 物件初始設定式或集合初始設定式。 您不可能以指向新建立的物件，它會初始化物件初始設定式內的運算式。

指定運算式中指派的相同方式來處理在等號之後的成員初始設定式 ([簡單指派](expressions.md#simple-assignment)) 為目標。

指定的物件初始設定式，等號之後的成員初始設定式***巢狀的物件初始設定式***，也就是，內嵌物件的初始化。 而不是將新的值指派給欄位或屬性中，巢狀的物件初始設定式中的指派會被視為指派的欄位或屬性的成員。 無法套用巢狀的物件初始設定式，屬性具有實值類型，或搭配實值類型的唯讀欄位。

指定等號後面的 「 集合初始設定式的成員初始設定式是內嵌集合初始化。 而不是將新的集合指派給目標欄位、 屬性或索引子，指定初始設定式中的項目會新增至目標所參考的集合。 目標必須是符合指定需求的集合型別[集合初始設定式](expressions.md#collection-initializers)。

索引初始設定式的引數一律會評估一次。 因此，即使引數會最後會永遠不會取得使用 （例如因為空的巢狀初始設定式），因此會評估其副作用。

下列類別代表具有兩個座標的點：
```csharp
public class Point
{
    int x, y;

    public int X { get { return x; } set { x = value; } }
    public int Y { get { return y; } set { y = value; } }
}
```

執行個體`Point`可以建立和初始化，如下所示：
```csharp
Point a = new Point { X = 0, Y = 1 };
```
具有相同的效果
```csharp
Point __a = new Point();
__a.X = 0;
__a.Y = 1; 
Point a = __a;
```
其中`__a`是否則不可見，而且無法存取暫存變數。 下列類別表示建立兩個點的矩形：
```csharp
public class Rectangle
{
    Point p1, p2;

    public Point P1 { get { return p1; } set { p1 = value; } }
    public Point P2 { get { return p2; } set { p2 = value; } }
}
```

執行個體`Rectangle`可以建立和初始化，如下所示：
```csharp
Rectangle r = new Rectangle {
    P1 = new Point { X = 0, Y = 1 },
    P2 = new Point { X = 2, Y = 3 }
};
```
具有相同的效果
```csharp
Rectangle __r = new Rectangle();
Point __p1 = new Point();
__p1.X = 0;
__p1.Y = 1;
__r.P1 = __p1;
Point __p2 = new Point();
__p2.X = 2;
__p2.Y = 3;
__r.P2 = __p2; 
Rectangle r = __r;
```
何處`__r`，`__p1`和`__p2`是暫存變數。

如果`Rectangle`的建構函式會配置兩個內嵌`Point`執行個體
```csharp
public class Rectangle
{
    Point p1 = new Point();
    Point p2 = new Point();

    public Point P1 { get { return p1; } }
    public Point P2 { get { return p2; } }
}
```
下列建構可以用來初始化內嵌`Point`而不是指派新的執行個體的執行個體：
```csharp
Rectangle r = new Rectangle {
    P1 = { X = 0, Y = 1 },
    P2 = { X = 2, Y = 3 }
};
```
具有相同的效果
```csharp
Rectangle __r = new Rectangle();
__r.P1.X = 0;
__r.P1.Y = 1;
__r.P2.X = 2;
__r.P2.Y = 3;
Rectangle r = __r;
```

如果已指定 C，下列範例的適當定義：
```csharp
var c = new C {
    x = true,
    y = { a = "Hello" },
    z = { 1, 2, 3 },
    ["x"] = 5,
    [0,0] = { "a", "b" },
    [1,2] = {}
};
```
相當於這一系列的 指派：
```csharp
C __c = new C();
__c.x = true;
__c.y.a = "Hello";
__c.z.Add(1); 
__c.z.Add(2);
__c.z.Add(3);
string __i1 = "x";
__c[__i1] = 5;
int __i2 = 0, __i3 = 0;
__c[__i2,__i3].Add("a");
__c[__i2,__i3].Add("b");
int __i4 = 1, __i5 = 2;
var c = __c;
```
其中`__c`等，是不可見且無法存取原始程式碼的產生的變數。 請注意，引數`[0,0]`評估一次，且引數`[1,2]`即使它們永遠不會用一次評估。

#### <a name="collection-initializers"></a>集合初始設定式

集合初始設定式中指定之集合的元素。

```antlr
collection_initializer
    : '{' element_initializer_list '}'
    | '{' element_initializer_list ',' '}'
    ;

element_initializer_list
    : element_initializer (',' element_initializer)*
    ;

element_initializer
    : non_assignment_expression
    | '{' expression_list '}'
    ;

expression_list
    : expression (',' expression)*
    ;
```

集合初始設定式所組成的項目初始設定式，用括住的一連串`{`和`}`語彙基元，並以逗號分隔。 每個項目初始設定式指定要加入至要初始化的集合物件的項目，並且所括住的運算式清單所組成`{`和`}`語彙基元，並以逗號分隔。  單一運算式項目初始設定式可以撰寫沒有大括號，但不能再作為指派運算式，若要避免成員初始設定式模稜兩可。 *Non_assignment_expression*中所定義的生產環境[運算式](expressions.md#expression)。

包含集合初始設定式的物件建立運算式的範例如下：
```csharp
List<int> digits = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
```

要套用的集合初始設定式的集合物件必須實作的型別`System.Collections.IEnumerable`或發生編譯時期錯誤。 每個指定項目順序，集合初始設定式會叫用`Add`目標上的方法作為引數清單中，套用一般成員查閱物件的項目初始設定式的運算式清單，並多載解析每次叫用。 因此，集合物件必須有適用的執行個體或擴充方法名稱`Add`每個項目初始設定式。

下列類別代表連絡人名稱和電話號碼清單：
```csharp
public class Contact
{
    string name;
    List<string> phoneNumbers = new List<string>();

    public string Name { get { return name; } set { name = value; } }

    public List<string> PhoneNumbers { get { return phoneNumbers; } }
}
```

A`List<Contact>`可以建立和初始化，如下所示：
```csharp
var contacts = new List<Contact> {
    new Contact {
        Name = "Chris Smith",
        PhoneNumbers = { "206-555-0101", "425-882-8080" }
    },
    new Contact {
        Name = "Bob Harris",
        PhoneNumbers = { "650-555-0199" }
    }
};
```
具有相同的效果
```csharp
var __clist = new List<Contact>();
Contact __c1 = new Contact();
__c1.Name = "Chris Smith";
__c1.PhoneNumbers.Add("206-555-0101");
__c1.PhoneNumbers.Add("425-882-8080");
__clist.Add(__c1);
Contact __c2 = new Contact();
__c2.Name = "Bob Harris";
__c2.PhoneNumbers.Add("650-555-0199");
__clist.Add(__c2);
var contacts = __clist;
```
何處`__clist`，`__c1`和`__c2`是暫存變數。

#### <a name="array-creation-expressions"></a>陣列建立運算式

*Array_creation_expression*用來建立的新執行個體*array_type*。

```antlr
array_creation_expression
    : 'new' non_array_type '[' expression_list ']' rank_specifier* array_initializer?
    | 'new' array_type array_initializer
    | 'new' rank_specifier array_initializer
    ;
```

陣列建立運算式的第一種形式會配置陣列類型的執行個體所產生的刪除運算式清單中的每個個別的運算式。 例如，陣列建立運算式`new int[10,20]`產生的型別陣列執行個體`int[,]`，和陣列建立運算式`new int[10][,]`會產生型別的陣列`int[][,]`。 運算式清單中的每一個運算式必須是型別`int`， `uint`， `long`，或`ulong`，或隱含地轉換成一或多個這些型別。 每個運算式的值會決定新配置的陣列執行個體中之相對應維度的長度。 因為陣列維度的長度必須為非負的它是編譯時期錯誤*constant_expression*以負數值，運算式清單中。

除非在不安全的內容 ([Unsafe 內容](unsafe-code.md#unsafe-contexts))，未指定陣列的配置。

如果陣列建立運算式的第一個表單包含陣列初始設定式，在運算式清單中的每個運算式必須是常數，而且運算式清單所指定的順位和維度長度必須符合的陣列初始設定式。

在第二個或第三個表單的陣列建立運算式，指定的陣列型別或陣序規範的陣序規範必須符合的陣列初始設定式。 個別的維度長度會推斷從每個對應的巢狀層級的陣列初始設定式中的項目數。 因此，運算式
```csharp
new int[,] {{0, 1}, {2, 3}, {4, 5}}
```
若要完全對應
```csharp
new int[3, 2] {{0, 1}, {2, 3}, {4, 5}}
```

陣列建立運算式的第三種形式指***隱含型別陣列建立運算式***。 它是類似於第二種形式中，不同之處在於陣列的項目類型並未明確指定，但決定做為最常見的類型 ([找出一組運算式的最常見類型](expressions.md#finding-the-best-common-type-of-a-set-of-expressions)) 集合的陣列中的運算式初始設定式。 多維度的陣列，也就是那個*rank_specifier*包含至少一個逗號，這個集合包含所有*運算式*s 中找到的巢狀*array_initializer*s。

陣列初始設定式中所述進一步[陣列初始設定式](arrays.md#array-initializers)。

評估陣列建立運算式的結果會分類為值時，也就是新配置的陣列執行個體的參考。 執行階段處理的陣列建立運算式包含下列步驟：

*  維度長度運算式*expression_list*的評估順序，從左到右。 遵循每個運算式，隱含轉換的評估結果 ([隱含轉換](conversions.md#implicit-conversions)) 執行下列類型的其中一個： `int`， `uint`， `long`， `ulong`。 第一個類型的隱含轉換存在，這份清單中選擇。 如果評估的運算式或後續的隱含轉換導致例外狀況，然後會評估任何進一步的運算式，並執行任何進一步的步驟。
*  維度長度的計算的值會進行驗證，如下所示。 如果一或多個值都小於零，`System.OverflowException`就會擲回，而且會執行任何進一步的步驟。
*  配置指定的維度長度的陣列執行個體。 如果不是記憶體不足，無法配置新的執行個體，`System.OutOfMemoryException`就會擲回，而且會執行任何進一步的步驟。
*  將新的陣列執行個體的所有項目都初始化為其預設值 ([預設值](variables.md#default-values))。
*  如果陣列建立運算式中包含的陣列初始設定式，陣列初始設定式中的每個運算式評估，並指派給其對應的陣列項目。 評估和指派運算式以陣列初始設定式的順序執行 — 亦即，項目都初始化遞增索引順序，與第一次增加最右邊的維度。 如果評估指定的運算式或後續指派給對應的陣列項目會導致例外狀況，然後會初始化任何進一步的項目 （和其餘的項目將會因此有其預設值）。

陣列建立運算式允許具現化陣列的項目陣列型別，但必須以手動方式初始化的這類陣列項目。 例如，陳述式
```csharp
int[][] a = new int[100][];
```
使用 100 個元素的類型建立的一維陣列`int[]`。 每個元素的初始值是`null`。 它並不適用相同的陣列建立運算式，也和具現化子陣列，該陳述式
```csharp
int[][] a = new int[100][5];        // Error
```
會導致編譯時期錯誤。 必須改為手動，如下所示執行具現化的子陣列
```csharp
int[][] a = new int[100][];
for (int i = 0; i < 100; i++) a[i] = new int[5];
```

陣列的陣列時的 「 矩形 」 圖形，子陣列全都是長度的相同時，它是長度的使用多維陣列更有效率。 在上述範例中，具現化一維陣列的陣列建立 101 物件 — 一個是外部陣列和 100 的子陣列。 相反地，
```csharp
int[,] = new int[100, 5];
```
會建立只有單一物件，一個二維陣列，並完成在單一陳述式中的配置。

隱含類型的陣列建立運算式的範例如下：
```csharp
var a = new[] { 1, 10, 100, 1000 };                       // int[]

var b = new[] { 1, 1.5, 2, 2.5 };                         // double[]

var c = new[,] { { "hello", null }, { "world", "!" } };   // string[,]

var d = new[] { 1, "one", 2, "two" };                     // Error
```

最後一個運算式會造成編譯時期錯誤，因為未`int`也不`string`是隱含地轉換成另一個，而因此那里不是最常見輸入。 明確類型的陣列建立運算式必須使用在此情況下，例如指定的型別是`object[]`。 或者，其中一個項目可以轉換成一般的基底類型，它就會成為推斷項目類型。

隱含類型的陣列建立運算式可以結合匿名物件初始設定式 ([匿名物件建立運算式](expressions.md#anonymous-object-creation-expressions)) 來建立匿名型別資料結構。 例如: 
```csharp
var contacts = new[] {
    new {
        Name = "Chris Smith",
        PhoneNumbers = new[] { "206-555-0101", "425-882-8080" }
    },
    new {
        Name = "Bob Harris",
        PhoneNumbers = new[] { "650-555-0199" }
    }
};
```

#### <a name="delegate-creation-expressions"></a>委派建立運算式

A *delegate_creation_expression*用來建立的新執行個體*delegate_type*。

```antlr
delegate_creation_expression
    : 'new' delegate_type '(' expression ')'
    ;
```

委派建立運算式的引數必須是方法群組、 匿名函式或編譯時間類型的值`dynamic`或是*delegate_type*。 如果引數的方法群組，它會識別的方法和執行個體方法，為其建立委派的物件。 如果引數的匿名函式直接定義委派目標方法主體與參數。 如果引數是值，它會識別用來建立複本的委派執行個體。

如果*運算式*已在編譯時期型別`dynamic`，則*delegate_creation_expression*動態繫結 ([動態繫結](expressions.md#dynamic-binding))，以及下列規則在執行階段使用的執行階段型別套用*運算式*。 否則就會在編譯時期套用規則。

繫結時間處理*delegate_creation_expression*的表單`new D(E)`，其中`D`是*delegate_type*並`E`是*運算式*，包含下列步驟：

*  如果`E`是方法群組，為方法群組轉換相同的方式處理委派建立運算式 ([方法群組轉換](conversions.md#method-group-conversions)) 從`E`到`D`。
*  如果`E`是匿名的函式的匿名函式轉換為相同的方式處理委派建立運算式 ([匿名函式轉換](conversions.md#anonymous-function-conversions)) 從`E`到`D`。
*  如果`E`是一個值，`E`必須是相容 ([委派宣告](delegates.md#delegate-declarations)) 與`D`，且結果為新建立之型別的委派的參考`D`參考相同的引動過程列為`E`。 如果`E`與不相容`D`，就會發生編譯時期錯誤。

執行階段處理*delegate_creation_expression*的表單`new D(E)`，其中`D`是*delegate_type*並`E`是*運算式*，包含下列步驟：

*   如果`E`是方法群組，則委派建立運算式會評估為方法群組轉換 ([方法群組轉換](conversions.md#method-group-conversions)) 從`E`到`D`。
*   如果`E`是匿名的函式委派建立的評估方式的匿名函式轉換`E`要`D`([匿名函式轉換](conversions.md#anonymous-function-conversions))。
*   如果`E`的值*delegate_type*:
    * `E` 會評估。 如果此評估會產生例外狀況，則會不執行任何進一步的步驟。
    * 如果值`E`已`null`、`System.NullReferenceException`就會擲回，而且會執行任何進一步的步驟。
    * 委派類型的新執行個體`D`配置。 如果不是記憶體不足，無法配置新的執行個體，`System.OutOfMemoryException`就會擲回，而且會執行任何進一步的步驟。
    * 使用相同的引動過程清單，為給定的委派執行個體初始化新的委派執行個體`E`。

委派具現化，並接著會維持不變的委派的整個存留期間時，會決定委派的引動過程清單。 換句話說，不可以變更委派的目標可呼叫實體，一旦建立之後。 當合併兩個委派，或移除其中一個是 ([委派宣告](delegates.md#delegate-declarations))，產生新的委派，任何現有的委派，並變更其內容。

您不可以建立委派，指屬性、 索引子、 使用者定義的運算子、 執行個體建構函式、 解構函式或靜態建構函式。

如上面所述，當建立委派從方法群組中，型式參數清單和委派的傳回型別，判斷其中一個多載的方法，來選取。 在範例
```csharp
delegate double DoubleFunc(double x);

class A
{
    DoubleFunc f = new DoubleFunc(Square);

    static float Square(float x) {
        return x * x;
    }

    static double Square(double x) {
        return x * x;
    }
}
```
`A.f`欄位會初始化的委派，其中第二個是指`Square`方法的型式參數清單和傳回型別，該方法完全比對因為`DoubleFunc`。 有第二個`Square`尚未存在的方法，會發生編譯時期錯誤。

#### <a name="anonymous-object-creation-expressions"></a>匿名物件建立運算式

*Anonymous_object_creation_expression*用來建立匿名型別的物件。

```antlr
anonymous_object_creation_expression
    : 'new' anonymous_object_initializer
    ;

anonymous_object_initializer
    : '{' member_declarator_list? '}'
    | '{' member_declarator_list ',' '}'
    ;

member_declarator_list
    : member_declarator (',' member_declarator)*
    ;

member_declarator
    : simple_name
    | member_access
    | base_access
    | null_conditional_member_access
    | identifier '=' expression
    ;
```

匿名物件初始設定式宣告匿名型別，並傳回該類型的執行個體。 匿名型別是無名稱的類別型別直接繼承自`object`。 匿名類型的成員是推斷的匿名物件初始設定式用來建立型別的執行個體的唯讀屬性的序列。 具體來說，匿名物件初始設定式的格式
```csharp
new { p1 = e1, p2 = e2, ..., pn = en }
```
宣告匿名類型的表單
```csharp
class __Anonymous1
{
    private readonly T1 f1;
    private readonly T2 f2;
    ...
    private readonly Tn fn;

    public __Anonymous1(T1 a1, T2 a2, ..., Tn an) {
        f1 = a1;
        f2 = a2;
        ...
        fn = an;
    }

    public T1 p1 { get { return f1; } }
    public T2 p2 { get { return f2; } }
    ...
    public Tn pn { get { return fn; } }

    public override bool Equals(object __o) { ... }
    public override int GetHashCode() { ... }
}
```
其中每個`Tx`是對應的運算式的型別`ex`。 所用的運算式*member_declarator*必須具有型別。 因此，它是在運算式的編譯時期錯誤*member_declarator*為 null 或匿名函式。 它也是要有不安全類型的運算式的編譯時期錯誤。

匿名型別和參數的名稱及其`Equals`方法透過編譯器自動產生，而且無法參考的程式文字中。

在相同的程式中，兩個匿名物件初始設定式的相同順序指定屬性的編譯時間類型與相同名稱的序列將會產生相同的匿名型別的執行個體。

在範例
```csharp
var p1 = new { Name = "Lawnmower", Price = 495.00 };
var p2 = new { Name = "Shovel", Price = 26.95 };
p1 = p2;
```
指派的最後一行受到允許，因為`p1`和`p2`都屬於相同匿名型別。

`Equals`和`GetHashcode`匿名型別上的方法覆寫繼承自方法`object`，，而且會定義的形式`Equals`和`GetHashcode`屬性，以便相同匿名型別的兩個執行個體是否相等如果而且，只有在其所有屬性都都相等。

成員宣告子可縮寫成簡單名稱 ([型別推斷](expressions.md#type-inference))，成員存取 ([編譯時期檢查動態的多載解析](expressions.md#compile-time-checking-of-dynamic-overload-resolution))，基底的存取 ([基底存取](expressions.md#base-access))或 null 條件成員存取 ([Null 條件運算式為投影初始設定式](expressions.md#null-conditional-expressions-as-projection-initializers))。 這就叫做***投影初始設定式***和是宣告和指派的屬性具有相同名稱的速記。 具體而言，一種格式的成員宣告子
```csharp
identifier
expr.identifier
```
分別是相當於下列：
```csharp
identifier = identifier
identifier = expr.identifier
```

因此，在規劃初始設定式*識別碼*選取同時值和欄位或屬性值會指派。 可想而知，投影初始設定式的專案不只是一個值，但也是值的名稱。

### <a name="the-typeof-operator"></a>Typeof 運算子

`typeof`運算子用來取得`System.Type`型別的物件。

```antlr
typeof_expression
    : 'typeof' '(' type ')'
    | 'typeof' '(' unbound_type_name ')'
    | 'typeof' '(' 'void' ')'
    ;

unbound_type_name
    : identifier generic_dimension_specifier?
    | identifier '::' identifier generic_dimension_specifier?
    | unbound_type_name '.' identifier generic_dimension_specifier?
    ;

generic_dimension_specifier
    : '<' comma* '>'
    ;

comma
    : ','
    ;
```

第一種形式*typeof_expression*組成`typeof`關鍵字後面接著括號括住*類型*。 這種形式的運算式的結果是`System.Type`指定型別的物件。 只有一個`System.Type`任何指定類型的物件。 這表示型別的 `T`，`typeof(T) == typeof(T)`一定是 true。 *型別*不能是`dynamic`。

第二個形式*typeof_expression*組成`typeof`關鍵字後面接著括號括住*unbound_type_name*。 *Unbound_type_name*非常類似於*type_name* ([命名空間和型別名稱](basic-concepts.md#namespace-and-type-names)) 不同之處在於*unbound_type_name*包含*generic_dimension_specifier*s 所在*type_name*包含*type_argument_list*s。 當的運算元*typeof_expression*是一連串的語彙基元滿足兩個文法*unbound_type_name*並*type_name*，也就是當它包含既不*generic_dimension_specifier*也不是*type_argument_list*，語彙基元順序會被視為*type_name*。 意義*unbound_type_name*判斷方式如下：

*  轉換到的語彙基元順序*type_name*取代每個*generic_dimension_specifier*具有*type_argument_list*有相同數目的逗號，關鍵字`object`為每個*type_argument*。
*  評估所產生的*type_name*，但略過所有的類型參數條件約束。
*  *Unbound_type_name*會解析為未繫結的泛型型別，以產生建構的型別相關聯 ([繫結和解除繫結類型](types.md#bound-and-unbound-types))。

結果*typeof_expression*是`System.Type`物件所產生的未繫結的泛型型別。

第三種*typeof_expression*組成`typeof`關鍵字後面接著括號括住`void`關鍵字。 這種形式的運算式的結果是`System.Type`物件，表示為型別不存在。 所傳回的型別物件`typeof(void)`會傳回任何類型的型別物件有所區別。 這個特殊的型別物件適合類別庫可讓方法上的反映在語言中，這些方法要想辦法代表包含 void 方法的執行個體的任何方法的傳回型別中`System.Type`。

`typeof`運算子可以用在類型參數。 結果是`System.Type`已繫結至型別參數的執行階段類型的物件。 `typeof`運算子也可以用在建構的型別或繫結的泛型型別 ([繫結和解除繫結類型](types.md#bound-and-unbound-types))。 `System.Type`物件中繫結的泛型型別不是相同`System.Type`執行個體類型的物件。 執行個體類型一定是在執行階段的封閉式建構的類型因此其`System.Type`物件取決於執行階段型別引數，在使用中，而未繫結的泛型型別沒有任何型別引數。

此範例
```csharp
using System;

class X<T>
{
    public static void PrintTypes() {
        Type[] t = {
            typeof(int),
            typeof(System.Int32),
            typeof(string),
            typeof(double[]),
            typeof(void),
            typeof(T),
            typeof(X<T>),
            typeof(X<X<T>>),
            typeof(X<>)
        };
        for (int i = 0; i < t.Length; i++) {
            Console.WriteLine(t[i]);
        }
    }
}

class Test
{
    static void Main() {
        X<int>.PrintTypes();
    }
}
```
會產生下列輸出：
```
System.Int32
System.Int32
System.String
System.Double[]
System.Void
System.Int32
X`1[System.Int32]
X`1[X`1[System.Int32]]
X`1[T]
```

請注意，`int`和`System.Int32`都是相同的型別。

也請注意，結果`typeof(X<>)`不相依於型別引數，但結果`typeof(X<T>)`沒有。

### <a name="the-checked-and-unchecked-operators"></a>Checked 與 unchecked 運算子

`checked`並`unchecked`運算子可用來控制***溢位檢查內容***整數型別算術運算和轉換。

```antlr
checked_expression
    : 'checked' '(' expression ')'
    ;

unchecked_expression
    : 'unchecked' '(' expression ')'
    ;
```

`checked`運算子會評估在 checked 內容中，包含的運算式和`unchecked`運算子會評估在 unchecked 內容中包含的運算式。 A *checked_expression*或是*unchecked_expression*就相當於*parenthesized_expression* ([括號括住運算式](expressions.md#parenthesized-expressions))，但包含的運算式會評估指定的溢位檢查內容中。

也可以透過控制溢位檢查內容`checked`並`unchecked`陳述式 ([checked 與 unchecked 陳述式](statements.md#the-checked-and-unchecked-statements))。

下列作業會受到溢位檢查所建立的內容`checked`和`unchecked`運算子和陳述式：

*  預先定義`++`並`--`一元運算子 ([後置遞增和遞減運算子](expressions.md#postfix-increment-and-decrement-operators)並[前置遞增和遞減運算子](expressions.md#prefix-increment-and-decrement-operators))，如果運算元為整數的型別。
*  預先定義`-`一元運算子 ([一元減號運算子](expressions.md#unary-minus-operator))，如果運算元為整數類資料類型。
*  預先定義`+`， `-`， `*`，以及`/`二元運算子 ([算術運算子](expressions.md#arithmetic-operators))，當這兩個運算元都是整數類資料類型。
*  明確數值轉換 ([明確數值轉換](conversions.md#explicit-numeric-conversions)) 從一種整數類資料類型為另一個整數型別，或從`float`或`double`為整數類型。

當上述作業的其中一個產生的結果太大，無法代表的目的型別，此作業執行的控制項的內容中產生的行為：

*  在 `checked`情況下，如果作業是常數運算式 ([常數運算式](expressions.md#constant-expressions))，就會發生編譯時期錯誤。 否則，當作業在執行階段`System.OverflowException`就會擲回。
*  在 `unchecked`內容中，結果會被截斷並捨棄任何高序位位元不適合目的類型。

非常數運算式 （在執行階段評估的運算式），不需加上任何`checked`或是`unchecked`運算子或陳述式，預設值溢位檢查內容是`unchecked`除非外部因素 （例如編譯器參數和執行環境組態） 呼叫`checked`評估。

對於常數運算式 （可以在編譯時期完整評估的運算式），預設值溢位檢查內容一律是`checked`。 除非常數運算式明確放入`unchecked`內容中，運算式一律產生編譯時期評估期間發生溢位會造成編譯時期錯誤。

匿名函式的主體不會受到`checked`或`unchecked`匿名函式會發生的內容。

在範例
```csharp
class Test
{
    static readonly int x = 1000000;
    static readonly int y = 1000000;

    static int F() {
        return checked(x * y);      // Throws OverflowException
    }

    static int G() {
        return unchecked(x * y);    // Returns -727379968
    }

    static int H() {
        return x * y;               // Depends on default
    }
}
```
因為沒有一個運算式可在編譯時期評估，則會不報告任何編譯時期錯誤。 在執行階段`F`方法會擲回`System.OverflowException`，和`G`方法會傳回-727379968 （較低 32 位元範圍外的結果）。 行為`H`方法取決於預設的溢位檢查內容進行編譯，但它是與相同`F`或相同`G`。

在範例
```csharp
class Test
{
    const int x = 1000000;
    const int y = 1000000;

    static int F() {
        return checked(x * y);      // Compile error, overflow
    }

    static int G() {
        return unchecked(x * y);    // Returns -727379968
    }

    static int H() {
        return x * y;               // Compile error, overflow
    }
}
```
評估中的常數運算式時，會發生溢位`F`並`H`會導致編譯時期錯誤，因為運算式會評估`checked`內容。 評估中的常數運算式時，也會發生溢位`G`，但因為評估會發生在`unchecked`內容，則不會報告溢位。

`checked`並`unchecked`運算子只會影響溢位檢查文字包含在這些作業的內容 」`(`"和"`)`"語彙基元。 運算子會有不會影響結果包含的運算式的評估會叫用的函式成員。 在範例
```csharp
class Test
{
    static int Multiply(int x, int y) {
        return x * y;
    }

    static int F() {
        return checked(Multiply(1000000, 1000000));
    }
}
```
善用`checked`中`F`不會影響評估`x * y`中`Multiply`，因此`x * y`預設溢位檢查內容中評估。

`unchecked`十六進位標記法撰寫的帶正負號的整數類資料類型的常數時，運算子會很方便。 例如: 
```csharp
class Test
{
    public const int AllBits = unchecked((int)0xFFFFFFFF);

    public const int HighBit = unchecked((int)0x80000000);
}
```

兩個以上十六進位常數的類型是`uint`。 因為常數之外`int`範圍，不含`unchecked`運算子、 型別轉換成`int`會產生編譯時期錯誤。

`checked`和`unchecked`運算子和陳述式可讓程式設計人員控制某些方面的一些數值計算。 不過，有些數值運算子的行為會取決於其運算元的資料類型。 比方說，乘以兩個小數位數永遠會導致溢位時例外狀況甚至內明確`unchecked`建構。 同樣地，乘以兩個浮點數從未結果溢位時例外狀況甚至內明確`checked`建構。 此外，其他運算子永遠不會受到所檢查的模式，不管是預設或明確。

### <a name="default-value-expressions"></a>預設值運算式

預設值運算式用來取得預設值 ([預設值](variables.md#default-values)) 的型別。 通常預設值運算式用於型別參數，因為它可能不知道如果型別參數是實值類型或參考型別。 (沒有任何轉換存在從`null`常值的型別參數的型別參數已知為參考型別，除非。)

```antlr
default_value_expression
    : 'default' '(' type ')'
    ;
```

如果*型別*中*default_value_expression*評估結果是在執行階段參考類型，`null`轉換成該類型。 如果*型別*中*default_value_expression*評估結果是在執行階段實值型別的*value_type*的預設值 ([預設建構函式](types.md#default-constructors))。

A *default_value_expression*是常數運算式 ([常數運算式](expressions.md#constant-expressions)) 如果類型是參考型別或型別參數就是參考型別 ([型別參數條件約束](classes.md#type-parameter-constraints))。 颾魤 ㄛ *default_value_expression*是常數運算式，如果類型是其中一個下列的實值型別： `sbyte`， `byte`， `short`， `ushort`， `int`， `uint`，`long`， `ulong`， `char`， `float`， `double`， `decimal`， `bool`，或任何列舉類型。


### <a name="nameof-expressions"></a>Nameof 運算式

A *nameof_expression*用來取得做為常數字串程式實體的名稱。

```antlr
nameof_expression
    : 'nameof' '(' named_entity ')'
    ;

named_entity
    : simple_name
    | named_entity_target '.' identifier type_argument_list?
    ;

named_entity_target
    : 'this'
    | 'base'
    | named_entity 
    | predefined_type 
    | qualified_alias_member
    ;
```

文法而言， *named_entity*運算元一律是運算式。 因為`nameof`不能是保留的關鍵字，nameof 運算式永遠是在語法上模稜兩可的簡單名稱的引動過程`nameof`。 基於相容性考量，如果名稱查閱 ([簡單名稱](expressions.md#simple-names)) 的名稱`nameof`成功，運算式會被視為*invocation_expression* -不論是否在引動過程合法的。 否則，它會*nameof_expression*。

意義*named_entity*的*nameof_expression*是它的意義，做為運算式; 也就是其中一個作為*simple_name*、 *base_access*或是*member_access*。 不過，其中在查閱中所述[簡單名稱](expressions.md#simple-names)並[成員存取](expressions.md#member-access)導致錯誤，因為在靜態內容中，找不到執行個體成員*nameof_expression*會產生任何這類錯誤。

它是編譯時期錯誤*named_entity*指定為方法群組*type_argument_list*。 它是編譯時期錯誤，如*named_entity_target*具有類型`dynamic`。

A *nameof_expression*是常數運算式的型別`string`，而且在執行階段沒有任何作用。 具體而言，其*named_entity*則不會評估，而且會忽略明確設定分析的目的 ([簡單運算式的一般規則](variables.md#general-rules-for-simple-expressions))。 其值是最後一個識別項*named_entity*之前選擇性最終*type_argument_list*已轉換的方式如下：

* 前置詞"`@`」，如果使用，會移除。
* 每個*unicode_escape_sequence*轉換成其對應的 Unicode 字元。
* 任何*formatting_characters*會移除。

這些都是相同的轉換中套用[識別碼](lexical-structure.md#identifiers)測試識別項之間的等號比較時。

TODO： 範例

### <a name="anonymous-method-expressions"></a>匿名方法運算式

*Anonymous_method_expression*是下列其中一種定義匿名函式。 進一步說明[匿名函式運算式](expressions.md#anonymous-function-expressions)。

## <a name="unary-operators"></a>一元運算子

`?`， `+`， `-`， `!`， `~`， `++`， `--`、 轉型和`await`運算子都稱為一元 （unary） 運算子。

```antlr
unary_expression
    : primary_expression
    | null_conditional_expression
    | '+' unary_expression
    | '-' unary_expression
    | '!' unary_expression
    | '~' unary_expression
    | pre_increment_expression
    | pre_decrement_expression
    | cast_expression
    | await_expression
    | unary_expression_unsafe
    ;
```

如果運算元*unary_expression*已在編譯時期型別`dynamic`，動態地繫結 ([動態繫結](expressions.md#dynamic-binding))。 在此情況下產生編譯時期類型*unary_expression*是`dynamic`，並如下所述的解析度會發生在執行階段使用的執行階段類型的運算元。

### <a name="null-conditional-operator"></a>Null 條件運算子

Null 條件運算子只適用於一份作業其運算元，運算元非 null。 否則套用運算子的結果就是`null`。

```antlr
null_conditional_expression
    : primary_expression null_conditional_operations
    ;

null_conditional_operations
    : null_conditional_operations? '?' '.' identifier type_argument_list?
    | null_conditional_operations? '?' '[' argument_list ']'
    | null_conditional_operations '.' identifier type_argument_list?
    | null_conditional_operations '[' argument_list ']'
    | null_conditional_operations '(' argument_list? ')'
    ;
```

成員存取和項目存取作業 （其本身可能是 null 條件），以及引動過程，可以包含的作業清單。

例如，運算式`a.b?[0]?.c()`是*null_conditional_expression*具有*primary_expression* `a.b`並*null_conditional_operations* `?[0]` （null 條件項目存取）， `?.c` （null 條件成員存取） 和`()`（引動過程）。

針對*null_conditional_expression* `E`使用*primary_expression* `P`讓`E0`是由賦予移除前置運算式`?`從每個*null_conditional_operations*的`E`，有一個。 就概念而言，`E0`之運算式。 如果沒有任何 null 檢查以表示將會評估`?`發現 s `null`。

此外，可讓`E1`是由賦予移除前置運算式`?`只從的第一個*null_conditional_operations*在`E`。 這可能會導致*主要運算式*(如果有的話就`?`) 或另一個*null_conditional_expression*。

比方說，如果`E`是運算式`a.b?[0]?.c()`，然後`E0`運算式`a.b[0].c()`並`E1`運算式`a.b[0]?.c()`。

如果`E0`歸類為任何內容，然後`E`歸類為執行任何動作。 否則將 E 分類為值。

`E0` 並`E1`用來判斷的意義`E`:

*  如果`E`當做*statement_expression*的意義`E`等同於陳述式

   ```csharp
   if ((object)P != null) E1;
   ```

   不同之處在於 P 只評估一次。

*  否則，如果`E0`歸類為執行任何動作就會發生編譯時期錯誤。

*  否則，讓`T0`的型別`E0`。

   *  如果`T0`是型別參數就不是是參考型別或不可為 null 的實值型別，就會發生編譯時期錯誤。

   *  如果`T0`不可為 null 的實值型別，則該類`E`是`T0?`，和意義`E`相同

      ```csharp
      ((object)P == null) ? (T0?)null : E1
      ```

      不同之處在於`P`只評估一次。

   *  否則 E 的型別 T0，而 E 的意義相同

      ```csharp
      ((object)P == null) ? null : E1
      ```

      不同之處在於`P`只評估一次。

如果`E1`本身*null_conditional_expression*，然後這些規則會套用同樣地，巢狀的測試`null`直到沒有其他進一步`?`的並一路向下精簡之後所得的運算式主要運算式`E0`。

例如，如果運算式`a.b?[0]?.c()`當做陳述式運算式，如陳述式所示：
```csharp
a.b?[0]?.c();
```
其意義等同於：
```csharp
if (a.b != null) a.b[0]?.c();
```
這一次是相當於項目：
```csharp
if (a.b != null) if (a.b[0] != null) a.b[0].c();
```
不同之處在於`a.b`和`a.b[0]`只評估一次。

如果發生在其中使用其值，如下所示的內容：
```csharp
var x = a.b?[0]?.c();
```
而且假設的最後一個引動過程類型不是不可為 null 的實值型別，其意義相當於：
```csharp
var x = (a.b == null) ? null : (a.b[0] == null) ? null : a.b[0].c();
```
不同之處在於`a.b`和`a.b[0]`只評估一次。

#### <a name="null-conditional-expressions-as-projection-initializers"></a>Null 條件運算式為投影初始設定式

Null 條件運算式只允許作為*member_declarator*中*anonymous_object_creation_expression* ([匿名物件建立運算式](expressions.md#anonymous-object-creation-expressions)) 如果它的結尾 （選擇性地 null-條件） 成員存取。 文法，這項需求可以表示為：

```antlr
null_conditional_member_access
    : primary_expression null_conditional_operations? '?' '.' identifier type_argument_list?
    | primary_expression null_conditional_operations '.' identifier type_argument_list?
    ;
```

這是特殊形式的文法*null_conditional_expression*上方。 針對生產*member_declarator*中[匿名物件建立運算式](expressions.md#anonymous-object-creation-expressions)然後僅包括*null_conditional_member_access*。

#### <a name="null-conditional-expressions-as-statement-expressions"></a>Null 條件運算式，做為陳述式運算式

Null 條件運算式只允許作為*statement_expression* ([運算式陳述式](statements.md#expression-statements)) 如果到最後的引動過程。 文法，這項需求可以表示為：

```antlr
null_conditional_invocation_expression
    : primary_expression null_conditional_operations '(' argument_list? ')'
    ;
```

這是特殊形式的文法*null_conditional_expression*上方。 針對生產*statement_expression*中[運算式陳述式](statements.md#expression-statements)然後僅包括*null_conditional_invocation_expression*。


### <a name="unary-plus-operator"></a>一元加號運算子

作業的表單`+x`，一元運算子多載解析 ([一元運算子多載解析](expressions.md#unary-operator-overload-resolution)) 套用至選取的特定運算子實作。 一個運算元轉換成所選的運算子的參數類型和結果的類型是運算子的傳回型別。 預先定義的一元加法運算子如下：

```csharp
int operator +(int x);
uint operator +(uint x);
long operator +(long x);
ulong operator +(ulong x);
float operator +(float x);
double operator +(double x);
decimal operator +(decimal x);
```

針對每個這些運算子，結果會是運算元的值。

### <a name="unary-minus-operator"></a>一元減號運算子

作業的表單`-x`，一元運算子多載解析 ([一元運算子多載解析](expressions.md#unary-operator-overload-resolution)) 套用至選取的特定運算子實作。 一個運算元轉換成所選的運算子的參數類型和結果的類型是運算子的傳回型別。 預先定義的否定運算子包括︰

*  整數否定：

   ```csharp
   int operator -(int x);
   long operator -(long x);
   ```

   結果計算減去`x`從零。 如果值的`x`是最小的運算元類型可代表值 (-2 ^31 個`int`或-2 ^63 `long`)，然後數學否定`x`不是可代表運算元的型別中。 如果這發生在`checked`內容中，`System.OverflowException`就會擲回; 內發生`unchecked`內容中，結果是運算元的值，且不會報告溢位。

   如果負運算子的運算元為類型`uint`，它會轉換成類型`long`，且結果類型是`long`。 例外狀況是允許的規則`int`值介於-2147483648 (-2 ^31) 撰寫為十進位整數常值 ([整數常值](lexical-structure.md#integer-literals))。

   如果負運算子的運算元為類型`ulong`，就會發生編譯時期錯誤。 例外狀況是允許的規則`long`值-9223372036854775808 (-2 ^63) 撰寫為十進位整數常值 ([整數常值](lexical-structure.md#integer-literals))。

*  浮點數的否定：

   ```csharp
   float operator -(float x);
   double operator -(double x);
   ```

   結果是值`x`反轉正負號。 如果`x`為 NaN，結果也是 NaN。

*  十進位否定：

   ```csharp
   decimal operator -(decimal x);
   ```

   結果計算減去`x`從零。 十進位否定是相當於使用一元減號運算子型別的`System.Decimal`。

### <a name="logical-negation-operator"></a>邏輯負運算子

作業的表單`!x`，一元運算子多載解析 ([一元運算子多載解析](expressions.md#unary-operator-overload-resolution)) 套用至選取的特定運算子實作。 一個運算元轉換成所選的運算子的參數類型和結果的類型是運算子的傳回型別。 只能有一個預先定義的邏輯負運算子存在：
```csharp
bool operator !(bool x);
```

這個運算子會計算運算元的邏輯否定：如果運算元`true`，結果是`false`。 如果運算元`false`，結果是`true`。

### <a name="bitwise-complement-operator"></a>位元補充運算子

作業的表單`~x`，一元運算子多載解析 ([一元運算子多載解析](expressions.md#unary-operator-overload-resolution)) 套用至選取的特定運算子實作。 一個運算元轉換成所選的運算子的參數類型和結果的類型是運算子的傳回型別。 是預先定義的位元補數運算子：
```csharp
int operator ~(int x);
uint operator ~(uint x);
long operator ~(long x);
ulong operator ~(ulong x);
```

針對每個這些運算子，作業的結果是位元補數`x`。

每個列舉類型`E`都會隱含地提供下列的位元補數運算子：

```csharp
E operator ~(E x);
```

評估的結果`~x`，其中`x`是列舉型別的運算式`E`基礎型別`U`，正是評估相同`(E)(~(U)x)`不同之處在於，轉換為`E`是一律會以執行在 if`unchecked`內容 ([checked 與 unchecked 運算子](expressions.md#the-checked-and-unchecked-operators))。

### <a name="prefix-increment-and-decrement-operators"></a>前置遞增和遞減運算子

```antlr
pre_increment_expression
    : '++' unary_expression
    ;

pre_decrement_expression
    : '--' unary_expression
    ;
```

運算元的前置遞增或遞減作業必須是運算式分類為變數、 屬性存取或索引子存取。 作業的結果是相同的型別運算元的值。

如果前置詞的運算元遞增或遞減運算是屬性或索引子存取、 屬性或索引子必須兩者`get`和`set`存取子。 如果這不是這樣，繫結階段會發生錯誤。

一元運算子多載解析 ([一元運算子多載解析](expressions.md#unary-operator-overload-resolution)) 套用至選取的特定運算子實作。 預先定義的`++`並`--`運算子有下列類型： `sbyte`， `byte`， `short`， `ushort`， `int`， `uint`， `long`， `ulong`， `char``float`， `double`， `decimal`，以及任何列舉類型。 預先定義`++`運算子會傳回運算元，而預先定義上加 1，所產生的值`--`運算子會傳回所產生的減去 1 的運算元的值。 在 `checked`情況下，如果這個加法或減法運算的結果超出結果型別的範圍和結果型別是整數類資料類型或列舉型別，`System.OverflowException`就會擲回。

執行階段的處理前置遞增或遞減運算的表單`++x`或`--x`包含下列步驟：

*   如果`x`分類為變數：
    * `x` 在評估後產生的變數。
    * 選取的運算子會叫用的值與`x`作為其引數。
    * 運算子的傳回值會儲存在評估所指定的位置`x`。
    * 運算子的傳回值就是作業的結果。
*   如果`x`歸類為屬性或索引子的存取：
    * 執行個體運算式 (如果`x`不是`static`) 和引數清單 (如果`x`是索引子存取) 相關聯`x`會進行評估，而且結果會用於後續`get`和`set`存取子引動過程。
    * `get`存取子`x`叫用。
    * 所傳回的值叫用所選的運算子`get`存取子實作為其引數。
    * `set`存取子`x`會使用該運算子作為所傳回的值叫用其`value`引數。
    * 運算子的傳回值就是作業的結果。

`++`並`--`運算子也支援後置標記法 ([後置遞增和遞減運算子](expressions.md#postfix-increment-and-decrement-operators))。 一般而言，結果`x++`或`x--`的值`x`作業之前，而結果`++x`或`--x`的值`x`作業之後。 在任一情況下，`x`本身具有相同的值在作業之後。

`operator++`或`operator--`實作可以使用來叫用前置詞或後置標記法。 您不可以有兩種標記法的個別運算子實作。

### <a name="cast-expressions"></a>Cast 運算式

A *cast_expression*用來明確地將運算式轉換成指定的型別。

```antlr
cast_expression
    : '(' type ')' unary_expression
    ;
```

A *cast_expression*的表單`(T)E`，其中`T`是*型別*並`E`是*unary_expression*，執行明確轉換 ([明確轉換](conversions.md#explicit-conversions)) 之值的`E`輸入`T`。 如果沒有任何明確的轉換存在從`E`至`T`，則繫結階段會發生錯誤。 否則，結果就是明確的轉換所產生的值。 結果一律會分類為值時，即使`E`代表變數。

文法*cast_expression*通往特定語法模稜兩可。 例如，運算式`(x)-y`可能是解譯為*cast_expression* (轉型`-y`鍵入`x`) 或*additive_expression*結合*parenthesized_expression* (它會計算值`x - y)`。

若要解決*cast_expression*模稜兩可，下列規則存在：一或多個序列*語彙基元*s ([泛空白字元](lexical-structure.md#white-space)) 括在括號會被視為開頭*cast_expression*至少下列其中一項條件成立時，才：

*  語彙基元順序是正確文法*型別*，但並不適合*運算式*。
*  語彙基元順序是正確文法*型別*，並緊接在右括號的語彙基元是語彙基元"`~`"，語彙基元"`!`"，語彙基元"`(`"、 *識別項*([Unicode 字元的逸出序列](lexical-structure.md#unicode-character-escape-sequences))，則*常值*([常值](lexical-structure.md#literals))，或有任何*關鍵字*([關鍵字](lexical-structure.md#keywords)) 除了`as`和`is`。

上面提到的 「 正確文法 」 表示只語彙基元順序必須符合特定的文法解析。 特別是不會考慮任何組成識別項的實際意義。 例如，如果`x`並`y`是識別項，然後`x.y`是正確的文法，對於類型，即使`x.y`實際上並不代表型別。

從去除混淆規則，如果`x`並`y`是識別項， `(x)y`， `(x)(y)`，和`(x)(-y)`會*cast_expression*s，但`(x)-y`不是，即使`x`識別的型別。 不過，如果`x`是識別預先定義的類型的關鍵字 (例如`int`)，則所有的四種形式*cast_expression*s （因為這類關鍵字本身不可能會是運算式）。

### <a name="await-expressions"></a>Await 運算式

Await 運算子用來暫停封入的非同步函式的評估，直到在運算元所表示的非同步作業已完成。

```antlr
await_expression
    : 'await' unary_expression
    ;
```

*Await_expression*只能在非同步函式主體中 ([迭代器](classes.md#iterators))。 中最內層非同步函式， *await_expression*可能不會發生在下列位置：

*  在巢狀 （非同步） 的匿名函式
*  區塊內*lock_statement*
*  在 unsafe 內容中

請注意， *await_expression*內的大部分位置中不會發生*query_expression>*，因為這些語法轉換成使用非同步 lambda 運算式。

在非同步函式內`await`不能當做識別項。 因此，await 運算式與包含識別碼的各種運算式之間沒有語法模稜兩可。 非同步函式中，外部`await`做為一般識別項。

運算元*await_expression*稱為***工作***。 它代表非同步作業，可能會或可能不完整當時*await_expression*評估。 Await 運算子的目的是暫止的封入的非同步函式的執行，直到等候的工作完成，並取得其結果。

#### <a name="awaitable-expressions"></a>可等候的運算式

Await 運算式的工作，一定要***awaitable***。 運算式`t`不必是即時資訊，如果下列其中一種保留：

*  `t` 編譯時間類型 `dynamic`
*  `t` 具有可存取執行個體或擴充的方法呼叫`GetAwaiter`沒有參數並沒有類型參數，且傳回類型與`A`，下列全部保留：
   * `A` 實作介面`System.Runtime.CompilerServices.INotifyCompletion`(以下稱為`INotifyCompletion`為求簡單明瞭)
   * `A` 具有可供存取的可讀取的執行個體屬性`IsCompleted`的型別 `bool`
   * `A` 具有可存取的執行個體的方法`GetResult`沒有任何參數，沒有類型參數

目的`GetAwaiter`方法，是取得***awaiter***工作。 型別`A`稱為***awaiter 的型別***await 運算式。

目的`IsCompleted`屬性是要判斷工作是否已經完成。 若是如此，不是需要暫停評估。

目的`INotifyCompletion.OnCompleted`方法是註冊 「 接續 」 工作，也就是委派 (型別的`System.Action`)，將會叫用完成工作之後。

目的`GetResult`方法是完成後，取得工作的結果。 此結果可能會成功完成時，可能與結果值，或它可能會擲回的例外狀況`GetResult`方法。

#### <a name="classification-of-await-expressions"></a>分類的 await 運算式

運算式`await t`運算式的相同方式來分類`(t).GetAwaiter().GetResult()`。 因此，如果傳回類型`GetResult`是`void`，則*await_expression*歸類為執行任何動作。 如果它具有非 void 傳回型別`T`，則*await_expression*分類類型的值為`T`。

#### <a name="runtime-evaluation-of-await-expressions"></a>執行階段評估的 await 運算式

在執行階段，運算式`await t`評估如下：

*  Awaiter`a`來評估運算式取得`(t).GetAwaiter()`。
*  A `bool` `b`所評估的運算式取得`(a).IsCompleted`。
*  如果`b`已`false`然後評估取決於是否`a`實作介面`System.Runtime.CompilerServices.ICriticalNotifyCompletion`(以下稱為`ICriticalNotifyCompletion`為求簡單明瞭)。 這項檢查是在繫結時間;也就是在執行階段若`a`編譯時間類型`dynamic`，而是在編譯階段則。 可讓`r`表示繼續委派 ([迭代器](classes.md#iterators)):
    * 如果`a`不會實作`ICriticalNotifyCompletion`，然後運算式`(a as (INotifyCompletion)).OnCompleted(r)`評估。
    * 如果`a`未實作`ICriticalNotifyCompletion`，然後運算式`(a as (ICriticalNotifyCompletion)).UnsafeOnCompleted(r)`評估。
    * 評估已然後暫停，而控制權給目前的呼叫端的非同步函式。
*  其中一個後立即 (如果`b`已`true`)，或是在稍後繼續委派引動過程 (如果`b`已`false`)，運算式`(a).GetResult()`評估。 如果傳回值，該值是結果*await_expression*。 否則結果就是執行任何動作。

實作介面方法的 awaiter`INotifyCompletion.OnCompleted`和`ICriticalNotifyCompletion.UnsafeOnCompleted`應該會造成委派`r`最多一次叫用。 否則，封入的非同步函式的行為未定義。

## <a name="arithmetic-operators"></a>算術運算子

`*`， `/`， `%`， `+`，和`-`運算子都稱為算術的運算子。

```antlr
multiplicative_expression
    : unary_expression
    | multiplicative_expression '*' unary_expression
    | multiplicative_expression '/' unary_expression
    | multiplicative_expression '%' unary_expression
    ;

additive_expression
    : multiplicative_expression
    | additive_expression '+' multiplicative_expression
    | additive_expression '-' multiplicative_expression
    ;
```

算術運算子的運算元是否在編譯時期型別`dynamic`，然後動態地繫結運算式 ([動態繫結](expressions.md#dynamic-binding))。 運算式的編譯時期型別是在此情況下`dynamic`，如下所述的解析度會發生在執行階段使用這些已編譯時間類型的運算元的執行階段型別和`dynamic`。

### <a name="multiplication-operator"></a>乘法運算子

作業的表單`x * y`，二元運算子多載解析 ([二元運算子多載解析](expressions.md#binary-operator-overload-resolution)) 套用至選取的特定運算子實作。 運算元會轉換成所選的運算子的參數類型和結果的類型是運算子的傳回型別。

以下列出預先定義的乘法運算子。 這些運算子都會計算乘積`x`和`y`。

*  整數乘法：

   ```csharp
   int operator *(int x, int y);
   uint operator *(uint x, uint y);
   long operator *(long x, long y);
   ulong operator *(ulong x, ulong y);
   ```

   在 `checked`情況下，如果產品是範圍之外的結果型別`System.OverflowException`就會擲回。 在 `unchecked`內容中，不會報告溢位，並捨棄任何重大高序位位元的範圍之外的結果型別。


*  浮點數的乘法：

   ```csharp
   float operator *(float x, float y);
   double operator *(double x, double y);
   ```

   根據 IEEE 754 算術的規則會計算乘積。 下表列出的非零的有限值的所有可能組合、 零、 無限及 NaN 的結果。 在資料表中，`x`和`y`是有限的正值。 `z` 結果的`x * y`。 如果結果太大的目的型別，如`z`是無限大。 如果結果太小的目的型別，`z`為零。

   |      |      |      |     |     |      |      |     |
   |:----:|-----:|:----:|:---:|:---:|:----:|:----:|:----|
   |      | + y   | -y   | +0  | -0  | +inf | -inf | NaN | 
   | + x   | + z   | -z   | +0  | -0  | +inf | -inf | NaN | 
   | -x   | -z   | + z   | -0  | +0  | -inf | +inf | NaN | 
   | +0   | +0   | -0   | +0  | -0  | NaN  | NaN  | NaN | 
   | -0   | -0   | +0   | -0  | +0  | NaN  | NaN  | NaN | 
   | +inf | +inf | -inf | NaN | NaN | +inf | -inf | NaN | 
   | -inf | -inf | +inf | NaN | NaN | -inf | +inf | NaN | 
   | NaN  | NaN  | NaN  | NaN | NaN | NaN  | NaN  | NaN | 

*  十進位乘法：

   ```csharp
   decimal operator *(decimal x, decimal y);
   ```

   產生的值是否太大，無法在代表`decimal`格式，`System.OverflowException`就會擲回。 如果結果值太小而無法在代表`decimal`格式時，結果會是零。 結果，在任何進位之前的小數位數是個兩個運算元的總和。

   十進位乘法相當於使用乘法運算子型別的`System.Decimal`。


### <a name="division-operator"></a>除法運算子

作業的表單`x / y`，二元運算子多載解析 ([二元運算子多載解析](expressions.md#binary-operator-overload-resolution)) 套用至選取的特定運算子實作。 運算元會轉換成所選的運算子的參數類型和結果的類型是運算子的傳回型別。

以下列出預先定義的除法運算子。 這些運算子都會計算商數`x`和`y`。

*  整數除法運算：

   ```csharp
   int operator /(int x, int y);
   uint operator /(uint x, uint y);
   long operator /(long x, long y);
   ulong operator /(ulong x, ulong y);
   ```

   如果右運算元的值為零，`System.DivideByZeroException`就會擲回。

   除法運算會無條件推向零結果。 因此結果的絕對值是商數的小於或等於兩個運算元絕對值的最大可能整數。 當兩個運算元具有相同的正負號和零或負的兩個運算元是相反的符號時，結果會是零或正數。

   如果左的運算元是可代表最小`int`或是`long`值和右運算元是`-1`，就會發生溢位。 在 `checked`內容，這會導致`System.ArithmeticException`（或子類別） 將會擲回。 在`unchecked`內容中，它是由實作定義是否`System.ArithmeticException`（或子類別） 會擲回或產生的值為，左邊運算元的附帶未回報的溢位。

*  浮點的除數：

   ```csharp
   float operator /(float x, float y);
   double operator /(double x, double y);
   ```

   根據 IEEE 754 算術的規則計算商數。 下表列出的非零的有限值的所有可能組合、 零、 無限及 NaN 的結果。 在資料表中，`x`和`y`是有限的正值。 `z` 結果的`x / y`。 如果結果太大的目的型別，如`z`是無限大。 如果結果太小的目的型別，`z`為零。

   |      |      |      |      |      |      |      |      |
   |:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
   |      | + y   | -y   | +0   | -0   | +inf | -inf | NaN  | 
   | + x   | + z   | -z   | +inf | -inf | +0   | -0   | NaN  | 
   | -x   | -z   | + z   | -inf | +inf | -0   | +0   | NaN  | 
   | +0   | +0   | -0   | NaN  | NaN  | +0   | -0   | NaN  | 
   | -0   | -0   | +0   | NaN  | NaN  | -0   | +0   | NaN  | 
   | +inf | +inf | -inf | +inf | -inf | NaN  | NaN  | NaN  | 
   | -inf | -inf | +inf | -inf | +inf | NaN  | NaN  | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 

*  十進位部門：

   ```csharp
   decimal operator /(decimal x, decimal y);
   ```

   如果右運算元的值為零，`System.DivideByZeroException`就會擲回。 產生的值是否太大，無法在代表`decimal`格式，`System.OverflowException`就會擲回。 如果結果值太小而無法在代表`decimal`格式時，結果會是零。 結果的小數位數是保留的結果會等於最小小數位數最接近的可代表的十進位值，則為 true 的數學結果。

   十進位的除法就相當於使用此類型的除法運算子`System.Decimal`。


### <a name="remainder-operator"></a>餘數運算子

作業的表單`x % y`，二元運算子多載解析 ([二元運算子多載解析](expressions.md#binary-operator-overload-resolution)) 套用至選取的特定運算子實作。 運算元會轉換成所選的運算子的參數類型和結果的類型是運算子的傳回型別。

以下列出預先定義的餘數運算子。 這些運算子都會計算之間除法的餘數`x`和`y`。

*  整數餘數：

   ```csharp
   int operator %(int x, int y);
   uint operator %(uint x, uint y);
   long operator %(long x, long y);
   ulong operator %(ulong x, ulong y);
   ```

   結果`x % y`由所產生值`x - (x / y) * y`。 如果`y`為零，`System.DivideByZeroException`就會擲回。

   如果左的運算元是最小`int`或是`long`值和右運算元是`-1`、`System.OverflowException`就會擲回。 在任何情況下並未`x % y`擲回例外狀況，`x / y`不會擲回例外狀況。

*  浮點數餘數：

   ```csharp
   float operator %(float x, float y);
   double operator %(double x, double y);
   ```

   下表列出的非零的有限值的所有可能組合、 零、 無限及 NaN 的結果。 在資料表中，`x`和`y`是有限的正值。 `z` 是的結果`x % y`並為計算`x - n * y`，其中`n`小於或等於最大可能整數`x / y`。 計算餘數的這個方法相當於使用整數運算元，但不同於 IEEE 754 定義 (所在`n`是最接近的整數`x / y`)。

   |      |      |      |      |      |      |      |      |
   |:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
   |      | + y   | -y   | +0   | -0   | +inf | -inf | NaN  | 
   | + x   | + z   | + z   | NaN  | NaN  | x    | x    | NaN  | 
   | -x   | -z   | -z   | NaN  | NaN  | -x   | -x   | NaN  | 
   | +0   | +0   | +0   | NaN  | NaN  | +0   | +0   | NaN  | 
   | -0   | -0   | -0   | NaN  | NaN  | -0   | -0   | NaN  | 
   | +inf | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 
   | -inf | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 

*  十進位的其餘部分：

   ```csharp
   decimal operator %(decimal x, decimal y);
   ```

   如果右運算元的值為零，`System.DivideByZeroException`就會擲回。 較大的兩個運算元，標尺的小數位數的結果，在任何進位之前且正負號的結果，如果不是零，等同於的`x`。

   十進位的其餘部分就相當於使用餘數運算子的型別`System.Decimal`。


### <a name="addition-operator"></a>加法運算子

作業的表單`x + y`，二元運算子多載解析 ([二元運算子多載解析](expressions.md#binary-operator-overload-resolution)) 套用至選取的特定運算子實作。 運算元會轉換成所選的運算子的參數類型和結果的類型是運算子的傳回型別。

以下列出預先定義的加法運算子。 對於數值和列舉型別，預先定義的加法運算子計算兩個運算元的總和。 當一個或兩個運算元字串類型時，預先定義的加法運算子會串連運算元的字串表示。

*  整數加法：

   ```csharp
   int operator +(int x, int y);
   uint operator +(uint x, uint y);
   long operator +(long x, long y);
   ulong operator +(ulong x, ulong y);
   ```

   在 `checked`情況下，如果總和超出範圍的結果型別，`System.OverflowException`就會擲回。 在 `unchecked`內容中，不會報告溢位，並捨棄任何重大高序位位元的範圍之外的結果型別。

*  浮點加法：

   ```csharp
   float operator +(float x, float y);
   double operator +(double x, double y);
   ```

   根據 IEEE 754 算術的規則會計算總和。 下表列出的非零的有限值的所有可能組合、 零、 無限及 NaN 的結果。 在資料表中，`x`並`y`是非零的有限值，並`z`結果`x + y`。 如果`x`並`y`具有相同大小但正負號，相反`z`是正零。 如果`x + y`太大，目的型別，表示`z`是使用相同的簽章，為無限大`x + y`。

   |      |      |      |      |      |      |      |
   |:----:|:----:|:----:|:----:|:----:|:----:|:----:|
   |      | y    | +0   | -0   | +inf | -inf | NaN  | 
   | x    | z    | x    | x    | +inf | -inf | NaN  | 
   | +0   | y    | +0   | +0   | +inf | -inf | NaN  | 
   | -0   | y    | +0   | -0   | +inf | -inf | NaN  | 
   | +inf | +inf | +inf | +inf | +inf | NaN  | NaN  | 
   | -inf | -inf | -inf | -inf | NaN  | -inf | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 

*  十進位的加法：

   ```csharp
   decimal operator +(decimal x, decimal y);
   ```

   產生的值是否太大，無法在代表`decimal`格式，`System.OverflowException`就會擲回。 結果，在任何進位之前的標尺是較大的兩個運算元的標尺。

   十進位新增相當於使用的型別，加法運算子`System.Decimal`。

*  列舉型別加入。 每個列舉類型都會隱含地提供下列預先定義的運算子，其中`E`是列舉類型，並`U`為基礎的類型`E`:

   ```csharp
   E operator +(E x, U y);
   E operator +(U x, E y);
   ```

   在執行階段評估這些運算子完全相同`(E)((U)x + (U)y)`。

*  字串串連：

   ```csharp
   string operator +(string x, string y);
   string operator +(string x, object y);
   string operator +(object x, string y);
   ```

   這些多載的二進位檔`+`運算子執行字串串連。 如果運算元字串串連的`null`，空字串用來替代。 否則，任何非字串引數會轉換為其字串表示所叫用的虛擬`ToString`方法繼承自型別的`object`。 如果`ToString`傳回`null`，空字串用來替代。

   ```csharp
   using System;
   
   class Test
   {
       static void Main() {
           string s = null;
           Console.WriteLine("s = >" + s + "<");        // displays s = ><
           int i = 1;
           Console.WriteLine("i = " + i);               // displays i = 1
           float f = 1.2300E+15F;
           Console.WriteLine("f = " + f);               // displays f = 1.23E+15
           decimal d = 2.900m;
           Console.WriteLine("d = " + d);               // displays d = 2.900
       }
   }
   ```

   字串串連運算子的結果是後面接著的字元，右邊運算元的左運算元的字元所組成的字串。 字串串連運算子永遠不會傳回`null`值。 A`System.OutOfMemoryException`如果記憶體不足，無法配置所產生的字串可能會擲回。

*  委派組合。 每個委派型別都會隱含地提供下列預先定義的運算子，其中`D`是委派型別：

   ```csharp
   D operator +(D x, D y);
   ```

   二進位`+`這兩個運算元都是相同委派型別時，運算子會執行委派組合`D`。 （如果運算元有不同的委派類型時，繫結階段會發生錯誤。）如果在第一個運算元`null`，此作業的結果是第二個運算元的值 (即使這也是`null`)。 否則，如果第二個運算元是`null`，則作業的結果為第一個運算元的值。 否則，作業的結果就是新的委派執行個體，當叫用時，會叫用第一個運算元而再叫用第二個運算元。 例如委派組合的詳細資訊，請參閱[減法運算子](expressions.md#subtraction-operator)並[委派引動過程](delegates.md#delegate-invocation)。 由於`System.Delegate`不是委派型別`operator` `+`未定義它。

### <a name="subtraction-operator"></a>減法運算子

作業的表單`x - y`，二元運算子多載解析 ([二元運算子多載解析](expressions.md#binary-operator-overload-resolution)) 套用至選取的特定運算子實作。 運算元會轉換成所選的運算子的參數類型和結果的類型是運算子的傳回型別。

以下列出預先定義的減法運算子。 所有減運算子`y`從`x`。

*  整數減法：

   ```csharp
   int operator -(int x, int y);
   uint operator -(uint x, uint y);
   long operator -(long x, long y);
   ulong operator -(ulong x, ulong y);
   ```

   在 `checked`情況下，差異在於範圍之外的結果型別，如果`System.OverflowException`就會擲回。 在 `unchecked`內容中，不會報告溢位，並捨棄任何重大高序位位元的範圍之外的結果型別。

*  浮點數的減法運算：

   ```csharp
   float operator -(float x, float y);
   double operator -(double x, double y);
   ```

   根據 IEEE 754 算術的規則被計算的差異。 下表列出非零的有限值的所有可能組合、 零、 無限及 Nan 的結果。 在資料表中，`x`並`y`是非零的有限值，並`z`結果`x - y`。 如果`x`並`y`相等，`z`是正零。 如果`x - y`太大，目的型別，表示`z`是使用相同的簽章，為無限大`x - y`。

   |      |      |      |      |      |      |     |
   |:----:|:----:|:----:|:----:|:----:|:----:|:---:|
   | NaN  | y    | +0   | -0   | +inf | -inf | NaN | 
   | x    | z    | x    | x    | -inf | +inf | NaN | 
   | +0   | -y   | +0   | +0   | -inf | +inf | NaN | 
   | -0   | -y   | -0   | +0   | -inf | +inf | NaN | 
   | +inf | +inf | +inf | +inf | NaN  | +inf | NaN | 
   | -inf | -inf | -inf | -inf | -inf | NaN  | NaN | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN | 

*  十進位的減法運算：

   ```csharp
   decimal operator -(decimal x, decimal y);
   ```

   產生的值是否太大，無法在代表`decimal`格式，`System.OverflowException`就會擲回。 結果，在任何進位之前的標尺是較大的兩個運算元的標尺。

   十進位減法相當於使用此類型的減法運算子`System.Decimal`。

*  列舉型別減法。 每個列舉類型都會隱含地提供下列預先定義的運算子，其中`E`是列舉類型，並`U`為基礎的類型`E`:

   ```csharp
   U operator -(E x, E y);
   ```

   這個運算子會評估完全為`(U)((U)x - (U)y)`。 換句話說，運算子會計算的值之間的差異`x`和`y`，且結果類型是列舉的基礎類型。

   ```csharp
   E operator -(E x, U y);
   ```

   這個運算子會評估完全為`(E)((U)x - y)`。 換句話說，運算子減去值之基礎類型的列舉型別，產生的列舉值。

*  委派移除。 每個委派型別都會隱含地提供下列預先定義的運算子，其中`D`是委派型別：

   ```csharp
   D operator -(D x, D y);
   ```

   二進位`-`這兩個運算元都是相同委派型別時，運算子會執行委派移除`D`。 如果運算元有不同的委派類型時，繫結階段會發生錯誤。 如果在第一個運算元`null`，此作業的結果是`null`。 否則，如果第二個運算元是`null`，則作業的結果為第一個運算元的值。 否則，這兩個運算元都代表引動過程清單 ([委派宣告](delegates.md#delegate-declarations)) 具有一或多個項目，以及結果是新的引動過程清單移除的第二個運算元的項目所組成的第一個運算元的清單它提供第二個運算元的清單是適當的連續子清單的第一個。     (若要判斷子清單相等，對應的項目會比較和委派等號比較運算子 ([委派等號比較運算子](expressions.md#delegate-equality-operators))。)否則，結果就是左運算元的值。 任一運算元的清單會變更處理序中。 如果第二個運算元的清單會比對多個的之子清單的第一個運算元的清單中的連續項目，則會移除最右邊的相符子清單的連續項目。 如果移除會導致空的清單，則結果是`null`。 例如: 

   ```csharp
   delegate void D(int x);
   
   class C
   {
       public static void M1(int i) { /* ... */ }
       public static void M2(int i) { /* ... */ }
   }

   class Test
   {
       static void Main() { 
           D cd1 = new D(C.M1);
           D cd2 = new D(C.M2);
           D cd3 = cd1 + cd2 + cd2 + cd1;   // M1 + M2 + M2 + M1
           cd3 -= cd1;                      // => M1 + M2 + M2
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd1 + cd2;                // => M2 + M1
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd2 + cd2;                // => M1 + M1
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd2 + cd1;                // => M1 + M2
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd1 + cd1;                // => M1 + M2 + M2 + M1
       }
   }
   ```

## <a name="shift-operators"></a>移位運算子

`<<`和`>>`運算子用來執行位元移位運算。

```antlr
shift_expression
    : additive_expression
    | shift_expression '<<' additive_expression
    | shift_expression right_shift additive_expression
    ;
```

如果運算元*shift_expression*已在編譯時期型別`dynamic`，然後動態地繫結運算式 ([動態繫結](expressions.md#dynamic-binding))。 運算式的編譯時期型別是在此情況下`dynamic`，如下所述的解析度會發生在執行階段使用這些已編譯時間類型的運算元的執行階段型別和`dynamic`。

作業的表單`x << count`或是`x >> count`，二元運算子多載解析 ([二元運算子多載解析](expressions.md#binary-operator-overload-resolution)) 套用至選取的特定運算子實作。 運算元會轉換成所選的運算子的參數類型和結果的類型是運算子的傳回型別。

宣告多載的移位運算子，第一個運算元的類型必須一律是類別或結構，包含運算子宣告中，而且第二個運算元的類型必須永遠`int`。

以下列出預先定義的移位運算子。

*  提早測試：

   ```csharp
   int operator <<(int x, int count);
   uint operator <<(uint x, int count);
   long operator <<(long x, int count);
   ulong operator <<(ulong x, int count);
   ```

   `<<`運算子的排班`x`左旋轉的位元數計算，如下所述。

   高序位位元的範圍之外的結果型別的`x`會捨棄其餘的位元會向左移位，而的低序位空的位元位置會設定為零。

*  向右移位：

   ```csharp
   int operator >>(int x, int count);
   uint operator >>(uint x, int count);
   long operator >>(long x, int count);
   ulong operator >>(ulong x, int count);
   ```

   `>>`運算子的排班`x`權限的位元數計算，如下所述。

   當`x`屬於型別`int`或`long`的低序位位元`x`會捨棄，其餘的位元會向右移位，而且的高序位空的位元位置會設定為零，如果`x`是非負值，而且設定為一個`x`為負數。

   當`x`屬於型別`uint`或`ulong`的低序位位元`x`會捨棄其餘的位元會向右移位，和的高序位空的位元位置會設定為零。

預先定義的運算子，移位的位元數字的計算方式如下：

*  當的型別`x`是`int`或`uint`，則指定移位計數是低序位五個位元的`count`。 換句話說，移位計數從計算`count & 0x1F`。
*  當的型別`x`是`long`或是`ulong`的低序位六位元指定移位計數是`count`。 換句話說，移位計數從計算`count & 0x3F`。

如果產生的移位計數為零，移位運算子只會傳回的值`x`。

移位作業絕不會造成溢位，並產生相同的結果中`checked`和`unchecked`內容。

當左的運算元`>>`運算子不帶正負號的整數類資料類型，運算子就會執行算術右運算元的最大顯著性位元 （正負號位元） 值會傳播其中至空白高序位的位元位置。 當左的運算元`>>`運算子是的不帶正負號的整數類資料類型時，運算子就會執行邏輯向右移位，其中空高序位的位元位置一律會設定為零。 若要執行作業的運算元類型推斷相反，可以使用明確的轉換。 比方說，如果`x`類型的變數`int`，此作業`unchecked((int)((uint)x >> y))`就會執行邏輯的`x`。

## <a name="relational-and-type-testing-operators"></a>關係和類型測試運算子

`==`， `!=`， `<`， `>`， `<=`， `>=`，`is`和`as`運算子都稱為關係和類型測試運算子。

```antlr
relational_expression
    : shift_expression
    | relational_expression '<' shift_expression
    | relational_expression '>' shift_expression
    | relational_expression '<=' shift_expression
    | relational_expression '>=' shift_expression
    | relational_expression 'is' type
    | relational_expression 'as' type
    ;

equality_expression
    : relational_expression
    | equality_expression '==' relational_expression
    | equality_expression '!=' relational_expression
    ;
```

`is`運算子所述[是運算子](expressions.md#the-is-operator)並`as`運算子所述[As 運算子](expressions.md#the-as-operator)。

`==`， `!=`， `<`， `>`，`<=`並`>=`運算子***比較運算子***。

比較運算子的運算元是否在編譯時期型別`dynamic`，然後動態地繫結運算式 ([動態繫結](expressions.md#dynamic-binding))。 運算式的編譯時期型別是在此情況下`dynamic`，如下所述的解析度會發生在執行階段使用這些已編譯時間類型的運算元的執行階段型別和`dynamic`。

作業的表單`x` *op* `y`，其中*op*是一個比較運算子，而多載解析 ([二元運算子多載解析](expressions.md#binary-operator-overload-resolution)) 套用至選取的特定運算子實作。 運算元會轉換成所選的運算子的參數類型和結果的類型是運算子的傳回型別。

預先定義的比較運算子是由下列各節所述。 所有預先定義的比較運算子傳回類型之結果的`bool`下, 表中所述。


| __作業__ | __結果__                                                       |
|---------------|------------------------------------------------------------------|
| `x == y`      | `true` 如果`x`等於`y`，`false`否則                 | 
| `x != y`      | `true` 如果`x`不等於`y`，`false`否則             | 
| `x < y`       | `true` 如果`x`是小於`y`，`false`否則                | 
| `x > y`       | `true` 如果`x`大於`y`，`false`否則             | 
| `x <= y`      | `true` 如果`x`小於或等於`y`，`false`否則    | 
| `x >= y`      | `true` 如果`x`大於或等於`y`，`false`否則 | 

### <a name="integer-comparison-operators"></a>整數比較運算子

預先定義的整數比較運算子包括︰
```csharp
bool operator ==(int x, int y);
bool operator ==(uint x, uint y);
bool operator ==(long x, long y);
bool operator ==(ulong x, ulong y);

bool operator !=(int x, int y);
bool operator !=(uint x, uint y);
bool operator !=(long x, long y);
bool operator !=(ulong x, ulong y);

bool operator <(int x, int y);
bool operator <(uint x, uint y);
bool operator <(long x, long y);
bool operator <(ulong x, ulong y);

bool operator >(int x, int y);
bool operator >(uint x, uint y);
bool operator >(long x, long y);
bool operator >(ulong x, ulong y);

bool operator <=(int x, int y);
bool operator <=(uint x, uint y);
bool operator <=(long x, long y);
bool operator <=(ulong x, ulong y);

bool operator >=(int x, int y);
bool operator >=(uint x, uint y);
bool operator >=(long x, long y);
bool operator >=(ulong x, ulong y);
```

每個運算子比較兩個整數運算元和傳回的數值`bool`值，指出特定的關聯性是否`true`或`false`。

### <a name="floating-point-comparison-operators"></a>浮點數的比較運算子

預先定義的比較運算子包括︰
```csharp
bool operator ==(float x, float y);
bool operator ==(double x, double y);

bool operator !=(float x, float y);
bool operator !=(double x, double y);

bool operator <(float x, float y);
bool operator <(double x, double y);

bool operator >(float x, float y);
bool operator >(double x, double y);

bool operator <=(float x, float y);
bool operator <=(double x, double y);

bool operator >=(float x, float y);
bool operator >=(double x, double y);
```

運算子會比較運算元根據 IEEE 754 標準的規則：

*  如果任一個運算元是 NaN，則結果是`false`以外的所有運算子`!=`，其結果為`true`。 對於任何兩個運算元，`x != y`一定會產生相同結果`!(x == y)`。 不過，當一或兩個運算元都是 NaN， `<`， `>`， `<=`，和`>=`運算子不會產生相反的運算子的邏輯否定與相同的結果。 例如，如果有任一個的`x`並`y`是 NaN，則`x < y`是`false`，但`!(x >= y)`是`true`。
*  當兩個運算元是 NaN 時，運算子會比較兩個浮點運算元相對於排序的值

   ```
   -inf < -max < ... < -min < -0.0 == +0.0 < +min < ... < +max < +inf
   ```

   何處`min`和`max`會最小和最大正數有限值表示指定的浮點格式。 值得注意的這個順序的影響如下：
   * 負向及正零會視為相等。
   * 負的無限值會被視為小於比所有其他值，但等於另一個負無限大。
   * 大於所有其他值，但等於另一個正無限大，則會被視為無限大的正數。

### <a name="decimal-comparison-operators"></a>十進位的比較運算子

預先定義的十進位比較運算子包括︰
```csharp
bool operator ==(decimal x, decimal y);
bool operator !=(decimal x, decimal y);
bool operator <(decimal x, decimal y);
bool operator >(decimal x, decimal y);
bool operator <=(decimal x, decimal y);
bool operator >=(decimal x, decimal y);
```

每個運算子比較兩個十進位運算元和傳回數值`bool`值，指出特定的關聯性是否`true`或`false`。 每個小數點的比較就相當於使用的對應關聯式或類型的等號比較運算子`System.Decimal`。

### <a name="boolean-equality-operators"></a>布林值等號比較運算子

預先定義的布林等號比較運算子包括︰
```csharp
bool operator ==(bool x, bool y);
bool operator !=(bool x, bool y);
```

結果`==`是`true`如果兩個`x`並`y`會`true`或如果兩個`x`並`y`是`false`。 否則，結果為 `false`。

結果`!=`是`false`如果兩個`x`並`y`會`true`或如果兩個`x`並`y`是`false`。 否則，結果為 `true`。 當運算元都是型別`bool`，則`!=`運算子會產生相同結果`^`運算子。

### <a name="enumeration-comparison-operators"></a>列舉型別比較運算子

每個列舉類型都會隱含地提供下列預先定義的比較運算子：
```csharp
bool operator ==(E x, E y);
bool operator !=(E x, E y);
bool operator <(E x, E y);
bool operator >(E x, E y);
bool operator <=(E x, E y);
bool operator >=(E x, E y);
```

評估的結果`x op y`，其中`x`並`y`是列舉型別的運算式`E`基礎型別`U`，和`op`是其中一個比較運算子，是完全相同評估`((U)x) op ((U)y)`。 換句話說，列舉型別比較運算子只會比較兩個運算元的基礎整數值。

### <a name="reference-type-equality-operators"></a>參考型別等號比較運算子

預先定義的參考類型的等號比較運算子包括︰
```csharp
bool operator ==(object x, object y);
bool operator !=(object x, object y);
```

運算子會傳回比較兩個參考相等或不等號比較的結果。

因為預先定義的參考類型的等號比較運算子接受類型的運算元`object`，它們適用於所有類型的未宣告適用`operator ==`和`operator !=`成員。 相反地，任何適用於使用者定義的等號比較運算子可以有效地隱藏預先定義的參考類型的等號比較運算子。

預先定義的參考類型的等號比較運算子需要下列其中一項：

*  這兩個運算元都是已知型別的值*reference_type*常值或`null`。 此外，明確參考轉換 ([明確參考轉換](conversions.md#explicit-reference-conversions)) 將另一個運算元的型別有任一個運算元的類型。
*  有一個運算元是值型別的`T`所在`T`是*type_parameter*另一個運算元為常值和`null`。 此外`T`沒有實值類型條件約束。

除非符合下列條件之一成立，繫結階段會發生錯誤。 值得注意的影響，這些規則是：

*  它是繫結時間錯誤使用預先定義的參考類型的等號比較運算子來比較兩個已知為不同繫結時間的參考。 比方說，如果繫結時間類型的運算元都是兩個類別類型`A`並`B`，和如果既未`A`也不`B`自另一個，則會是不可能的兩個運算元參考到相同的物件。 因此，此作業會被視為一個繫結錯誤。
*  預先定義的參考類型的等號比較運算子不允許的值進行比較的型別運算元。 因此，除非結構類型會宣告它自己的等號比較運算子，不可能比較該結構類型的值。
*  預先定義的參考類型的等號比較運算子永遠不會導致發生其運算元的 boxing 作業。 它會執行這類的 boxing 作業，因為新配置已封裝的執行個體參考一定會不同於其他的所有參考意義。
*  如果型別參數類型的運算元`T`相較於`null`，和執行階段類型`T`實值型別比較的結果是`false`。

下列範例會檢查未受限制的型別參數類型的引數是否`null`。
```csharp
class C<T>
{
    void F(T x) {
        if (x == null) throw new ArgumentNullException();
        ...
    }
}
```

`x == null`即使允許建構`T`可能代表實值類型，以及結果只定義為`false`當`T`是實值類型。

作業的表單`x == y`或`x != y`，如果任何適用`operator ==`或`operator !=`存在，運算子多載解析 ([二元運算子多載解析](expressions.md#binary-operator-overload-resolution)) 規則將會選取，而不是預先定義的參考類型的等號比較運算子的運算子。 不過，它就一定能夠選取預先定義的參考類型的等號比較運算子，明確轉換一或兩個輸入運算元`object`。 此範例
```csharp
using System;

class Test
{
    static void Main() {
        string s = "Test";
        string t = string.Copy(s);
        Console.WriteLine(s == t);
        Console.WriteLine((object)s == t);
        Console.WriteLine(s == (object)t);
        Console.WriteLine((object)s == (object)t);
    }
}
```
產生下列輸出
```
True
False
False
False
```

`s`並`t`變數參考兩個不同`string`包含相同字元的執行個體。 第一個比較輸出`True`因為預先定義的字串等號比較運算子 ([字串等號比較運算子](expressions.md#string-equality-operators)) 這兩個運算元屬於型別時，會選取`string`。 所有其他的比較輸出`False`因為一或兩個運算元屬於類型時，會選取預先定義的參考類型的等號比較運算子`object`。

請注意，上述的技巧並不會對實值型別有意義。 此範例
```csharp
class Test
{
    static void Main() {
        int i = 123;
        int j = 123;
        System.Console.WriteLine((object)i == (object)j);
    }
}
```
輸出`False`因為轉換會建立兩個不同的執行個體的參考進行 boxed 處理`int`值。

### <a name="string-equality-operators"></a>字串等號比較運算子

預先定義的字串等號比較運算子包括︰
```csharp
bool operator ==(string x, string y);
bool operator !=(string x, string y);
```

兩個`string`值都視為相等，當下列其中一項條件成立：

*  這兩個值是`null`。
*  這兩個值是在每個字元的位置中有相同的長度，以及完全相同字元的字串執行個體的非 null 參考。

字串等號比較運算子比較字串值，而不是字串的參考。 當兩個不同的字串執行個體包含完全相同的字元序列時，字串的值相等，但參考不同。 中所述[參考型別等號比較運算子](expressions.md#reference-type-equality-operators)，參考類型的等號比較運算子可用來比較字串的參考，而不是字串值。

### <a name="delegate-equality-operators"></a>委派等號比較運算子

每個委派類型以隱含方式提供下列預先定義的比較運算子：

```csharp
bool operator ==(System.Delegate x, System.Delegate y);
bool operator !=(System.Delegate x, System.Delegate y);
```

兩個委派執行個體視為相等，如下所示：

*  如果委派執行個體的任何一種`null`，它們是否相等的如果且只有兩者都是`null`。
*  如果委派具有不同的執行階段型別就是永遠不會相等。
*  如果這兩個委派執行個體具有引動過程清單 ([委派宣告](delegates.md#delegate-declarations))，這些執行個體相等，如果且只有其引動過程清單都有相同的長度，並在其中的引動過程清單中的每個項目是否相等 （如下列所定義）對應中的項目，其他的引動過程清單中的順序。

下列規則可管理引動過程清單項目的相等：

*  如果兩個引動過程清單項目這兩個參考相同的靜態方法，則項目相等。
*  如果兩個引動過程清單項目這兩個參考相同的非靜態方法，在相同的目標物件上 （如參考等號比較運算子所定義） 項目相等。
*  引動過程清單項目所產生的相同語意的評估*anonymous_method_expression*s 或*lambda_expression*與相同 （可能是空的） 擷取外部變數的集合執行個體所允許 （但非必要） 才會相等。

### <a name="equality-operators-and-null"></a>等號比較運算子和 null

`==`並`!=`運算子允許一個運算元是值為 null 的型別和其他為`null`常值，即使沒有預先定義或使用者定義的運算子 （使用或提昇的形式） 存在的作業。

其中一種形式的作業
```csharp
x == null
null == x
x != null
null != x
```
何處`x`類型的運算式可為 null，則運算子多載解析 ([二元運算子多載解析](expressions.md#binary-operator-overload-resolution)) 尋找適用的運算子，結果就無法改為從計算`HasValue`屬性`x`。 具體來說前, 兩個形式會轉譯成`!x.HasValue`，以及最後兩種形式會轉譯成`x.HasValue`。

### <a name="the-is-operator"></a>是運算子

`is`運算子用來以動態方式檢查 執行階段類型的物件是否與指定的型別相容。 作業的結果`E is T`，其中`E`是運算式和`T`是類型為布林值，這個值表示是否`E`成功轉換為類型`T`透過參考轉換、 boxing轉換或 unboxing 轉換。 作業會在之後的所有型別參數已取代型別引數，如下所示，評估：

*  如果`E`是匿名函式，就會發生編譯時期錯誤
*  如果`E`是方法群組或`null`常值，if 的型別`E`是參考型別或可為 null 的型別和值的`E`是 null，結果為 false。
*  否則，讓`D`代表的動態類型`E`，如下所示：
   * 如果類型`E`是參考型別`D`之執行個體參考的執行階段類型`E`。
   * 如果類型`E`是可為 null 的型別，`D`是該可為 null 的型別的基礎型別。
   * 如果類型`E`不可為 null 的實值型別，`D`是種`E`。
*  作業的結果會取決於`D`和`T`，如下所示：
   * 如果`T`是參考型別，結果為 true 如果`D`並`T`是相同的型別，如果`D`是參考類型，從隱含參考轉換`D`來`T`存在，或如果`D`是實值類型和 boxing 轉換`D`至`T`存在。
   * 如果`T`是可為 null 的型別，結果為 true 如果`D`則是基礎型別`T`。
   * 如果`T`不可為 null 的實值型別，則結果為 true 如果`D`和`T`都是相同的型別。
   * 否則，結果就是 false。

請注意，使用者定義轉換，不會考慮`is`運算子。

### <a name="the-as-operator"></a>As 運算子

`as`運算子用來明確地將值轉換為指定的參考型別或可為 null 的型別。 不同於轉型運算式 ([轉型運算式](expressions.md#cast-expressions))，則`as`運算子絕不會擲回的例外狀況。 相反地，如果指定的轉換不可行，產生的值是`null`。

在作業中的表單`E as T`，`E`必須是運算式和`T`必須是參考型別，已知為參考類型或可為 null 類型的型別參數。 此外，至少一個下列必須為 true，或否則會發生編譯時期錯誤：

*  身分識別 ([身分識別轉換](conversions.md#identity-conversion))、 隱含可為 null ([可為 null 的隱含轉換](conversions.md#implicit-nullable-conversions))，隱含參考 ([隱含參考轉換](conversions.md#implicit-reference-conversions))，boxing ([Boxing 轉換](conversions.md#boxing-conversions))、 明確可為 null ([明確可為 null 的轉換](conversions.md#explicit-nullable-conversions))，明確參考 ([明確參考轉換](conversions.md#explicit-reference-conversions))，或 unboxing ([Unboxing 轉換](conversions.md#unboxing-conversions)) 轉換存在`E`至`T`。
*  型別`E`或`T`是開啟型別。
*  `E` 是`null`常值。

編譯時間類型，是否`E`不是`dynamic`，此作業`E as T`產生相同結果
```csharp
E is T ? (T)(E) : (T)null
```
但只會評估 `E` 一次。 可預期的編譯器最佳化`E as T`執行最多一個動態型別檢查而不是上述擴充所隱含的兩個動態型別檢查。

編譯時間類型，是否`E`已`dynamic`，不像轉型運算子`as`運算子沒有動態繫結 ([動態繫結](expressions.md#dynamic-binding))。 因此擴充在此情況下是：
```csharp
E is T ? (T)(object)(E) : (T)null
```

請注意，某些轉換，例如使用者定義轉換，即無法在`as`運算子，而且應該改為執行使用轉型運算式。

在範例
```csharp
class X
{

    public string F(object o) {
        return o as string;        // OK, string is a reference type
    }

    public T G<T>(object o) where T: Attribute {
        return o as T;             // Ok, T has a class constraint
    }

    public U H<U>(object o) {
        return o as U;             // Error, U is unconstrained 
    }
}
```
型別參數`T`的`G`已知為參考類型，因為它具有類別條件約束。 型別參數`U`的`H`不是不過，因此使用`as`中的運算子`H`不被允許。

## <a name="logical-operators"></a>邏輯運算子

`&`， `^`，和`|`運算子都稱為邏輯運算子。

```antlr
and_expression
    : equality_expression
    | and_expression '&' equality_expression
    ;

exclusive_or_expression
    : and_expression
    | exclusive_or_expression '^' and_expression
    ;

inclusive_or_expression
    : exclusive_or_expression
    | inclusive_or_expression '|' exclusive_or_expression
    ;
```

邏輯運算子的運算元是否在編譯時期型別`dynamic`，然後動態地繫結運算式 ([動態繫結](expressions.md#dynamic-binding))。 運算式的編譯時期型別是在此情況下`dynamic`，如下所述的解析度會發生在執行階段使用這些已編譯時間類型的運算元的執行階段型別和`dynamic`。

作業的表單`x op y`，其中`op`是其中一個邏輯運算子，也就是多載解析 ([二元運算子多載解析](expressions.md#binary-operator-overload-resolution)) 套用至選取的特定運算子實作。 運算元會轉換成所選的運算子的參數類型和結果的類型是運算子的傳回型別。

預先定義的邏輯運算子會由下列各節所述。

### <a name="integer-logical-operators"></a>整數的邏輯運算子

預先定義之的整數的邏輯運算子包括︰
```csharp
int operator &(int x, int y);
uint operator &(uint x, uint y);
long operator &(long x, long y);
ulong operator &(ulong x, ulong y);

int operator |(int x, int y);
uint operator |(uint x, uint y);
long operator |(long x, long y);
ulong operator |(ulong x, ulong y);

int operator ^(int x, int y);
uint operator ^(uint x, uint y);
long operator ^(long x, long y);
ulong operator ^(ulong x, ulong y);
```

`&`運算子會計算位元邏輯`AND`兩個運算元`|`運算子會計算位元邏輯`OR`兩個運算元和`^`運算子計算位元邏輯互斥`OR`兩個運算元。 從這些作業可能不會有任何溢位。

### <a name="enumeration-logical-operators"></a>列舉邏輯運算子

每個列舉類型`E`都會隱含地提供下列預先定義的邏輯運算子：

```csharp
E operator &(E x, E y);
E operator |(E x, E y);
E operator ^(E x, E y);
```

評估的結果`x op y`，其中`x`並`y`是列舉型別的運算式`E`基礎型別`U`，和`op`是其中一個邏輯運算子，是完全相同評估`(E)((U)x op (U)y)`。 換句話說，列舉型別邏輯運算子只會執行之基礎類型的兩個運算元的邏輯作業。

### <a name="boolean-logical-operators"></a>布林值的邏輯運算子

預先定義的布林邏輯運算子包括︰
```csharp
bool operator &(bool x, bool y);
bool operator |(bool x, bool y);
bool operator ^(bool x, bool y);
```

若 `x` 及 `y` 皆為 `true`，那麼 `x & y` 的結果會是 `true`。 否則，結果為 `false`。

結果`x | y`已`true`如果`x`或是`y`是`true`。 否則，結果為 `false`。

結果`x ^ y`是`true`如果`x`是`true`並`y`是`false`，或`x`是`false`並`y`是`true`。 否則，結果為 `false`。 當運算元都是型別`bool`，則`^`運算子會計算為相同的結果`!=`運算子。

### <a name="nullable-boolean-logical-operators"></a>可為 null 的布林邏輯運算子

可為 null 的布林型別`bool?`可以代表三個值， `true`， `false`，和`null`，並在概念上類似 SQL 中的布林值運算式使用三種值的類型。 所產生的結果時，確保`&`並`|`運算子`bool?`運算元都與 SQL 的三個值的邏輯一致的會提供下列預先定義的運算子：

```csharp
bool? operator &(bool? x, bool? y);
bool? operator |(bool? x, bool? y);
```

下表列出這些運算子的所有值的組合所產生的結果`true`， `false`，和`null`。

| `x`     | `y`     | `x & y` | <code>x &#124; y</code> |
|:-------:|:-------:|:-------:|:-------:|
| `true`  | `true`  | `true`  | `true`  | 
| `true`  | `false` | `false` | `true`  | 
| `true`  | `null`  | `null`  | `true`  | 
| `false` | `true`  | `false` | `true`  | 
| `false` | `false` | `false` | `false` | 
| `false` | `null`  | `false` | `null`  | 
| `null`  | `true`  | `null`  | `true`  | 
| `null`  | `false` | `false` | `null`  | 
| `null`  | `null`  | `null`  | `null`  | 

## <a name="conditional-logical-operators"></a>條件式邏輯運算子

`&&`和`||`運算子稱為條件邏輯運算子。 它們也稱為 「 最少運算 」 的邏輯運算子。

```antlr
conditional_and_expression
    : inclusive_or_expression
    | conditional_and_expression '&&' inclusive_or_expression
    ;

conditional_or_expression
    : conditional_and_expression
    | conditional_or_expression '||' conditional_and_expression
    ;
```

`&&`並`||`是條件式版本運算子`&`和`|`運算子：

*  操作`x && y`對應至作業`x & y`，差異在於`y`才會求`x`不是`false`。
*  操作`x || y`對應至作業`x | y`，差異在於`y`才會求`x`不是`true`。

條件式邏輯運算子的運算元是否在編譯時期型別`dynamic`，然後動態地繫結運算式 ([動態繫結](expressions.md#dynamic-binding))。 運算式的編譯時期型別是在此情況下`dynamic`，如下所述的解析度會發生在執行階段使用這些已編譯時間類型的運算元的執行階段型別和`dynamic`。

表單的作業`x && y`或`x || y`處理藉由套用多載解析 ([二元運算子多載解析](expressions.md#binary-operator-overload-resolution))，如果作業寫入`x & y`或`x | y`。 然後，

*  如果多載解析失敗，若要尋找單一最佳的運算子，或如果多載解析會選取其中一個預先定義之的整數的邏輯運算子，就會發生繫結時間錯誤。
*  否則，如果選取的運算子是其中一個預先定義的布林邏輯運算子 ([布林值的邏輯運算子](expressions.md#boolean-logical-operators)) 或可為 null 的布林邏輯運算子 ([可為 Null 的布林邏輯運算子](expressions.md#nullable-boolean-logical-operators))，作業處理中所述[，則為 True 的條件式邏輯運算子](expressions.md#boolean-conditional-logical-operators)。
*  否則，所選的運算子是使用者定義的運算子，而且則會處理作業中所述[使用者定義的條件式邏輯運算子](expressions.md#user-defined-conditional-logical-operators)。

您不可能直接多載條件邏輯運算子。 但是，因為條件式邏輯運算子會評估規則的邏輯運算子方面，多載一般邏輯運算子，具有某些限制，也可以視為條件式邏輯運算子的多載。 這是更進一步的說明[使用者定義的條件式邏輯運算子](expressions.md#user-defined-conditional-logical-operators)。

### <a name="boolean-conditional-logical-operators"></a>布林值的條件式邏輯運算子

時的運算元`&&`或`||`的型別`bool`，或當運算元都是未定義在適用的型別`operator &`或`operator |`，但定義隱含地轉換成`bool`，作業處理方式，如下所示：

*  操作`x && y`評估為`x ? y : false`。 亦即`x`第一次評估，以及轉換成型別`bool`。 然後，如果`x`是`true`，`y`評估，以及轉換成型別`bool`，並成為運算的結果。 否則，作業的結果就是`false`。
*  操作`x || y`評估為`x ? true : y`。 亦即`x`第一次評估，以及轉換成型別`bool`。 然後，如果`x`是`true`，此作業的結果是`true`。 否則，請`y`評估，以及轉換成型別`bool`，並成為運算的結果。

### <a name="user-defined-conditional-logical-operators"></a>使用者定義的條件式邏輯運算子

當的運算元`&&`或`||`由宣告適用之型別的使用者定義`operator &`或`operator |`，這兩個項目必須為 true，其中`T`是在宣告選取的運算子的類型：

*  傳回的型別和所選運算子的每個參數的型別必須是`T`。 換句話說，操作員必須計算邏輯`AND`或邏輯`OR`兩個運算元的型別`T`，而且必須傳回類型之結果的`T`。
*  `T` 必須包含的宣告`operator true`和`operator false`。

如果不符合任一需求，就會發生的繫結階段錯誤。 否則，請`&&`或`||`作業會藉由結合使用者定義評估`operator true`或`operator false`與選取的使用者定義運算子：

*  作業`x && y`評估為`T.false(x) ? x : T.&(x, y)`，其中`T.false(x)`是的引動過程`operator false`中所宣告`T`，和`T.&(x, y)`是所選取的引動過程`operator &`。 也就是說，`x`就會先評估並`operator false`來判斷結果上叫用`x`是明確地 false。 然後，如果`x`明確地為 false，作業的結果就是先前計算的值是`x`。 否則`y`評估時，與所選取`operator &`先前的計算值上叫用`x`和用於計算的值`y`產生作業的結果。
*  作業`x || y`評估為`T.true(x) ? x : T.|(x, y)`，其中`T.true(x)`是的引動過程`operator true`中所宣告`T`，和`T.|(x,y)`是所選取的引動過程`operator|`。 換句話說，`x`就會先評估並`operator true`來判斷結果上叫用`x`為絕對，則為 true。 然後，如果`x`為絕對，則為 true，此作業的結果是先前的計算值`x`。 否則`y`評估時，與所選取`operator |`先前的計算值上叫用`x`和用於計算的值`y`產生作業的結果。

在這些作業時，所指定的運算式`x`是只評估一次，而所指定的運算式`y`無法評估或評估一次。

如需範例實作的型別`operator true`並`operator false`，請參閱[資料庫，則為 true 的型別](structs.md#database-boolean-type)。

## <a name="the-null-coalescing-operator"></a>Null 聯合運算子

`??`運算子稱為 null 聯合運算子。

```antlr
null_coalescing_expression
    : conditional_or_expression
    | conditional_or_expression '??' null_coalescing_expression
    ;
```

格式的 null 聯合運算式`a ?? b`需要`a`可為 null 的型別或參考類型。 如果`a`為非 null 的結果`a ?? b`是`a`; 否則結果是`b`。 此作業會評估`b`只有當`a`為 null。

Null 聯合運算子是右向關聯，表示由右至左的分組作業。 例如，以下格式的運算式`a ?? b ?? c`評估為`a ?? (b ?? c)`。 一般情況下搜尋文字格式的運算式`E1 ?? E2 ?? ... ?? En`會傳回運算元的第一個非 null，或如果所有運算元都是 null 時則為 null。

運算式的型別`a ?? b`取決於在運算元上可用的隱含轉換。 中依偏好程度的型別`a ?? b`是`A0`， `A`，或`B`，其中`A`是種`a`(前提是`a`具有型別)，`B`是種`b`(前提`b`具有型別)，並`A0`是基礎類型`A`如果`A`是可為 null 的型別，或`A`否則。 具體來說，`a ?? b`處理，如下所示：

*  如果`A`存在，而且不是 null 的型別或參考類型，就會發生編譯時期錯誤。
*  如果`b`是動態的運算式，結果型別是`dynamic`。 在執行階段`a`先進行評估。 如果`a`不是 null，`a`轉換為動態，並成為結果。 否則，`b`評估時，這就成為結果。
*  否則，如果`A`存在於可為 null 的型別且隱含的轉換`b`要`A0`，結果型別是`A0`。 在執行階段`a`先進行評估。 如果`a`不是 null，`a`會解除包裝以輸入`A0`，而這會成為結果。 否則，請`b`評估，以及轉換為類型`A0`，而這會變成結果。
*  否則，如果`A`存在且隱含的轉換從`b`要`A`，結果型別是`A`。 在執行階段`a`先進行評估。 如果`a`不是 null，`a`產生結果。 否則，請`b`評估，以及轉換為類型`A`，而這會變成結果。
*  否則，如果`b`具有型別的`B`且隱含的轉換從`a`要`B`，結果型別是`B`。 在執行階段`a`先進行評估。 如果`a`不是 null，`a`會解除包裝以輸入`A0`(如果`A`存在，而且可為 null) 和轉換成輸入`B`，而這會成為結果。 否則，`b`評估，並產生結果。
*  否則，請`a`和`b`不相容，以及編譯時期錯誤，就會發生。

## <a name="conditional-operator"></a>條件運算子

`?:`運算子稱為條件運算子。 它有時也稱為三元運算子。

```antlr
conditional_expression
    : null_coalescing_expression
    | null_coalescing_expression '?' expression ':' expression
    ;
```

條件運算式的形式`b ? x : y`條件會先評估`b`。 然後，如果`b`已`true`，`x`評估，並產生作業的結果。 否則，`y`評估，並產生作業的結果。 條件運算式永遠不會評估兩者`x`和`y`。

條件運算子是右向關聯，表示由右至左的分組作業。 例如，以下格式的運算式`a ? b : c ? d : e`評估為`a ? b : (c ? d : e)`。

第一個運算元`?:`運算子必須可以隱含地轉換成運算式`bool`，或實作型別的運算式`operator true`。 如果滿足這些需求都沒有，就會發生編譯時期錯誤。

第二個和第三個運算元`x`並`y`的`?:`運算子控制的條件運算式的類型。

*  如果`x`具有類型`X`並`y`具有類型`Y`然後
   * 如果隱含的轉換 ([隱含轉換](conversions.md#implicit-conversions)) 從`X`來`Y`，而不是從`Y`來`X`，然後`Y`是條件運算式的類型。
   * 如果隱含的轉換 ([隱含轉換](conversions.md#implicit-conversions)) 從`Y`來`X`，而不是從`X`來`Y`，然後`X`是條件運算式的類型。
   * 否則，可以判斷任何運算式類型，並就會發生編譯時期錯誤。
*  如果只有其中一個`x`及`y`具有一個型別，並同時`x`和`y`的會隱含地轉換成該類型，則這是條件式運算式的類型。
*  否則，可以判斷任何運算式類型，並就會發生編譯時期錯誤。

條件運算式的形式執行階段處理`b ? x : y`包含下列步驟：

*  第一次，`b`會評估，而`bool`的值`b`取決於：
   * 如果類型的隱含轉換`b`要`bool`存在，則會執行這項隱含轉換，來產生`bool`值。
   * 否則，請`operator true`的類型所定義`b`叫用以產生`bool`值。
*  如果`bool`上述步驟所產生的值是`true`，然後`x`評估，以及轉換類型的條件運算式中，這就成為條件式運算式的結果。
*  否則，`y`評估，以及轉換類型的條件運算式中，這就成為條件式運算式的結果。

## <a name="anonymous-function-expressions"></a>匿名函式運算式

***匿名函式***是代表"line"方法定義的運算式。 匿名函式沒有值或型別本身，但轉換成相容的委派或運算式樹狀結構類型。 匿名函式轉換的評估取決於轉換的目標類型：如果是委派類型，轉換就會評估委派值參考的匿名函式定義的方法。 如果運算式樹狀架構類型，轉換會評估為運算式樹狀架構表示的方法，做為物件結構的結構。

基於歷史原因有兩種語法匿名函式，也就是*lambda_expression*s 並*anonymous_method_expression*s。 幾乎所有基於*lambda_expression*會更簡潔易懂，比*anonymous_method_expression*s，保留的語言中回溯相容性。

```antlr
lambda_expression
    : anonymous_function_signature '=>' anonymous_function_body
    ;

anonymous_method_expression
    : 'delegate' explicit_anonymous_function_signature? block
    ;

anonymous_function_signature
    : explicit_anonymous_function_signature
    | implicit_anonymous_function_signature
    ;

explicit_anonymous_function_signature
    : '(' explicit_anonymous_function_parameter_list? ')'
    ;

explicit_anonymous_function_parameter_list
    : explicit_anonymous_function_parameter (',' explicit_anonymous_function_parameter)*
    ;

explicit_anonymous_function_parameter
    : anonymous_function_parameter_modifier? type identifier
    ;

anonymous_function_parameter_modifier
    : 'ref'
    | 'out'
    ;

implicit_anonymous_function_signature
    : '(' implicit_anonymous_function_parameter_list? ')'
    | implicit_anonymous_function_parameter
    ;

implicit_anonymous_function_parameter_list
    : implicit_anonymous_function_parameter (',' implicit_anonymous_function_parameter)*
    ;

implicit_anonymous_function_parameter
    : identifier
    ;

anonymous_function_body
    : expression
    | block
    ;
```

`=>`運算子具有相同的優先順序，與指派 (`=`) 和是右向關聯。

使用匿名函式`async`修飾詞是非同步函式，並且遵循規則中所述[迭代器](classes.md#iterators)。

匿名函式的形式的參數*lambda_expression*可以明確或隱含型別。 在明確類型的參數清單中，明確指定每個參數的型別。 隱含型別的參數清單中，參數型別會推斷的匿名函式發生的內容從 — 特別是，當匿名函式轉換成相容的委派型別或型別提供運算式樹狀架構類型參數類型 ([匿名函式轉換](conversions.md#anonymous-function-conversions))。

在匿名函式具有單一、 隱含型別參數，可能會從參數清單省略括弧。 換句話說，表單匿名函式
```csharp
( param ) => expr
```
可以縮寫成
```csharp
param => expr
```

參數清單的匿名函式的形式*anonymous_method_expression*是選擇性的。 如果指定的話，必須明確型別參數。 如果不是，匿名函式轉換成委派，以使用任何參數的清單，不包含`out`參數。

A*區塊*匿名函式的主體是連線到 ([結束點和可執行性](statements.md#end-points-and-reachability)) 除非匿名函式，就會發生無法到達陳述式。

匿名函式的一些範例，請遵循下列：

```csharp
x => x + 1                              // Implicitly typed, expression body
x => { return x + 1; }                  // Implicitly typed, statement body
(int x) => x + 1                        // Explicitly typed, expression body
(int x) => { return x + 1; }            // Explicitly typed, statement body
(x, y) => x * y                         // Multiple parameters
() => Console.WriteLine()               // No parameters
async (t1,t2) => await t1 + await t2    // Async
delegate (int x) { return x + 1; }      // Anonymous method expression
delegate { return 1 + 1; }              // Parameter list omitted
```

行為*lambda_expression*s 並*anonymous_method_expression*s 是除了下列幾點：

*  *anonymous_method_expression*s 允許參數清單，請完全省略產生可轉換成委派類型的任何值參數的清單。
*  *lambda_expression*s 允許省略和推斷而來的參數型別*anonymous_method_expression*s 需要明確指示的參數類型。
*  主體*lambda_expression*可以是運算式或陳述式區塊而主體*anonymous_method_expression*必須是陳述式區塊。
*  只有*lambda_expression*有相容的運算式樹狀架構類型的轉換 ([運算式樹狀架構類型](types.md#expression-tree-types))。

### <a name="anonymous-function-signatures"></a>匿名函式簽章

選擇性*anonymous_function_signature*匿名函式的定義名稱和選擇性的匿名函式的型式參數類型。 匿名函式參數的範圍是*anonymous_function_body*。 ([領域](basic-concepts.md#scopes)) 參數清單 （如果有） 以及匿名-方法-主體構成宣告空間 ([宣告](basic-concepts.md#declarations))。 因此是匿名函式，以符合本機變數、 區域常數或其範圍，包括的參數名稱的參數名稱的編譯時期錯誤*anonymous_method_expression*或*lambda_運算式*。

匿名函式是否*explicit_anonymous_function_signature*，則一組相容的委派型別和運算式樹狀架構類型僅限於具有相同參數類型和修飾詞會以相同的順序。 相較於方法群組轉換 ([方法群組轉換](conversions.md#method-group-conversions))，不支援 /yield 匿名函式參數類型。 如果匿名函式沒有*anonymous_function_signature*，則一組相容的委派型別和運算式樹狀架構類型僅限於那些沒有`out`參數。

請注意， *anonymous_function_signature*不能包含屬性或參數陣列。 不過， *anonymous_function_signature*可能相容的參數清單包含參數陣列的委派類型。

也請注意，轉換為運算式樹狀結構類型，即使相容，仍然可能會在編譯階段失敗 ([運算式樹狀架構類型](types.md#expression-tree-types))。

### <a name="anonymous-function-bodies"></a>匿名函式主體

主體 (*運算式*或是*區塊*) 的匿名函式會受限於下列規則：

*  如果匿名函式包含簽章，就有一個簽章中指定的參數可在本文中。 如果匿名函式沒有簽章可以轉換為委派型別或具有參數的運算式型別 ([匿名函式轉換](conversions.md#anonymous-function-conversions))，但無法存取參數，在主體中。
*  除了`ref`或是`out`參數的最內層的簽章 （如果有的話） 中指定匿名函式，它是主體存取的編譯時期錯誤`ref`或`out`參數。
*  當的型別`this`是結構類型時，它是主體存取的編譯時期錯誤`this`。 這是，則為 true 的存取是否明確 (依照`this.x`) 或隱含 (中`x`其中`x`是結構的執行個體成員)。 此規則只是禁止這類存取權，並不會影響成員查詢結果中的結構成員。
*  此主體可存取外部變數 ([外部變數](expressions.md#outer-variables)) 的匿名函式。 外部變數的存取會參考此變數會是作用中時的執行個體*lambda_expression*或是*anonymous_method_expression*評估 ([評估匿名函式運算式](expressions.md#evaluation-of-anonymous-function-expressions))。
*  本文包含的編譯時期錯誤就`goto`陳述式中，`break`陳述式，或`continue`其目標是主體之外，或包含匿名函式主體內的陳述式。
*  A`return`主體中的陳述式會傳回控制項從最接近的封閉式的引動過程不是來自封入函式成員的匿名函式。 中指定的運算式`return`陳述式必須是隱含地轉換成委派類型的運算式樹狀架構型別，要傳回的型別最接近的封閉式*lambda_expression*或*anonymous_method_expression*轉換 ([匿名函式轉換](conversions.md#anonymous-function-conversions))。

是否沒有任何方法可以執行而不透過評估和引動過程的匿名函式的區塊並未明確指定*lambda_expression*或*anonymous_method_expression*. 特別是，編譯器可能會選擇實作的匿名函式，藉由合成一或多個具名方法或類型。 保留供編譯器使用必須是格式的這類合成的項目的名稱。

### <a name="overload-resolution-and-anonymous-functions"></a>多載解析和匿名函式

匿名函式引數清單中的加入型別推斷和多載解析。 請參閱[型別推斷](expressions.md#type-inference)並[多載解析](expressions.md#overload-resolution)的確切規則。

下列範例說明多載解析匿名函式的影響。

```csharp
class ItemList<T>: List<T>
{
    public int Sum(Func<T,int> selector) {
        int sum = 0;
        foreach (T item in this) sum += selector(item);
        return sum;
    }

    public double Sum(Func<T,double> selector) {
        double sum = 0;
        foreach (T item in this) sum += selector(item);
        return sum;
    }
}
```

`ItemList<T>`類別有兩個`Sum`方法。 每個處理`selector`引數，從清單項目透過擷取值總和。 所擷取的值可以是`int`或是`double`與產生的加總同樣`int`或`double`。

`Sum`方法，例如可用來計算從清單中訂單的詳細資料行的總和。

```csharp
class Detail
{
    public int UnitCount;
    public double UnitPrice;
    ...
}

void ComputeSums() {
    ItemList<Detail> orderDetails = GetOrderDetails(...);
    int totalUnits = orderDetails.Sum(d => d.UnitCount);
    double orderTotal = orderDetails.Sum(d => d.UnitPrice * d.UnitCount);
    ...
}
```

中的第一個引動過程`orderDetails.Sum`，這兩個`Sum`方法都適用因為匿名函式`d => d. UnitCount`適用於兩者`Func<Detail,int>`和`Func<Detail,double>`。 不過，多載解析會挑選第一個`Sum`方法因為轉換成`Func<Detail,int>`優於轉換為`Func<Detail,double>`。

中的第二個引動過程`orderDetails.Sum`，而第二個`Sum`方法就適用因為匿名函式`d => d.UnitPrice * d.UnitCount`會產生型別的值`double`。 因此，多載解析會挑選第二個`Sum`方法的引動過程。

### <a name="anonymous-functions-and-dynamic-binding"></a>匿名函式和動態繫結

匿名函式不能是接收者、 引數或動態繫結作業的運算元。

### <a name="outer-variables"></a>外部變數

任何本機變數、 值參數或其範圍，包括參數陣列*lambda_expression*或是*anonymous_method_expression*稱為***外部變數***匿名函式。 在類別的執行個體函式成員`this`值會被視為實值參數，且任何包含在函式成員內的匿名函式的外部變數。

#### <a name="captured-outer-variables"></a>擷取外部變數

當外部變數的匿名函式所參考時，即稱為外部變數已被***擷取***匿名函式。 一般情況下，本機變數的存留期間受限於區塊或陳述式與它相關聯的執行 ([區域變數](variables.md#local-variables))。 不過，擷取的外部變數的存留期至少延長到委派，或從匿名函式建立的運算式樹狀架構就適合進行記憶體回收。

在範例
```csharp
using System;

delegate int D();

class Test
{
    static D F() {
        int x = 0;
        D result = () => ++x;
        return result;
    }

    static void Main() {
        D d = F();
        Console.WriteLine(d());
        Console.WriteLine(d());
        Console.WriteLine(d());
    }
}
```
區域變數`x`擷取匿名函式，及其的存留期`x`至少會延伸到傳回的委派之前`F`就適合進行記憶體回收 （不會發生的最尾端之前程式）。 因為相同的執行個體上運作的匿名函式每次叫用`x`，此範例的輸出：
```
1
2
3
```

當匿名函式擷取的本機變數或值參數時，本機變數或參數不再被視為是固定的變數 ([固定和可移動變數](unsafe-code.md#fixed-and-moveable-variables))，但會被視為是 moveable變數。 因此，任何`unsafe`程式碼會擷取外部變數的位址，必須先使用`fixed`修正變數的陳述式。

請注意，不同於 uncaptured 的變數，擷取本機變數可以同時公開至執行多個執行緒。

#### <a name="instantiation-of-local-variables"></a>具現化的本機變數

本機變數會被視為***具現化***執行時進入變數的範圍。 例如，下列方法叫用時，本機變數`x`是具現化並初始化三次，一次迴圈的每個反覆項目。

```csharp
static void F() {
    for (int i = 0; i < 3; i++) {
        int x = i * 2 + 1;
        ...
    }
}
```

不過，移動的宣告`x`之外的單一具現化的迴圈導致`x`:
```csharp
static void F() {
    int x;
    for (int i = 0; i < 3; i++) {
        x = i * 2 + 1;
        ...
    }
}
```

不擷取，就無法觀察區域變數具現化的方式通常 — 因為具現化的存留期是否不相交，就可以為每個具現化，只要使用相同的儲存位置。 不過，當匿名函式擷取區域變數，具現化的效果會變得明顯。

此範例
```csharp
using System;

delegate void D();

class Test
{
    static D[] F() {
        D[] result = new D[3];
        for (int i = 0; i < 3; i++) {
            int x = i * 2 + 1;
            result[i] = () => { Console.WriteLine(x); };
        }
        return result;
    }

    static void Main() {
        foreach (D d in F()) d();
    }
}
```
產生下列輸出：
```
1
3
5
```

不過，當宣告`x`移到迴圈外：
```csharp
static D[] F() {
    D[] result = new D[3];
    int x;
    for (int i = 0; i < 3; i++) {
        x = i * 2 + 1;
        result[i] = () => { Console.WriteLine(x); };
    }
    return result;
}
```
輸出為：
```
5
5
5
```

如果 for 迴圈中宣告的反覆項目變數，該變數本身視為在迴圈外宣告。 因此，如果此範例會變更為擷取反覆項目變數本身：

```csharp
static D[] F() {
    D[] result = new D[3];
    for (int i = 0; i < 3; i++) {
        result[i] = () => { Console.WriteLine(i); };
    }
    return result;
}
```
已擷取的反覆運算變數只有一個執行個體，產生下列輸出：
```
3
3
3
```

您有要分享一些擷取的變數，但有不同的執行個體的其他人的匿名函式委派。 例如，如果`F`變更為
```csharp
static D[] F() {
    D[] result = new D[3];
    int x = 0;
    for (int i = 0; i < 3; i++) {
        int y = 0;
        result[i] = () => { Console.WriteLine("{0} {1}", ++x, ++y); };
    }
    return result;
}
```
三個委派擷取相同的執行個體`x`但不同的執行個體`y`，輸出則：
```
1 1
2 1
3 1
```

個別的匿名函式可以擷取相同的執行個體的外部變數。 在下列範例中：
```csharp
using System;

delegate void Setter(int value);

delegate int Getter();

class Test
{
    static void Main() {
        int x = 0;
        Setter s = (int value) => { x = value; };
        Getter g = () => { return x; };
        s(5);
        Console.WriteLine(g());
        s(10);
        Console.WriteLine(g());
    }
}
```
兩個的匿名函式擷取相同的執行個體的本機變數`x`，以及他們可以因此 「 通訊 」 透過該變數。 此範例的輸出為：
```
5
10
```

### <a name="evaluation-of-anonymous-function-expressions"></a>匿名函式運算式的評估

匿名函式`F`永遠必須轉換成委派類型`D`或運算式樹狀架構型別`E`，直接或透過委派建立運算式執行`new D(F)`。 這項轉換會決定的匿名函式結果中所述[匿名函式轉換](conversions.md#anonymous-function-conversions)。

## <a name="query-expressions"></a>查詢運算式

***查詢運算式***提供語言整合式的語法類似於關聯式和階層式查詢的語言，例如 SQL 和 XQuery 的查詢。

```antlr
query_expression
    : from_clause query_body
    ;

from_clause
    : 'from' type? identifier 'in' expression
    ;

query_body
    : query_body_clauses? select_or_group_clause query_continuation?
    ;

query_body_clauses
    : query_body_clause
    | query_body_clauses query_body_clause
    ;

query_body_clause
    : from_clause
    | let_clause
    | where_clause
    | join_clause
    | join_into_clause
    | orderby_clause
    ;

let_clause
    : 'let' identifier '=' expression
    ;

where_clause
    : 'where' boolean_expression
    ;

join_clause
    : 'join' type? identifier 'in' expression 'on' expression 'equals' expression
    ;

join_into_clause
    : 'join' type? identifier 'in' expression 'on' expression 'equals' expression 'into' identifier
    ;

orderby_clause
    : 'orderby' orderings
    ;

orderings
    : ordering (',' ordering)*
    ;

ordering
    : expression ordering_direction?
    ;

ordering_direction
    : 'ascending'
    | 'descending'
    ;

select_or_group_clause
    : select_clause
    | group_clause
    ;

select_clause
    : 'select' expression
    ;

group_clause
    : 'group' expression 'by' expression
    ;

query_continuation
    : 'into' identifier query_body
    ;
```

查詢運算式的開頭`from`子句和以結束`select`或`group`子句。 初始`from`子句後面可以接著零或多個`from`， `let`， `where`，`join`或`orderby`子句。 每個`from`子句是產生器簡介***範圍變數***範圍中的項目***順序***。 每個`let`子句會導入代表值，計算透過前一個範圍變數的範圍變數。 每個`where`子句是篩選器，從結果排除項目。 每個`join`子句將比較指定的索引鍵的來源序列的其他順序，產生符合的配對的索引鍵。 每個`orderby`子句重新排列項目，根據指定的準則。最終`select`或`group`子句指定結果的範圍變數的形狀。 最後，`into`子句可以用來 「 接合 」 查詢，藉由將一個查詢的結果為在後續查詢產生器。

### <a name="ambiguities-in-query-expressions"></a>查詢運算式中的模稜兩可

查詢運算式包含 「 內容關鍵字 」，亦即，給定的內容中具有特殊意義的識別項數目。 特別是這些`from`， `where`， `join`， `on`， `equals`， `into`， `let`， `orderby`， `ascending`， `descending`， `select`，`group`和`by`. 為了避免因混合使用這些識別碼，作為關鍵字或簡單名稱的查詢運算式中的模稜兩可，這些識別項都會被視為關鍵字的查詢運算式中發生的任何位置。

基於此目的，查詢運算式是以開頭的任何運算式 」`from identifier`"後面接著以外的任何權杖 」`;`"，"`=`「 或 」`,`"。

若要使用這些字做為查詢運算式中的識別項，它們可以在前面加上"`@`」 ([識別碼](lexical-structure.md#identifiers))。

### <a name="query-expression-translation"></a>查詢運算式轉譯

C# 語言不會指定查詢運算式的執行語意。 相反地，查詢運算式會轉譯成符合方法的引動過程*查詢運算式模式*([查詢運算式模式](expressions.md#the-query-expression-pattern))。 具體而言，查詢運算式會轉譯成方法，名稱為叫用`Where`， `Select`， `SelectMany`， `Join`， `GroupJoin`， `OrderBy`， `OrderByDescending`， `ThenBy`， `ThenByDescending`， `GroupBy`，和`Cast`。這些方法都應該有特定的簽章和結果的型別中所述[查詢運算式模式](expressions.md#the-query-expression-pattern)。 這些方法可以是所查詢之物件的執行個體方法或擴充方法外部物件，並在實作查詢的實際執行。

從查詢運算式轉譯為方法引動過程語法的對應，就會發生任何型別繫結之前或執行多載解析。 轉譯可以保證語法正確，但它不會保證能夠產生語意正確的 C# 程式碼。 查詢運算式的轉譯，產生的方法引動過程處理為一般方法引動過程，而這又可能會發現錯誤，例如，如果方法不存在，如果引數有錯誤的類型，或如果方法是泛型和型別推斷失敗。

查詢運算式是由重複套用下列的翻譯之前可能不會有任何進一步簡化, 處理。 轉譯會依照順序的應用程式： 每個區段假設已徹底，執行上述章節中的翻譯，且之後用完，區段會不稍後可再次回到相同的查詢運算式的處理中。

查詢運算式中不允許指派給範圍變數。 不過 C# 實作允許不一定強制執行這項限制，因為這有時不可能與此處所提供的語法轉譯配置。

特定翻譯插入且透明的識別項所表示的範圍變數`*`。 透明識別項的特殊屬性會討論中進一步[透明識別項](expressions.md#transparent-identifiers)。

#### <a name="select-and-groupby-clauses-with-continuations"></a>接續的定序的選取和 groupby 子句

查詢運算式與接續
```csharp
from ... into x ...
```
轉譯成
```csharp
from x in ( from ... ) ...
```

下列各節中的轉譯會假設查詢沒有任何`into`接續。

此範例
```csharp
from c in customers
group c by c.Country into g
select new { Country = g.Key, CustCount = g.Count() }
```
轉譯成
```csharp
from g in
    from c in customers
    group c by c.Country
select new { Country = g.Key, CustCount = g.Count() }
```
最終的翻譯
```csharp
customers.
GroupBy(c => c.Country).
Select(g => new { Country = g.Key, CustCount = g.Count() })
```

#### <a name="explicit-range-variable-types"></a>明確的範圍變數型別

A`from`子句來明確指定範圍變數的類型
```csharp
from T x in e
```
轉譯成
```csharp
from x in ( e ) . Cast < T > ( )
```

A`join`子句來明確指定範圍變數的類型
```
join T x in e on k1 equals k2
```
轉譯成
```
join x in ( e ) . Cast < T > ( ) on k1 equals k2
```

下列各節中的轉譯會假設查詢有沒有明確的範圍變數的型別。

此範例
```csharp
from Customer c in customers
where c.City == "London"
select c
```
轉譯成
```csharp
from c in customers.Cast<Customer>()
where c.City == "London"
select c
```
最終的翻譯
```csharp
customers.
Cast<Customer>().
Where(c => c.City == "London")
```

明確的範圍變數型別可用於查詢實作非泛型集合`IEnumerable`介面，但不是泛型`IEnumerable<T>`介面。 在上述範例中，這會是則`customers`類型的`ArrayList`。

#### <a name="degenerate-query-expressions"></a>變質的查詢運算式

格式的查詢運算式
```csharp
from x in e select x
```
轉譯成
```csharp
( e ) . Select ( x => x )
```

此範例
```csharp
from c in customers
select c
```
轉譯成
```csharp
customers.Select(c => c)
```

變質的查詢運算式是來源的透過極簡方式選取項目。 翻譯的後期移除變質導入由其他轉譯工作順序步驟，取代為其來源的查詢。 務必以確保查詢的結果運算式絕不會是來源物件本身，不過，會顯示類型和來源的身分識別給用戶端的查詢。 因此這個步驟可保護撰寫直接在原始程式碼中明確呼叫的變質查詢`Select`來源上的資料。 然後是由實作者的`Select`和其他查詢運算子，以確保這些方法會永遠不會傳回本身的來源物件。

#### <a name="from-let-where-join-and-orderby-clauses"></a>From、 let、 where、 聯結和 orderby 子句

第二個查詢運算式`from`子句後面`select`子句
```csharp
from x1 in e1
from x2 in e2
select v
```
轉譯成
```csharp
( e1 ) . SelectMany( x1 => e2 , ( x1 , x2 ) => v )
```

第二個查詢運算式`from`子句後面的項目以外的其他`select`子句：

```csharp
from x1 in e1
from x2 in e2
...
```
轉譯成
```csharp
from * in ( e1 ) . SelectMany( x1 => e2 , ( x1 , x2 ) => new { x1 , x2 } )
...
```

使用查詢運算式`let`子句
```csharp
from x in e
let y = f
...
```
轉譯成
```csharp
from * in ( e ) . Select ( x => new { x , y = f } )
...
```

使用查詢運算式`where`子句
```csharp
from x in e
where f
...
```
轉譯成
```csharp
from x in ( e ) . Where ( x => f )
...
```

使用查詢運算式`join`子句但不含`into`後面`select`子句
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2
select v
```
轉譯成
```csharp
( e1 ) . Join( e2 , x1 => k1 , x2 => k2 , ( x1 , x2 ) => v )
```

使用查詢運算式`join`子句但不含`into`後面的項目以外的其他`select`子句
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2
...
```
轉譯成
```csharp
from * in ( e1 ) . Join( e2 , x1 => k1 , x2 => k2 , ( x1 , x2 ) => new { x1 , x2 })
...
```

使用查詢運算式`join`子句`into`後面`select`子句
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2 into g
select v
```
轉譯成
```csharp
( e1 ) . GroupJoin( e2 , x1 => k1 , x2 => k2 , ( x1 , g ) => v )
```

使用查詢運算式`join`子句`into`後面的項目以外的其他`select`子句
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2 into g
...
```
轉譯成
```csharp
from * in ( e1 ) . GroupJoin( e2 , x1 => k1 , x2 => k2 , ( x1 , g ) => new { x1 , g })
...
```

使用查詢運算式`orderby`子句
```csharp
from x in e
orderby k1 , k2 , ..., kn
...
```
轉譯成
```csharp
from x in ( e ) . 
OrderBy ( x => k1 ) . 
ThenBy ( x => k2 ) .
... .
ThenBy ( x => kn )
...
```

如果排序子句會指定`descending`方向指標、 的引動過程`OrderByDescending`或`ThenByDescending`而產生。

下列轉譯是假設沒有任何`let`， `where`，`join`或`orderby`子句，而且不超過一個初始`from`中每個查詢運算式子句。

此範例
```csharp
from c in customers
from o in c.Orders
select new { c.Name, o.OrderID, o.Total }
```
轉譯成
```csharp
customers.
SelectMany(c => c.Orders,
     (c,o) => new { c.Name, o.OrderID, o.Total }
)
```

此範例
```csharp
from c in customers
from o in c.Orders
orderby o.Total descending
select new { c.Name, o.OrderID, o.Total }
```
轉譯成
```csharp
from * in customers.
    SelectMany(c => c.Orders, (c,o) => new { c, o })
orderby o.Total descending
select new { c.Name, o.OrderID, o.Total }
```
最終的翻譯
```csharp
customers.
SelectMany(c => c.Orders, (c,o) => new { c, o }).
OrderByDescending(x => x.o.Total).
Select(x => new { x.c.Name, x.o.OrderID, x.o.Total })
```
其中`x`是編譯器產生識別碼，否則是不可見的且無法存取。

此範例
```csharp
from o in orders
let t = o.Details.Sum(d => d.UnitPrice * d.Quantity)
where t >= 1000
select new { o.OrderID, Total = t }
```
轉譯成
```csharp
from * in orders.
    Select(o => new { o, t = o.Details.Sum(d => d.UnitPrice * d.Quantity) })
where t >= 1000 
select new { o.OrderID, Total = t }
```
最終的翻譯
```csharp
orders.
Select(o => new { o, t = o.Details.Sum(d => d.UnitPrice * d.Quantity) }).
Where(x => x.t >= 1000).
Select(x => new { x.o.OrderID, Total = x.t })
```
其中`x`是編譯器產生識別碼，否則是不可見的且無法存取。

此範例
```csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID
select new { c.Name, o.OrderDate, o.Total }
```
轉譯成
```csharp
customers.Join(orders, c => c.CustomerID, o => o.CustomerID,
    (c, o) => new { c.Name, o.OrderDate, o.Total })
```

此範例
```csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID into co
let n = co.Count()
where n >= 10
select new { c.Name, OrderCount = n }
```
轉譯成
```csharp
from * in customers.
    GroupJoin(orders, c => c.CustomerID, o => o.CustomerID,
        (c, co) => new { c, co })
let n = co.Count()
where n >= 10 
select new { c.Name, OrderCount = n }
```
最終的翻譯
```csharp
customers.
GroupJoin(orders, c => c.CustomerID, o => o.CustomerID,
    (c, co) => new { c, co }).
Select(x => new { x, n = x.co.Count() }).
Where(y => y.n >= 10).
Select(y => new { y.x.c.Name, OrderCount = y.n)
```
何處`x`和`y`是編譯器產生的識別項，否則為不可見的且無法存取。

此範例
```csharp
from o in orders
orderby o.Customer.Name, o.Total descending
select o
```
具有最終轉譯
```csharp
orders.
OrderBy(o => o.Customer.Name).
ThenByDescending(o => o.Total)
```

#### <a name="select-clauses"></a>Select 子句

格式的查詢運算式
```csharp
from x in e select v
```
轉譯成
```csharp
( e ) . Select ( x => v )
```
除了當 v 是識別項 x，轉譯就是
```csharp
( e )
```

例如
```csharp
from c in customers.Where(c => c.City == "London")
select c
```
只會轉譯成
```csharp
customers.Where(c => c.City == "London")
```

#### <a name="groupby-clauses"></a>Groupby 子句

格式的查詢運算式
```csharp
from x in e group v by k
```
轉譯成
```csharp
( e ) . GroupBy ( x => k , x => v )
```
除了當 v 是識別項 x，翻譯就是
```csharp
( e ) . GroupBy ( x => k )
```

此範例
```csharp
from c in customers
group c.Name by c.Country
```
轉譯成
```csharp
customers.
GroupBy(c => c.Country, c => c.Name)
```

#### <a name="transparent-identifiers"></a>透明識別項

特定翻譯插入具有範圍變數***透明識別項***所表示`*`。 透明識別項而不是適當的語言功能;它們只能以查詢運算式轉譯程序的中繼步驟形式存在。

當查詢轉譯會插入透明的識別碼時，進一步翻譯步驟將傳播透明的識別項到匿名函式和匿名物件初始設定式。 在這些內容中，透明識別項會有下列行為：

*  當做匿名函式中的參數是透明的識別項時，相關聯的匿名型別的成員會自動在範圍內的匿名函式主體中。
*  在範圍內的成員具有透明的識別碼時，該成員的成員是在範圍內以及。
*  為匿名物件初始設定式中的成員宣告子是透明的識別項時，它引入了具有透明識別項的成員。
*  在上面所述的轉換步驟，透明的識別碼會永遠引進了以及匿名型別，目的是擷取多個範圍變數做為單一物件的成員。 允許使用不同的機制，比匿名型別群組在一起的多個範圍變數的 C# 實作。 下列的轉譯範例假設使用時，匿名型別，以及顯示如何透明識別項可以立即轉譯。

此範例
```csharp
from c in customers
from o in c.Orders
orderby o.Total descending
select new { c.Name, o.Total }
```
轉譯成
```csharp
from * in customers.
    SelectMany(c => c.Orders, (c,o) => new { c, o })
orderby o.Total descending
select new { c.Name, o.Total }
```

然後再轉譯成
```csharp
customers.
SelectMany(c => c.Orders, (c,o) => new { c, o }).
OrderByDescending(* => o.Total).
Select(* => new { c.Name, o.Total })
```
當透明的識別碼就會清除，相當於
```csharp
customers.
SelectMany(c => c.Orders, (c,o) => new { c, o }).
OrderByDescending(x => x.o.Total).
Select(x => new { x.c.Name, x.o.Total })
```
其中`x`是編譯器產生識別碼，否則是不可見的且無法存取。

此範例
```csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID
join d in details on o.OrderID equals d.OrderID
join p in products on d.ProductID equals p.ProductID
select new { c.Name, o.OrderDate, p.ProductName }
```
轉譯成
```csharp
from * in customers.
    Join(orders, c => c.CustomerID, o => o.CustomerID, 
        (c, o) => new { c, o })
join d in details on o.OrderID equals d.OrderID
join p in products on d.ProductID equals p.ProductID
select new { c.Name, o.OrderDate, p.ProductName }
```
這會進一步縮減為
```csharp
customers.
Join(orders, c => c.CustomerID, o => o.CustomerID, (c, o) => new { c, o }).
Join(details, * => o.OrderID, d => d.OrderID, (*, d) => new { *, d }).
Join(products, * => d.ProductID, p => p.ProductID, (*, p) => new { *, p }).
Select(* => new { c.Name, o.OrderDate, p.ProductName })
```
最終的翻譯
```csharp
customers.
Join(orders, c => c.CustomerID, o => o.CustomerID,
    (c, o) => new { c, o }).
Join(details, x => x.o.OrderID, d => d.OrderID,
    (x, d) => new { x, d }).
Join(products, y => y.d.ProductID, p => p.ProductID,
    (y, p) => new { y, p }).
Select(z => new { z.y.x.c.Name, z.y.x.o.OrderDate, z.p.ProductName })
```
何處`x`， `y`，和`z`是編譯器產生的識別項，否則為不可見的且無法存取。

### <a name="the-query-expression-pattern"></a>查詢運算式模式

***查詢運算式模式***建立模式的類型可以實作以支援查詢運算式的方法。 查詢運算式會轉譯為方法引動過程中，透過語法的對應，因為類型會有極大的彈性，在實作查詢運算式模式的方式。 比方說，模式的方法可實作為執行個體方法或擴充方法因為這兩個具有相同的引動過程語法中，而且方法可以要求委派或運算式樹狀架構，因為匿名函式會轉換成這兩者。

泛型類型的建議的圖形`C<T>`，支援的查詢運算式模式如下所示。 泛型型別用來說明之間參數和結果的型別，適當的關聯性，但可以實作非泛型型別模式。

```csharp
delegate R Func<T1,R>(T1 arg1);

delegate R Func<T1,T2,R>(T1 arg1, T2 arg2);

class C
{
    public C<T> Cast<T>();
}

class C<T> : C
{
    public C<T> Where(Func<T,bool> predicate);

    public C<U> Select<U>(Func<T,U> selector);

    public C<V> SelectMany<U,V>(Func<T,C<U>> selector,
        Func<T,U,V> resultSelector);

    public C<V> Join<U,K,V>(C<U> inner, Func<T,K> outerKeySelector,
        Func<U,K> innerKeySelector, Func<T,U,V> resultSelector);

    public C<V> GroupJoin<U,K,V>(C<U> inner, Func<T,K> outerKeySelector,
        Func<U,K> innerKeySelector, Func<T,C<U>,V> resultSelector);

    public O<T> OrderBy<K>(Func<T,K> keySelector);

    public O<T> OrderByDescending<K>(Func<T,K> keySelector);

    public C<G<K,T>> GroupBy<K>(Func<T,K> keySelector);

    public C<G<K,E>> GroupBy<K,E>(Func<T,K> keySelector,
        Func<T,E> elementSelector);
}

class O<T> : C<T>
{
    public O<T> ThenBy<K>(Func<T,K> keySelector);

    public O<T> ThenByDescending<K>(Func<T,K> keySelector);
}

class G<K,T> : C<T>
{
    public K Key { get; }
}
```

上述方法使用泛型委派類型`Func<T1,R>`和`Func<T1,T2,R>`，但它們可能也同樣使用過其他委派或運算式樹狀架構型別參數和結果的類型中相同的關聯性。

請注意建議的關聯性之間`C<T>`和`O<T>`可確保`ThenBy`和`ThenByDescending`方法都只位於結果`OrderBy`或`OrderByDescending`。 也請注意結果的建議的圖形`GroupBy`-一連串的序列，其中每個內部序列都有額外`Key`屬性。

`System.Linq`命名空間會實作任何類型提供的查詢運算子的模式實作`System.Collections.Generic.IEnumerable<T>`介面。

## <a name="assignment-operators"></a>指派運算子

指派運算子會將新的值指派給變數、 屬性、 事件或索引子項目。

```antlr
assignment
    : unary_expression assignment_operator expression
    ;

assignment_operator
    : '='
    | '+='
    | '-='
    | '*='
    | '/='
    | '%='
    | '&='
    | '|='
    | '^='
    | '<<='
    | right_shift_assignment
    ;
```

指派的左的運算元必須是運算式分類為變數、 屬性存取、 索引子存取或事件存取。

`=`呼叫運算子***簡單指派運算子***。 它會將右運算元的值指派給左運算元所指定的變數、 屬性或索引子的項目中。 簡單指派運算子的左的運算元可能無法存取事件 (除了中所述[欄位型事件](classes.md#field-like-events))。 簡單指派運算子所述[簡單指派](expressions.md#simple-assignment)。

指派運算子以外`=`運算子會呼叫***複合指派運算子***。 這些運算子會執行兩個運算元中，指定的作業，並再將產生的值指派給左運算元所指定的變數、 屬性或索引子的項目。 複合指派運算子所述[複合指派](expressions.md#compound-assignment)。

`+=`並`-=`事件存取運算式為左運算元的運算子都稱為*事件指派運算子*。 沒有其他的指派運算子是與事件存取有效的做為左運算元。 事件指派運算子所述[事件指派](expressions.md#event-assignment)。

指派運算子是右向關聯，表示由右至左的分組作業。 例如，以下格式的運算式`a = b = c`評估為`a = (b = c)`。

### <a name="simple-assignment"></a>單一指派

`=`運算子稱為簡單指派運算子。

簡單指派的左的運算元是否屬於表單`E.P`或`E[Ei]`其中`E`已編譯時期型別`dynamic`，然後指派動態繫結 ([動態繫結](expressions.md#dynamic-binding))。 在此案例是指派運算式的編譯時期型別`dynamic`，並如下所述的解析度會在執行階段根據執行階段類型的進行`E`。

在簡單的指派，右運算元必須隱含轉換為左運算元的類型的運算式。 作業會將右運算元的值指派給左運算元所指定的變數、 屬性或索引子的項目。

簡單指派運算式的結果會指派給左運算元的值。 結果會具有左運算元相同的型別，而且一律會分類為值。

如果左的運算元是屬性或索引子的存取，必須有屬性或索引子`set`存取子。 如果這不是這樣，繫結階段會發生錯誤。

執行階段處理表單的簡單指派`x = y`包含下列步驟：

*  如果`x`分類為變數：
   * `x` 在評估後產生的變數。
   * `y` 是評估後，如有需要，轉換成的型別`x`透過隱含的轉換 ([隱含轉換](conversions.md#implicit-conversions))。
   * 如果所指定變數`x`是陣列項目*reference_type*，則執行階段會檢查以確保針對計算的值`y`適用於陣列執行個體，其中`x`是項目。 檢查成功，如果`y`已`null`，或如果隱含參考轉換 ([隱含參考轉換](conversions.md#implicit-reference-conversions)) 執行個體所參考的實際型別`y`實際的項目型別陣列執行個體，包含`x`。 否則會擲回 `System.ArrayTypeMismatchException`。
   * 評估和轉換所產生的值`y`的評估所指定的位置儲存`x`。
*  如果`x`歸類為屬性或索引子的存取：
   * 執行個體運算式 (如果`x`不是`static`) 和引數清單 (如果`x`是索引子存取) 相關聯`x`會進行評估，而且結果會用於後續`set`存取子引動過程。
   * `y` 是評估後，如有需要，轉換成的型別`x`透過隱含的轉換 ([隱含轉換](conversions.md#implicit-conversions))。
   * `set`存取子`x`叫用的計算值`y`做為其`value`引數。

陣列共同變異數規則 ([陣列共變數](arrays.md#array-covariance)) 允許值的陣列型別`A[]`是陣列型別的執行個體的參考`B[]`，前提是隱含參考轉換存在從`B`至`A`. 因為這些規則中，指派的陣列項目的*reference_type*需要執行階段檢查，以確保相容於陣列執行個體被指派的值。 在範例
```csharp
string[] sa = new string[10];
object[] oa = sa;

oa[0] = null;               // Ok
oa[1] = "Hello";            // Ok
oa[2] = new ArrayList();    // ArrayTypeMismatchException
```
過去的指派會導致`System.ArrayTypeMismatchException`因為擲回的執行個體`ArrayList`中的項目無法儲存`string[]`。

當屬性或索引子宣告中*struct_type*指派的目標，執行個體運算式相關聯的屬性或索引子存取必須分類為變數。 如果執行個體運算式分類為值，繫結階段會發生錯誤。 由於[成員存取](expressions.md#member-access)，相同的規則也套用至欄位。

宣告為例：
```csharp
struct Point
{
    int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int X {
        get { return x; }
        set { x = value; }
    }

    public int Y {
        get { return y; }
        set { y = value; }
    }
}

struct Rectangle
{
    Point a, b;

    public Rectangle(Point a, Point b) {
        this.a = a;
        this.b = b;
    }

    public Point A {
        get { return a; }
        set { a = value; }
    }

    public Point B {
        get { return b; }
        set { b = value; }
    }
}
```
在範例
```csharp
Point p = new Point();
p.X = 100;
p.Y = 100;
Rectangle r = new Rectangle();
r.A = new Point(10, 10);
r.B = p;
```
若要指派`p.X`， `p.Y`， `r.A`，以及`r.B`已允許，因為`p`和`r`是變數。 不過，在此範例
```csharp
Rectangle r = new Rectangle();
r.A.X = 10;
r.A.Y = 10;
r.B.X = 100;
r.B.Y = 100;
```
指派的設定全部無效，因為`r.A`和`r.B`並不是變數。

### <a name="compound-assignment"></a>複合指派

複合指派的左的運算元是否屬於表單`E.P`或`E[Ei]`其中`E`已編譯時期型別`dynamic`，然後指派動態繫結 ([動態繫結](expressions.md#dynamic-binding))。 在此案例是指派運算式的編譯時期型別`dynamic`，並如下所述的解析度會在執行階段根據執行階段類型的進行`E`。

表單的作業`x op= y`處理所套用的二元運算子多載解析 ([二元運算子多載解析](expressions.md#binary-operator-overload-resolution))，如果作業寫入`x op y`。 然後，

*  如果選取之運算子的傳回型別是隱含地轉換成的型別`x`，作業評估為`x = x op y`，差異在於`x`只評估一次。
*  否則，如果選取的運算子是一個預先定義的運算子，明確地轉換成的型別所選運算子的傳回型別是否`x`，而且如果`y`隱含地轉換成的型別`x`或操作員移位運算子，則作業會評估為`x = (T)(x op y)`，其中`T`是種`x`，只不過`x`只評估一次。
*  否則，複合指派無效，並在繫結階段錯誤發生。

「 只評估一次 」 一詞是指，在評估的`x op y`，任何構成運算式中的結果`x`會暫時儲存並重複使用時執行指派給`x`。 比方說，在 [指派] `A()[B()] += C()`，其中`A`是方法，傳回`int[]`，和`B`並`C`方法傳回`int`，在順序中的 「 方法叫用一次， `A`，`B`, `C`.

複合指派的左的運算元是存取屬性或索引子存取，當屬性或索引子必須兩者`get`存取子和`set`存取子。 如果這不是這樣，繫結階段會發生錯誤。

第二項規則允許上述`x op= y`評估為`x = (T)(x op y)`在特定內容中。 預先定義的運算子可用來當做複合運算子的左的運算元的類型時，有規則`sbyte`， `byte`， `short`， `ushort`，或`char`。 即使兩個引數的其中一種類型，預先定義的運算子會產生類型的結果`int`中所述[二進位數字提升](expressions.md#binary-numeric-promotions)。 因此，未使用轉型其就無法將結果指派給左運算元。

預先定義的運算子規則的直覺式作用在於只要`x op= y`如果兩個允許的`x op y`和`x = y`允許。 在範例
```csharp
byte b = 0;
char ch = '\0';
int i = 0;

b += 1;             // Ok
b += 1000;          // Error, b = 1000 not permitted
b += i;             // Error, b = i not permitted
b += (byte)i;       // Ok

ch += 1;            // Error, ch = 1 not permitted
ch += (char)1;      // Ok
```
針對每個錯誤的直覺化的原因是，對應的簡單指派也會發生錯誤。

這也表示複合指派作業支援提昇的作業。 在範例
```csharp
int? i = 0;
i += 1;             // Ok
```
提昇的運算子`+(int?,int?)`用。

### <a name="event-assignment"></a>事件指派

如果左的運算元`+=`或`-=`運算子會分類為事件的存取，則運算式會評估，如下所示：

*  執行個體，如果有的話，事件存取會評估運算式。
*  右運算元`+=`或是`-=`運算子，評估，再，如有需要，轉換成透過隱含的轉換的左運算元的類型 ([隱含轉換](conversions.md#implicit-conversions))。
*  叫用事件的事件存取子時，具有組成的右運算元，評估後的引數清單，並視需要轉換。 如果運算子`+=`，則`add`存取子會叫用; 如果運算子`-=`，則`remove`存取子會叫用。

事件指派運算式不會產生值。 因此，事件指派運算式是有效的內容中，只有*statement_expression* ([運算式陳述式](statements.md#expression-statements))。

## <a name="expression"></a>運算式

*運算式*是*non_assignment_expression*或是*指派*。

```antlr
expression
    : non_assignment_expression
    | assignment
    ;

non_assignment_expression
    : conditional_expression
    | lambda_expression
    | query_expression
    ;
```

## <a name="constant-expressions"></a>常數運算式

A *constant_expression*是可以在編譯時期完整評估的運算式。

```antlr
constant_expression
    : expression
    ;
```

必須是常數運算式`null`常值或具有下列一種類型的值： `sbyte`， `byte`， `short`， `ushort`， `int`， `uint`， `long`， `ulong`， `char``float`， `double`， `decimal`， `bool`， `object`， `string`，或任何列舉類型。 在常數運算式中允許下列建構：

*  常值 (包括`null`常值)。
*  若要參考`const`類別和結構類型的成員。
*  列舉型別之成員的參考。
*  若要參考`const`參數或區域變數
*  括號括住的子運算式，也就是本身為常數運算式。
*  轉型運算式，提供目標型別是上面所列類型之一。
*  `checked` 和`unchecked`運算式
*  預設值運算式
*  Nameof 運算式
*  預先定義`+`， `-`， `!`，和`~`一元運算子。
*  預先定義`+`， `-`， `*`， `/`， `%`， `<<`， `>>`， `&`， `|`， `^`， `&&`， `||`， `==`， `!=`， `<`， `>`， `<=`，和`>=`二元運算子，可讓您提供每一個運算元是上面所列的型別。
*  `?:`條件運算子。

在常數運算式中允許下列轉換：

*  身分識別轉換
*  數值轉換
*  列舉型別轉換
*  常數運算式轉換
*  提供轉換的來源是常數運算式評估為 null 值的隱含和明確參考轉換。

其他轉換，包括 boxing，常數運算式中不允許非 null 值 unboxing 和隱含參考轉換。 例如: 
```csharp
class C {
    const object i = 5;         // error: boxing conversion not permitted
    const object str = "hello"; // error: implicit reference conversion
}
```
初始化 i 是錯誤，因為 boxing 轉換為必要項。 Str 的初始化是錯誤，因為從非 null 值的隱含參考轉換為必要項。

每當運算式，可滿足上述需求，是在編譯時期評估運算式。 這是 true，即使運算式是包含非常數的建構較大運算式的子運算式。

常數運算式的編譯時期評估為非常數運算式，執行階段評估使用相同的規則，不同之處在於其中的執行階段評估就會擲出例外狀況，評估編譯時間會導致發生編譯時期錯誤。

除非常數運算式明確放入`unchecked`內容、 發生編譯時期評估的運算式一律在整數型別算術運算和轉換的溢位會造成編譯時期錯誤 ([常數運算式](expressions.md#constant-expressions))。

常數運算式可以出現在下面所列的內容。 在這些內容中，如果運算式不能在編譯時期完整評估，就會發生編譯時期錯誤。

*  常數宣告 ([常數](classes.md#constants))。
*  列舉型別成員宣告 ([列舉成員](enums.md#enum-members))。
*  預設引數的型式參數清單 ([方法參數](classes.md#method-parameters))
*  `case` 標籤`switch`陳述式 ([switch 陳述式](statements.md#the-switch-statement))。
*  `goto case` 陳述式 ([goto 陳述式](statements.md#the-goto-statement))。
*  維度中陣列建立運算式的長度 ([陣列建立運算式](expressions.md#array-creation-expressions))，其中包含初始設定式。
*  屬性 ([屬性](attributes.md))。

隱含的常數運算式轉換 ([隱含的常數運算式轉換](conversions.md#implicit-constant-expression-conversions)) 允許類型的常數運算式`int`轉換成`sbyte`， `byte`， `short`， `ushort`， `uint`，或`ulong`，前提是常數運算式的值是目的地類型的範圍內。

## <a name="boolean-expressions"></a>布林運算式

A *boolean_expression*是運算式，產生的結果為類型`bool`; 可直接或透過應用程式的`operator true`在下列中所指定的特定內容中。

```antlr
boolean_expression
    : expression
    ;
```

控制條件式運算式*if_statement* ([if 陳述式](statements.md#the-if-statement))， *while_statement* ([while 陳述式](statements.md#the-while-statement))，*do_statement* ([do 陳述式](statements.md#the-do-statement))，或*for_statement* ([陳述式](statements.md#the-for-statement)) 是*boolean_運算式*。 控制條件式運算式`?:`運算子 ([條件運算子](expressions.md#conditional-operator)) 會遵循相同的規則*boolean_expression*，但基於運算子的分類優先順序作為*conditional_or_expression*。

A *boolean_expression* `E`必須是能夠產生之類型值的`bool`、，如下所示：

*  如果`E`隱含轉換為`bool`則會在執行階段套用該隱含轉換。
*  否則一元運算子多載解析 ([一元運算子多載解析](expressions.md#unary-operator-overload-resolution)) 用來尋找唯一的最佳實作的運算子`true`上`E`，而且該實作會在執行階段套用。
*  如果找到這樣的運算子，則繫結階段會發生錯誤。

`DBBool`結構中的型別[資料庫，則為 true 的型別](structs.md#database-boolean-type)提供之類型的實作範例`operator true`和`operator false`。
